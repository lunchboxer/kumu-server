
(function(l, i, v, e) { v = l.createElement(i); v.async = 1; v.src = '//' + (location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; e = l.getElementsByTagName(i)[0]; e.parentNode.insertBefore(v, e)})(document, 'script');
var app = (function () {
    'use strict';

    function noop() { }
    const identity = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function is_promise(value) {
        return value && typeof value === 'object' && typeof value.then === 'function';
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function validate_store(store, name) {
        if (!store || typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, callback) {
        const unsub = store.subscribe(callback);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value(store) {
        let value;
        subscribe(store, _ => value = _)();
        return value;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, fn) {
        return definition[1]
            ? assign({}, assign(ctx.$$scope.ctx, definition[1](fn ? fn(ctx) : {})))
            : ctx.$$scope.ctx;
    }
    function get_slot_changes(definition, ctx, changed, fn) {
        return definition[1]
            ? assign({}, assign(ctx.$$scope.changed || {}, definition[1](fn ? fn(changed) : {})))
            : ctx.$$scope.changed || {};
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    let running = false;
    function run_tasks() {
        tasks.forEach(task => {
            if (!task[0](now())) {
                tasks.delete(task);
                task[1]();
            }
        });
        running = tasks.size > 0;
        if (running)
            raf(run_tasks);
    }
    function loop(fn) {
        let task;
        if (!running) {
            running = true;
            raf(run_tasks);
        }
        return {
            promise: new Promise(fulfil => {
                tasks.add(task = [fn, fulfil]);
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else
            node.setAttribute(attribute, value);
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_data(text, data) {
        data = '' + data;
        if (text.data !== data)
            text.data = data;
    }
    function set_input_value(input, value) {
        if (value != null || input.value) {
            input.value = value;
        }
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
    }
    function select_value(select) {
        const selected_option = select.querySelector(':checked') || select.options[0];
        return selected_option && selected_option.__value;
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }
    class HtmlTag {
        constructor(html, anchor = null) {
            this.e = element('div');
            this.a = anchor;
            this.u(html);
        }
        m(target, anchor = null) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(target, this.n[i], anchor);
            }
            this.t = target;
        }
        u(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        p(html) {
            this.d();
            this.u(html);
            this.m(this.t, this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    let stylesheet;
    let active = 0;
    let current_rules = {};
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        if (!current_rules[name]) {
            if (!stylesheet) {
                const style = element('style');
                document.head.appendChild(style);
                stylesheet = style.sheet;
            }
            current_rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        node.style.animation = (node.style.animation || '')
            .split(', ')
            .filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        )
            .join(', ');
        if (name && !--active)
            clear_rules();
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            let i = stylesheet.cssRules.length;
            while (i--)
                stylesheet.deleteRule(i);
            current_rules = {};
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error(`Function called outside component initialization`);
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = current_component;
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            callbacks.slice().forEach(fn => fn(event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    function flush() {
        const seen_callbacks = new Set();
        do {
            // first, call beforeUpdate functions
            // and update components
            while (dirty_components.length) {
                const component = dirty_components.shift();
                set_current_component(component);
                update(component.$$);
            }
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    callback();
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
    }
    function update($$) {
        if ($$.fragment) {
            $$.update($$.dirty);
            run_all($$.before_update);
            $$.fragment.p($$.dirty, $$.ctx);
            $$.dirty = null;
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_in_transition(node, fn, params) {
        let config = fn(node, params);
        let running = false;
        let animation_name;
        let task;
        let uid = 0;
        function cleanup() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
            tick(0, 1);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            if (task)
                task.abort();
            running = true;
            add_render_callback(() => dispatch(node, true, 'start'));
            task = loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(1, 0);
                        dispatch(node, true, 'end');
                        cleanup();
                        return running = false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(t, 1 - t);
                    }
                }
                return running;
            });
        }
        let started = false;
        return {
            start() {
                if (started)
                    return;
                delete_rule(node);
                if (is_function(config)) {
                    config = config();
                    wait().then(go);
                }
                else {
                    go();
                }
            },
            invalidate() {
                started = false;
            },
            end() {
                if (running) {
                    cleanup();
                    running = false;
                }
            }
        };
    }
    function create_out_transition(node, fn, params) {
        let config = fn(node, params);
        let running = true;
        let animation_name;
        const group = outros;
        group.r += 1;
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            add_render_callback(() => dispatch(node, false, 'start'));
            loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(0, 1);
                        dispatch(node, false, 'end');
                        if (!--group.r) {
                            // this will result in `end()` being called,
                            // so we don't need to clean up here
                            run_all(group.c);
                        }
                        return false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(1 - t, t);
                    }
                }
                return running;
            });
        }
        if (is_function(config)) {
            wait().then(() => {
                // @ts-ignore
                config = config();
                go();
            });
        }
        else {
            go();
        }
        return {
            end(reset) {
                if (reset && config.tick) {
                    config.tick(1, 0);
                }
                if (running) {
                    if (animation_name)
                        delete_rule(node, animation_name);
                    running = false;
                }
            }
        };
    }
    function create_bidirectional_transition(node, fn, params, intro) {
        let config = fn(node, params);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function init(program, duration) {
            const d = program.b - t;
            duration *= Math.abs(d);
            return {
                a: t,
                b: program.b,
                d,
                duration,
                start: program.start,
                end: program.start + duration,
                group: program.group
            };
        }
        function go(b) {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            const program = {
                start: now() + delay,
                b
            };
            if (!b) {
                // @ts-ignore todo: improve typings
                program.group = outros;
                outros.r += 1;
            }
            if (running_program) {
                pending_program = program;
            }
            else {
                // if this is an intro, and there's a delay, we need to do
                // an initial tick and/or apply CSS animation immediately
                if (css) {
                    clear_animation();
                    animation_name = create_rule(node, t, b, duration, delay, easing, css);
                }
                if (b)
                    tick(0, 1);
                running_program = init(program, duration);
                add_render_callback(() => dispatch(node, b, 'start'));
                loop(now => {
                    if (pending_program && now > pending_program.start) {
                        running_program = init(pending_program, duration);
                        pending_program = null;
                        dispatch(node, running_program.b, 'start');
                        if (css) {
                            clear_animation();
                            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                        }
                    }
                    if (running_program) {
                        if (now >= running_program.end) {
                            tick(t = running_program.b, 1 - t);
                            dispatch(node, running_program.b, 'end');
                            if (!pending_program) {
                                // we're done
                                if (running_program.b) {
                                    // intro — we can tidy up immediately
                                    clear_animation();
                                }
                                else {
                                    // outro — needs to be coordinated
                                    if (!--running_program.group.r)
                                        run_all(running_program.group.c);
                                }
                            }
                            running_program = null;
                        }
                        else if (now >= running_program.start) {
                            const p = now - running_program.start;
                            t = running_program.a + running_program.d * easing(p / running_program.duration);
                            tick(t, 1 - t);
                        }
                    }
                    return !!(running_program || pending_program);
                });
            }
        }
        return {
            run(b) {
                if (is_function(config)) {
                    wait().then(() => {
                        // @ts-ignore
                        config = config();
                        go(b);
                    });
                }
                else {
                    go(b);
                }
            },
            end() {
                clear_animation();
                running_program = pending_program = null;
            }
        };
    }

    function handle_promise(promise, info) {
        const token = info.token = {};
        function update(type, index, key, value) {
            if (info.token !== token)
                return;
            info.resolved = key && { [key]: value };
            const child_ctx = assign(assign({}, info.ctx), info.resolved);
            const block = type && (info.current = type)(child_ctx);
            if (info.block) {
                if (info.blocks) {
                    info.blocks.forEach((block, i) => {
                        if (i !== index && block) {
                            group_outros();
                            transition_out(block, 1, 1, () => {
                                info.blocks[i] = null;
                            });
                            check_outros();
                        }
                    });
                }
                else {
                    info.block.d(1);
                }
                block.c();
                transition_in(block, 1);
                block.m(info.mount(), info.anchor);
                flush();
            }
            info.block = block;
            if (info.blocks)
                info.blocks[index] = block;
        }
        if (is_promise(promise)) {
            const current_component = get_current_component();
            promise.then(value => {
                set_current_component(current_component);
                update(info.then, 1, info.value, value);
                set_current_component(null);
            }, error => {
                set_current_component(current_component);
                update(info.catch, 2, info.error, error);
                set_current_component(null);
            });
            // if we previously had a then/catch block, destroy it
            if (info.current !== info.pending) {
                update(info.pending, 0);
                return true;
            }
        }
        else {
            if (info.current !== info.then) {
                update(info.then, 1, info.value, promise);
                return true;
            }
            info.resolved = { [info.value]: promise };
        }
    }

    const globals = (typeof window !== 'undefined' ? window : global);

    function destroy_block(block, lookup) {
        block.d(1);
        lookup.delete(block.key);
    }
    function outro_and_destroy_block(block, lookup) {
        transition_out(block, 1, 1, () => {
            lookup.delete(block.key);
        });
    }
    function update_keyed_each(old_blocks, changed, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
        let o = old_blocks.length;
        let n = list.length;
        let i = o;
        const old_indexes = {};
        while (i--)
            old_indexes[old_blocks[i].key] = i;
        const new_blocks = [];
        const new_lookup = new Map();
        const deltas = new Map();
        i = n;
        while (i--) {
            const child_ctx = get_context(ctx, list, i);
            const key = get_key(child_ctx);
            let block = lookup.get(key);
            if (!block) {
                block = create_each_block(key, child_ctx);
                block.c();
            }
            else if (dynamic) {
                block.p(changed, child_ctx);
            }
            new_lookup.set(key, new_blocks[i] = block);
            if (key in old_indexes)
                deltas.set(key, Math.abs(i - old_indexes[key]));
        }
        const will_move = new Set();
        const did_move = new Set();
        function insert(block) {
            transition_in(block, 1);
            block.m(node, next);
            lookup.set(block.key, block);
            next = block.first;
            n--;
        }
        while (o && n) {
            const new_block = new_blocks[n - 1];
            const old_block = old_blocks[o - 1];
            const new_key = new_block.key;
            const old_key = old_block.key;
            if (new_block === old_block) {
                // do nothing
                next = new_block.first;
                o--;
                n--;
            }
            else if (!new_lookup.has(old_key)) {
                // remove old block
                destroy(old_block, lookup);
                o--;
            }
            else if (!lookup.has(new_key) || will_move.has(new_key)) {
                insert(new_block);
            }
            else if (did_move.has(old_key)) {
                o--;
            }
            else if (deltas.get(new_key) > deltas.get(old_key)) {
                did_move.add(new_key);
                insert(new_block);
            }
            else {
                will_move.add(old_key);
                o--;
            }
        }
        while (o--) {
            const old_block = old_blocks[o];
            if (!new_lookup.has(old_block.key))
                destroy(old_block, lookup);
        }
        while (n)
            insert(new_blocks[n - 1]);
        return new_blocks;
    }

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }

    function bind(component, name, callback) {
        if (component.$$.props.indexOf(name) === -1)
            return;
        component.$$.bound[name] = callback;
        callback(component.$$.ctx[name]);
    }
    function mount_component(component, target, anchor) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment.m(target, anchor);
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        if (component.$$.fragment) {
            run_all(component.$$.on_destroy);
            component.$$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            component.$$.on_destroy = component.$$.fragment = null;
            component.$$.ctx = {};
        }
    }
    function make_dirty(component, key) {
        if (!component.$$.dirty) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty = blank_object();
        }
        component.$$.dirty[key] = true;
    }
    function init(component, options, instance, create_fragment, not_equal, prop_names) {
        const parent_component = current_component;
        set_current_component(component);
        const props = options.props || {};
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props: prop_names,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : []),
            // everything else
            callbacks: blank_object(),
            dirty: null
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, props, (key, value) => {
                if ($$.ctx && not_equal($$.ctx[key], $$.ctx[key] = value)) {
                    if ($$.bound[key])
                        $$.bound[key](value);
                    if (ready)
                        make_dirty(component, key);
                }
            })
            : props;
        $$.update();
        ready = true;
        run_all($$.before_update);
        $$.fragment = create_fragment($$.ctx);
        if (options.target) {
            if (options.hydrate) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment.l(children(options.target));
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor);
            flush();
        }
        set_current_component(parent_component);
    }
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set() {
            // overridden by instance, if it has props
        }
    }
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error(`'target' is a required option`);
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn(`Component was already destroyed`); // eslint-disable-line no-console
            };
        }
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe,
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    /**
     * Derived value store by synchronizing one or more readable stores and
     * applying an aggregation function over its input values.
     * @param {Stores} stores input stores
     * @param {function(Stores=, function(*)=):*}fn function callback that aggregates the values
     * @param {*=}initial_value when used asynchronously
     */
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => store.subscribe((value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    const selfDestructDelay = 4000; // milliseconds

    const generateKey = () => {
      // timestamp with 4 random characters on the end
      const now = new Date();
      const randomCode = Math.floor((1 + Math.random()) * 0x10000)
        .toString(16)
        .substring(1);
      return now.toISOString() + randomCode
    };

    const createNotificationStore = () => {
      const { subscribe, update } = writable({});

      return {
        subscribe,
        remove: id => {
          update(previous => {
            const { [id]: value, ...withoutThisOne } = previous;
            return withoutThisOne
          });
        },
        add: function (message) {
          const id = generateKey();
          update(previous => ({ ...previous, [id]: message }));
          setTimeout(() => {
            this.remove(id);
          }, selfDestructDelay);
        }
      }
    };

    const notifications = createNotificationStore();

    function cubicOut(t) {
        const f = t - 1.0;
        return f * f * f + 1.0;
    }

    function fade(node, { delay = 0, duration = 400 }) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            css: t => `opacity: ${t * o}`
        };
    }
    function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 }) {
        const style = getComputedStyle(node);
        const target_opacity = +style.opacity;
        const transform = style.transform === 'none' ? '' : style.transform;
        const od = target_opacity * (1 - opacity);
        return {
            delay,
            duration,
            easing,
            css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
        };
    }
    function slide(node, { delay = 0, duration = 400, easing = cubicOut }) {
        const style = getComputedStyle(node);
        const opacity = +style.opacity;
        const height = parseFloat(style.height);
        const padding_top = parseFloat(style.paddingTop);
        const padding_bottom = parseFloat(style.paddingBottom);
        const margin_top = parseFloat(style.marginTop);
        const margin_bottom = parseFloat(style.marginBottom);
        const border_top_width = parseFloat(style.borderTopWidth);
        const border_bottom_width = parseFloat(style.borderBottomWidth);
        return {
            delay,
            duration,
            easing,
            css: t => `overflow: hidden;` +
                `opacity: ${Math.min(t * 20, 1) * opacity};` +
                `height: ${t * height}px;` +
                `padding-top: ${t * padding_top}px;` +
                `padding-bottom: ${t * padding_bottom}px;` +
                `margin-top: ${t * margin_top}px;` +
                `margin-bottom: ${t * margin_bottom}px;` +
                `border-top-width: ${t * border_top_width}px;` +
                `border-bottom-width: ${t * border_bottom_width}px;`
        };
    }

    /* admin/src/components/notifications/NotificationItem.svelte generated by Svelte v3.9.2 */

    const file = "admin/src/components/notifications/NotificationItem.svelte";

    function create_fragment(ctx) {
    	var div, button, t0, t1, div_class_value, dispose;

    	return {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			t0 = space();
    			t1 = text(ctx.text);
    			attr(button, "class", "delete");
    			add_location(button, file, 14, 2, 342);
    			attr(div, "class", div_class_value = "notification is-" + ctx.type + " svelte-zww63w");
    			add_location(div, file, 13, 0, 303);
    			dispose = listen(button, "click", ctx.remove);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, button);
    			append(div, t0);
    			append(div, t1);
    		},

    		p: function update(changed, ctx) {
    			if (changed.text) {
    				set_data(t1, ctx.text);
    			}

    			if ((changed.type) && div_class_value !== (div_class_value = "notification is-" + ctx.type + " svelte-zww63w")) {
    				attr(div, "class", div_class_value);
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			dispose();
    		}
    	};
    }

    function instance($$self, $$props, $$invalidate) {
    	let { id, message } = $$props;

      const remove = () => notifications.remove(id);

    	const writable_props = ['id', 'message'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<NotificationItem> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('id' in $$props) $$invalidate('id', id = $$props.id);
    		if ('message' in $$props) $$invalidate('message', message = $$props.message);
    	};

    	let text, type;

    	$$self.$$.update = ($$dirty = { message: 1 }) => {
    		if ($$dirty.message) { $$invalidate('text', text = !message || typeof message === 'string' ? message : message.text); }
    		if ($$dirty.message) { $$invalidate('type', type = !message || typeof message === 'string' ? 'info' : message.type); }
    	};

    	return { id, message, remove, text, type };
    }

    class NotificationItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, ["id", "message"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.id === undefined && !('id' in props)) {
    			console.warn("<NotificationItem> was created without expected prop 'id'");
    		}
    		if (ctx.message === undefined && !('message' in props)) {
    			console.warn("<NotificationItem> was created without expected prop 'message'");
    		}
    	}

    	get id() {
    		throw new Error("<NotificationItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<NotificationItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get message() {
    		throw new Error("<NotificationItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set message(value) {
    		throw new Error("<NotificationItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/notifications/NotificationList.svelte generated by Svelte v3.9.2 */

    const file$1 = "admin/src/components/notifications/NotificationList.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.id = list[i][0];
    	child_ctx.message = list[i][1];
    	return child_ctx;
    }

    // (30:0) {#if $notifications}
    function create_if_block(ctx) {
    	var div, each_blocks = [], each_1_lookup = new Map(), current;

    	var each_value = Object.entries(ctx.$notifications);

    	const get_key = ctx => ctx.id;

    	for (var i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			div = element("div");

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();
    			attr(div, "class", "notification-list svelte-1t0onhw");
    			add_location(div, file$1, 30, 0, 623);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(div, null);

    			current = true;
    		},

    		p: function update(changed, ctx) {
    			const each_value = Object.entries(ctx.$notifications);

    			group_outros();
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block, null, get_each_context);
    			check_outros();
    		},

    		i: function intro(local) {
    			if (current) return;
    			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

    			current = true;
    		},

    		o: function outro(local) {
    			for (i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d();
    		}
    	};
    }

    // (32:2) {#each Object.entries($notifications) as [id, message] (id)}
    function create_each_block(key_1, ctx) {
    	var div, t, div_transition, current;

    	var notificationitem = new NotificationItem({
    		props: { message: ctx.message, id: ctx.id },
    		$$inline: true
    	});

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			div = element("div");
    			notificationitem.$$.fragment.c();
    			t = space();
    			add_location(div, file$1, 32, 2, 720);
    			this.first = div;
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			mount_component(notificationitem, div, null);
    			append(div, t);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var notificationitem_changes = {};
    			if (changed.$notifications) notificationitem_changes.message = ctx.message;
    			if (changed.$notifications) notificationitem_changes.id = ctx.id;
    			notificationitem.$set(notificationitem_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(notificationitem.$$.fragment, local);

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, fly, {x:400}, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(notificationitem.$$.fragment, local);

    			if (!div_transition) div_transition = create_bidirectional_transition(div, fly, {x:400}, false);
    			div_transition.run(0);

    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			destroy_component(notificationitem);

    			if (detaching) {
    				if (div_transition) div_transition.end();
    			}
    		}
    	};
    }

    function create_fragment$1(ctx) {
    	var if_block_anchor, current;

    	var if_block = (ctx.$notifications) && create_if_block(ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.$notifications) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let $notifications;

    	validate_store(notifications, 'notifications');
    	component_subscribe($$self, notifications, $$value => { $notifications = $$value; $$invalidate('$notifications', $notifications); });

    	return { $notifications };
    }

    class NotificationList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, []);
    	}
    }

    const fetch = window.fetch;

    // const endpoint = "development" === 'production'
    //   ? process.env.PROD_API_ENDPOINT
    //   : process.env.DEV_API_ENDPOINT

    const request = async (query, variables) => {
      const coldAuth = window.localStorage.getItem('auth');
      const token = coldAuth ? JSON.parse(coldAuth).token : null;
      const body = typeof query === 'function'
        ? query(variables)
        : JSON.stringify({ query, variables });
      const response = await fetch("http://192.168.1.9:4000/api", {
        method: 'post',
        headers: {
          'Content-Type': 'application/json',
          Authorization: token || ''
        },
        body
      });
      const result = response && await response.json();
      if (response && response.ok && !result.errors && result.data) {
        return result.data
      } else {
        throw result.errors
      }
    };

    const LOGIN = /* GraphQL */`
  mutation Login($username: String!, $password: String!) {
    login(username: $username, password: $password) {
      token
      user {
        id
        username
      }
    }
  }
`;

    const getAuthFromStorage = () => {
      const coldAuth = window.localStorage.getItem('auth');
      const user = coldAuth ? JSON.parse(coldAuth).user : null;
      const token = coldAuth ? JSON.parse(coldAuth).token : null;
      return { user, token }
    };

    const createAuthStore = () => {
      // pull token and user from localStorage if it's there
      const { user, token } = getAuthFromStorage();
      const { subscribe, set, update } = writable({ ...user, token });

      return {
        subscribe,
        login: async (username, password) => {
          const response = await request(LOGIN, { username, password });
          window.localStorage.setItem('auth', JSON.stringify(response.login));
          update(previous => ({
            ...previous,
            ...response.login.user,
            token: response.login.token
          }));
        },
        logout: () => {
          const { user } = getAuthFromStorage();
          window.localStorage.removeItem('auth');
          set({});
          return user && user.username
        }
      }
    };

    const auth = createAuthStore();

    function regexparam (str, loose) {
    	if (str instanceof RegExp) return { keys:false, pattern:str };
    	var c, o, tmp, ext, keys=[], pattern='', arr = str.split('/');
    	arr[0] || arr.shift();

    	while (tmp = arr.shift()) {
    		c = tmp[0];
    		if (c === '*') {
    			keys.push('wild');
    			pattern += '/(.*)';
    		} else if (c === ':') {
    			o = tmp.indexOf('?', 1);
    			ext = tmp.indexOf('.', 1);
    			keys.push( tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length) );
    			pattern += !!~o && !~ext ? '(?:/([^/]+?))?' : '/([^/]+?)';
    			if (!!~ext) pattern += (!!~o ? '?' : '') + '\\' + tmp.substring(ext);
    		} else {
    			pattern += '/' + tmp;
    		}
    	}

    	return {
    		keys: keys,
    		pattern: new RegExp('^' + pattern + (loose ? '(?=$|\/)' : '\/?$'), 'i')
    	};
    }

    /* node_modules/svelte-spa-router/Router.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1, Object: Object_1 } = globals;

    function create_fragment$2(ctx) {
    	var switch_instance_anchor, current;

    	var switch_value = ctx.component;

    	function switch_props(ctx) {
    		return {
    			props: { params: ctx.componentParams },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		var switch_instance = new switch_value(switch_props(ctx));
    	}

    	return {
    		c: function create() {
    			if (switch_instance) switch_instance.$$.fragment.c();
    			switch_instance_anchor = empty();
    		},

    		l: function claim(nodes) {
    			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert(target, switch_instance_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var switch_instance_changes = {};
    			if (changed.componentParams) switch_instance_changes.params = ctx.componentParams;

    			if (switch_value !== (switch_value = ctx.component)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;
    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});
    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));

    					switch_instance.$$.fragment.c();
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			}

    			else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(switch_instance_anchor);
    			}

    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};
    }

    /**
     * @typedef {Object} Location
     * @property {string} location - Location (page/view), for example `/book`
     * @property {string} [querystring] - Querystring from the hash, as a string not parsed
     */
    /**
     * Returns the current location from the hash.
     *
     * @returns {Location} Location object
     * @private
     */
    function getLocation() {
    const hashPosition = window.location.href.indexOf('#/');
    let location = (hashPosition > -1) ? window.location.href.substr(hashPosition + 1) : '/';

    // Check if there's a querystring
    const qsPosition = location.indexOf('?');
    let querystring = '';
    if (qsPosition > -1) {
        querystring = location.substr(qsPosition + 1);
        location = location.substr(0, qsPosition);
    }

    return {location, querystring}
    }

    /**
     * Readable store that returns the current full location (incl. querystring)
     */
    const loc = readable(
    getLocation(),
    // eslint-disable-next-line prefer-arrow-callback
    function start(set) {
        const update = () => {
            set(getLocation());
        };
        window.addEventListener('hashchange', update, false);

        return function stop() {
            window.removeEventListener('hashchange', update, false);
        }
    }
    );

    /**
     * Readable store that returns the current location
     */
    const location = derived(
    loc,
    ($loc) => $loc.location
    );

    /**
     * Readable store that returns the current querystring
     */
    const querystring = derived(
    loc,
    ($loc) => $loc.querystring
    );

    /**
     * Navigates to a new page programmatically.
     *
     * @param {string} location - Path to navigate to (must start with `/`)
     */
    function push(location) {
    if (!location || location.length < 1 || location.charAt(0) != '/') {
        throw Error('Invalid parameter location')
    }

    // Execute this code when the current call stack is complete
    setTimeout(() => {
        window.location.hash = '#' + location;
    }, 0);
    }

    /**
     * Navigates back in history (equivalent to pressing the browser's back button).
     */
    function pop() {
    // Execute this code when the current call stack is complete
    setTimeout(() => {
        window.history.back();
    }, 0);
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let $loc;

    	validate_store(loc, 'loc');
    	component_subscribe($$self, loc, $$value => { $loc = $$value; $$invalidate('$loc', $loc); });

    	/**
     * Dictionary of all routes, in the format `'/path': component`.
     *
     * For example:
     * ````js
     * import HomeRoute from './routes/HomeRoute.svelte'
     * import BooksRoute from './routes/BooksRoute.svelte'
     * import NotFoundRoute from './routes/NotFoundRoute.svelte'
     * routes = {
     *     '/': HomeRoute,
     *     '/books': BooksRoute,
     *     '*': NotFoundRoute
     * }
     * ````
     */
    let { routes = {} } = $$props;

    /**
     * Container for a route: path, component
     */
    class RouteItem {
        /**
         * Initializes the object and creates a regular expression from the path, using regexparam.
         *
         * @param {string} path - Path to the route (must start with '/' or '*')
         * @param {SvelteComponent} component - Svelte component for the route
         */
        constructor(path, component) {
            // Path must be a regular or expression, or a string starting with '/' or '*'
            if (!path || 
                (typeof path == 'string' && (path.length < 1 || (path.charAt(0) != '/' && path.charAt(0) != '*'))) ||
                (typeof path == 'object' && !(path instanceof RegExp))
            ) {
                throw Error('Invalid value for "path" argument')
            }

            const {pattern, keys} = regexparam(path);

            this.path = path;
            this.component = component;

            this._pattern = pattern;
            this._keys = keys;
        }

        /**
         * Checks if `path` matches the current route.
         * If there's a match, will return the list of parameters from the URL (if any).
         * In case of no match, the method will return `null`.
         *
         * @param {string} path - Path to test
         * @returns {null|Object.<string, string>} List of paramters from the URL if there's a match, or `null` otherwise.
         */
        match(path) {
            const matches = this._pattern.exec(path);
            if (matches === null) {
                return null
            }

            // If the input was a regular expression, this._keys would be false, so return matches as is
            if (this._keys === false) {
                return matches
            }

            const out = {};
            let i = 0;
            while (i < this._keys.length) {
                out[this._keys[i]] = matches[++i] || null;
            }
            return out
        }
    }

    // We need an iterable: if it's not a Map, use Object.entries
    const routesIterable = (routes instanceof Map) ? routes : Object.entries(routes);

    // Set up all routes
    const routesList = [];
    for (const [path, route] of routesIterable) {
        routesList.push(new RouteItem(path, route));
    }

    // Props for the component to render
    let component = null;
    let componentParams = {};

    	const writable_props = ['routes'];
    	Object_1.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Router> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('routes' in $$props) $$invalidate('routes', routes = $$props.routes);
    	};

    	$$self.$$.update = ($$dirty = { component: 1, $loc: 1 }) => {
    		if ($$dirty.component || $$dirty.$loc) { {
                // Find a route matching the location
                $$invalidate('component', component = null);
                let i = 0;
                while (!component && i < routesList.length) {
                    const match = routesList[i].match($loc.location);
                    if (match) {
                        $$invalidate('component', component = routesList[i].component);
                        $$invalidate('componentParams', componentParams = match);
                    }
                    i++;
                }
            } }
    	};

    	return { routes, component, componentParams };
    }

    class Router extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, ["routes"]);
    	}

    	get routes() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set routes(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/NotFound.svelte generated by Svelte v3.9.2 */

    const file$2 = "admin/src/components/NotFound.svelte";

    // (30:4) {:else }
    function create_else_block(ctx) {
    	var p, t0, t1, t2;

    	return {
    		c: function create() {
    			p = element("p");
    			t0 = text("The path '");
    			t1 = text(ctx.$location);
    			t2 = text("' leads nowhere");
    			add_location(p, file$2, 30, 6, 614);
    		},

    		m: function mount(target, anchor) {
    			insert(target, p, anchor);
    			append(p, t0);
    			append(p, t1);
    			append(p, t2);
    		},

    		p: function update(changed, ctx) {
    			if (changed.$location) {
    				set_data(t1, ctx.$location);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(p);
    			}
    		}
    	};
    }

    // (28:4) {#if params.item}
    function create_if_block$1(ctx) {
    	var p, t0, strong, t1_value = ctx.params.item + "", t1, t2, t3_value = ctx.params.id ? `'${ctx.params.id}'` : '' + "", t3, t4;

    	return {
    		c: function create() {
    			p = element("p");
    			t0 = text("The ");
    			strong = element("strong");
    			t1 = text(t1_value);
    			t2 = space();
    			t3 = text(t3_value);
    			t4 = text(" could not be found.");
    			add_location(strong, file$2, 28, 13, 504);
    			add_location(p, file$2, 28, 6, 497);
    		},

    		m: function mount(target, anchor) {
    			insert(target, p, anchor);
    			append(p, t0);
    			append(p, strong);
    			append(strong, t1);
    			append(p, t2);
    			append(p, t3);
    			append(p, t4);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.params) && t1_value !== (t1_value = ctx.params.item + "")) {
    				set_data(t1, t1_value);
    			}

    			if ((changed.params) && t3_value !== (t3_value = ctx.params.id ? `'${ctx.params.id}'` : '' + "")) {
    				set_data(t3, t3_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(p);
    			}
    		}
    	};
    }

    function create_fragment$3(ctx) {
    	var div, section, h1, i0, t0, t1, h2, t3, t4, p, t5, a, t7, t8, button, i1, t9, dispose;

    	function select_block_type(changed, ctx) {
    		if (ctx.params.item) return create_if_block$1;
    		return create_else_block;
    	}

    	var current_block_type = select_block_type(null, ctx);
    	var if_block = current_block_type(ctx);

    	return {
    		c: function create() {
    			div = element("div");
    			section = element("section");
    			h1 = element("h1");
    			i0 = element("i");
    			t0 = text(" 404");
    			t1 = space();
    			h2 = element("h2");
    			h2.textContent = "resource not found";
    			t3 = space();
    			if_block.c();
    			t4 = space();
    			p = element("p");
    			t5 = text("It might be wise to return to the ");
    			a = element("a");
    			a.textContent = "main page";
    			t7 = text(".");
    			t8 = space();
    			button = element("button");
    			i1 = element("i");
    			t9 = text(" go back");
    			attr(i0, "class", "fas fa-frown-open");
    			add_location(i0, file$2, 24, 35, 366);
    			attr(h1, "class", "title is-1 primary svelte-vcg24b");
    			add_location(h1, file$2, 24, 4, 335);
    			attr(h2, "class", "subtitle is-3");
    			add_location(h2, file$2, 25, 4, 418);
    			attr(a, "href", "#/");
    			add_location(a, file$2, 32, 41, 709);
    			add_location(p, file$2, 32, 4, 672);
    			attr(i1, "class", "fas fa-backward");
    			add_location(i1, file$2, 33, 50, 791);
    			attr(button, "class", "button is-link svelte-vcg24b");
    			add_location(button, file$2, 33, 4, 745);
    			add_location(section, file$2, 23, 2, 321);
    			attr(div, "class", "container svelte-vcg24b");
    			add_location(div, file$2, 22, 0, 295);
    			dispose = listen(button, "click", pop);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, section);
    			append(section, h1);
    			append(h1, i0);
    			append(h1, t0);
    			append(section, t1);
    			append(section, h2);
    			append(section, t3);
    			if_block.m(section, null);
    			append(section, t4);
    			append(section, p);
    			append(p, t5);
    			append(p, a);
    			append(p, t7);
    			append(section, t8);
    			append(section, button);
    			append(button, i1);
    			append(button, t9);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(changed, ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);
    				if (if_block) {
    					if_block.c();
    					if_block.m(section, t4);
    				}
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			if_block.d();
    			dispose();
    		}
    	};
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let $location;

    	validate_store(location, 'location');
    	component_subscribe($$self, location, $$value => { $location = $$value; $$invalidate('$location', $location); });

    	let { params = {} } = $$props;

    	const writable_props = ['params'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<NotFound> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('params' in $$props) $$invalidate('params', params = $$props.params);
    	};

    	return { params, $location };
    }

    class NotFound extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, ["params"]);
    	}

    	get params() {
    		throw new Error("<NotFound>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<NotFound>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/dashboard/Dashboard.svelte generated by Svelte v3.9.2 */

    const file$3 = "admin/src/components/dashboard/Dashboard.svelte";

    function create_fragment$4(ctx) {
    	var t, h1;

    	return {
    		c: function create() {
    			t = space();
    			h1 = element("h1");
    			h1.textContent = "Dashboard";
    			document.title = "Dashboard";
    			attr(h1, "class", "title");
    			add_location(h1, file$3, 7, 0, 77);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    			insert(target, h1, anchor);
    		},

    		p: noop,
    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    				detach(h1);
    			}
    		}
    	};
    }

    class Dashboard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, null, create_fragment$4, safe_not_equal, []);
    	}
    }

    const GET_SEMESTERS = /* GraphQL */`
  {
    semesters {
      id
      name
      startDate
      endDate
      groups {
        id
        name
      }
    }
  }
`;

    const CREATE_SEMESTER = /* GraphQL */`
  mutation createSemester($input: SemesterInput!) {
    createSemester(input: $input) {
      name
      id
      startDate
      endDate
      groups {
        id
        name
      }
    }
  }
`;

    const DELETE_SEMESTER = /* GraphQL */`
  mutation deleteSemester($id: ID!) {
    deleteSemester(id: $id) {
      id
      name
    }
  }
`;

    const UPDATE_SEMESTER = /* GraphQL */`
  mutation updateSemester($id: ID!, $input: SemesterInput!) {
  updateSemester(input: $input, id: $id) {
    name
      id
      startDate
      endDate
      groups {
        id
        name
      }
  }
}
`;

    const createSemesterStore = () => {
      const { subscribe, set, update } = writable();

      return {
        subscribe,
        get: async () => {
          const response = await request(GET_SEMESTERS);
          set(response.semesters);
        },
        remove: async id => {
          const response = await request(DELETE_SEMESTER, { id });
          update(previous =>
            previous.filter(semester => response.deleteSemester.id !== semester.id)
          );
        },
        create: async (input) => {
          const response = await request(CREATE_SEMESTER, { input });
          update(previous => [...previous, response.createSemester]);
        },
        patch: async (id, input) => {
          const response = await request(UPDATE_SEMESTER, { id, input });
          update(previous => previous.map((semester) => {
            if (semester.id !== id) return semester
            return response.updateSemester
          }));
        }
      }
    };

    const semesters = createSemesterStore();

    /* admin/src/components/Error.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$1 } = globals;

    const file$4 = "admin/src/components/Error.svelte";

    // (30:0) {#if getMessage(errors)}
    function create_if_block$2(ctx) {
    	var p, span, i, strong, t1, t2_value = ctx.getMessage(ctx.errors) + "", t2;

    	return {
    		c: function create() {
    			p = element("p");
    			span = element("span");
    			i = element("i");
    			strong = element("strong");
    			strong.textContent = "Error:";
    			t1 = text(" ");
    			t2 = text(t2_value);
    			attr(i, "class", "fas fa-exclamation-triangle svelte-sljdgk");
    			add_location(i, file$4, 31, 32, 591);
    			attr(strong, "class", "svelte-sljdgk");
    			add_location(strong, file$4, 31, 75, 634);
    			attr(span, "class", "error-message svelte-sljdgk");
    			add_location(span, file$4, 31, 4, 563);
    			attr(p, "class", "error svelte-sljdgk");
    			add_location(p, file$4, 30, 0, 541);
    		},

    		m: function mount(target, anchor) {
    			insert(target, p, anchor);
    			append(p, span);
    			append(span, i);
    			append(span, strong);
    			append(span, t1);
    			append(span, t2);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.errors) && t2_value !== (t2_value = ctx.getMessage(ctx.errors) + "")) {
    				set_data(t2, t2_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(p);
    			}
    		}
    	};
    }

    function create_fragment$5(ctx) {
    	var show_if = ctx.getMessage(ctx.errors), if_block_anchor;

    	var if_block = (show_if) && create_if_block$2(ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},

    		l: function claim(nodes) {
    			throw new Error_1$1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (changed.errors) show_if = ctx.getMessage(ctx.errors);

    			if (show_if) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$2(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { errors = '' } = $$props;

      const getMessage = (errors) => {
        if (!errors) return false
        return (Array.isArray(errors))
          ? errors.map(error => error.message).join('\n')
          : !errors.message ? errors : errors.message
      };

    	const writable_props = ['errors'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Error> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('errors' in $$props) $$invalidate('errors', errors = $$props.errors);
    	};

    	return { errors, getMessage };
    }

    class Error$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$5, safe_not_equal, ["errors"]);
    	}

    	get errors() {
    		throw new Error_1$1("<Error>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set errors(value) {
    		throw new Error_1$1("<Error>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/ConfirmDelete.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$2 } = globals;

    const file$5 = "admin/src/components/ConfirmDelete.svelte";

    function create_fragment$6(ctx) {
    	var h1, t0, t1, t2, t3, p, t4, span, t6, t7, div, button0, t8, t9, button1, current, dispose;

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	const default_slot_template = ctx.$$slots.default;
    	const default_slot = create_slot(default_slot_template, ctx, null);

    	return {
    		c: function create() {
    			h1 = element("h1");
    			t0 = text("Delete ");
    			t1 = text(ctx.name);
    			t2 = space();
    			error.$$.fragment.c();
    			t3 = space();
    			p = element("p");
    			t4 = text("Permanently delete ");

    			if (!default_slot) {
    				span = element("span");
    				span.textContent = "item";
    			}

    			if (default_slot) default_slot.c();
    			t6 = text("\n  ?");
    			t7 = space();
    			div = element("div");
    			button0 = element("button");
    			t8 = text("Delete");
    			t9 = space();
    			button1 = element("button");
    			button1.textContent = "Keep it";
    			attr(h1, "class", "title");
    			add_location(h1, file$5, 24, 0, 436);

    			if (!default_slot) {
    				attr(span, "class", "placeholder");
    				add_location(span, file$5, 27, 4, 525);
    			}

    			add_location(p, file$5, 26, 0, 492);
    			attr(button0, "class", "button is-primary");
    			button0.disabled = ctx.loading;
    			toggle_class(button0, "is-loading", ctx.loading);
    			add_location(button0, file$5, 31, 2, 605);
    			attr(button1, "class", "button");
    			add_location(button1, file$5, 33, 2, 731);
    			attr(div, "class", "buttons svelte-5zwjdi");
    			add_location(div, file$5, 30, 0, 581);

    			dispose = [
    				listen(button0, "click", ctx.handleDelete),
    				listen(button1, "click", ctx.close)
    			];
    		},

    		l: function claim(nodes) {
    			if (default_slot) default_slot.l(p_nodes);
    			throw new Error_1$2("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, h1, anchor);
    			append(h1, t0);
    			append(h1, t1);
    			insert(target, t2, anchor);
    			mount_component(error, target, anchor);
    			insert(target, t3, anchor);
    			insert(target, p, anchor);
    			append(p, t4);

    			if (!default_slot) {
    				append(p, span);
    			}

    			else {
    				default_slot.m(p, null);
    			}

    			append(p, t6);
    			insert(target, t7, anchor);
    			insert(target, div, anchor);
    			append(div, button0);
    			append(button0, t8);
    			append(div, t9);
    			append(div, button1);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (!current || changed.name) {
    				set_data(t1, ctx.name);
    			}

    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);

    			if (default_slot && default_slot.p && changed.$$scope) {
    				default_slot.p(
    					get_slot_changes(default_slot_template, ctx, changed, null),
    					get_slot_context(default_slot_template, ctx, null)
    				);
    			}

    			if (!current || changed.loading) {
    				button0.disabled = ctx.loading;
    			}

    			if (changed.loading) {
    				toggle_class(button0, "is-loading", ctx.loading);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);

    			transition_in(default_slot, local);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			transition_out(default_slot, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h1);
    				detach(t2);
    			}

    			destroy_component(error, detaching);

    			if (detaching) {
    				detach(t3);
    				detach(p);
    			}

    			if (default_slot) default_slot.d(detaching);

    			if (detaching) {
    				detach(t7);
    				detach(div);
    			}

    			run_all(dispose);
    		}
    	};
    }

    function instance$5($$self, $$props, $$invalidate) {
    	

      const dispatch = createEventDispatcher();

      let { open = false, loading = false, errors = '', name = "item" } = $$props;

      const handleDelete = async () => {
        dispatch('delete');
      };
      const close = () => { $$invalidate('open', open = false); };

    	const writable_props = ['open', 'loading', 'errors', 'name'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<ConfirmDelete> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;

    	$$self.$set = $$props => {
    		if ('open' in $$props) $$invalidate('open', open = $$props.open);
    		if ('loading' in $$props) $$invalidate('loading', loading = $$props.loading);
    		if ('errors' in $$props) $$invalidate('errors', errors = $$props.errors);
    		if ('name' in $$props) $$invalidate('name', name = $$props.name);
    		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
    	};

    	return {
    		open,
    		loading,
    		errors,
    		name,
    		handleDelete,
    		close,
    		$$slots,
    		$$scope
    	};
    }

    class ConfirmDelete extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$6, safe_not_equal, ["open", "loading", "errors", "name"]);
    	}

    	get open() {
    		throw new Error_1$2("<ConfirmDelete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set open(value) {
    		throw new Error_1$2("<ConfirmDelete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loading() {
    		throw new Error_1$2("<ConfirmDelete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loading(value) {
    		throw new Error_1$2("<ConfirmDelete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get errors() {
    		throw new Error_1$2("<ConfirmDelete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set errors(value) {
    		throw new Error_1$2("<ConfirmDelete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error_1$2("<ConfirmDelete>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error_1$2("<ConfirmDelete>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/Modal.svelte generated by Svelte v3.9.2 */

    const file$6 = "admin/src/components/Modal.svelte";

    // (24:0) {#if open}
    function create_if_block$3(ctx) {
    	var div2, div0, div0_transition, t, div1, section, div1_intro, div1_outro, current, dispose;

    	const default_slot_template = ctx.$$slots.default;
    	const default_slot = create_slot(default_slot_template, ctx, null);

    	return {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t = space();
    			div1 = element("div");
    			section = element("section");

    			if (default_slot) default_slot.c();
    			attr(div0, "class", "modal-background");
    			add_location(div0, file$6, 25, 2, 371);

    			attr(section, "class", "section svelte-1v8v78e");
    			add_location(section, file$6, 35, 4, 611);
    			attr(div1, "class", "modal-content svelte-1v8v78e");
    			add_location(div1, file$6, 30, 2, 488);
    			attr(div2, "class", "modal is-active");
    			add_location(div2, file$6, 24, 0, 339);
    			dispose = listen(div0, "click", ctx.close);
    		},

    		l: function claim(nodes) {
    			if (default_slot) default_slot.l(section_nodes);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div2, anchor);
    			append(div2, div0);
    			append(div2, t);
    			append(div2, div1);
    			append(div1, section);

    			if (default_slot) {
    				default_slot.m(section, null);
    			}

    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (default_slot && default_slot.p && changed.$$scope) {
    				default_slot.p(
    					get_slot_changes(default_slot_template, ctx, changed, null),
    					get_slot_context(default_slot_template, ctx, null)
    				);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			if (local) {
    				add_render_callback(() => {
    					if (!div0_transition) div0_transition = create_bidirectional_transition(div0, fade, { duration: 200 }, true);
    					div0_transition.run(1);
    				});
    			}

    			transition_in(default_slot, local);

    			add_render_callback(() => {
    				if (div1_outro) div1_outro.end(1);
    				if (!div1_intro) div1_intro = create_in_transition(div1, fly, { duration: 200, y: -300 });
    				div1_intro.start();
    			});

    			current = true;
    		},

    		o: function outro(local) {
    			if (local) {
    				if (!div0_transition) div0_transition = create_bidirectional_transition(div0, fade, { duration: 200 }, false);
    				div0_transition.run(0);
    			}

    			transition_out(default_slot, local);
    			if (div1_intro) div1_intro.invalidate();

    			div1_outro = create_out_transition(div1, fly, { duration: 200, y: 300 });

    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div2);
    				if (div0_transition) div0_transition.end();
    			}

    			if (default_slot) default_slot.d(detaching);

    			if (detaching) {
    				if (div1_outro) div1_outro.end();
    			}

    			dispose();
    		}
    	};
    }

    function create_fragment$7(ctx) {
    	var if_block_anchor, current;

    	var if_block = (ctx.open) && create_if_block$3(ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.open) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { open = false } = $$props;

      const close = () => {
        $$invalidate('open', open = false);
      };

    	const writable_props = ['open'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Modal> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;

    	$$self.$set = $$props => {
    		if ('open' in $$props) $$invalidate('open', open = $$props.open);
    		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
    	};

    	return { open, close, $$slots, $$scope };
    }

    class Modal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$7, safe_not_equal, ["open"]);
    	}

    	get open() {
    		throw new Error("<Modal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set open(value) {
    		throw new Error("<Modal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/DeleteItem.svelte generated by Svelte v3.9.2 */

    // (35:2) {#if open}
    function create_if_block$4(ctx) {
    	var updating_open, current;

    	function confirmdelete_open_binding(value) {
    		ctx.confirmdelete_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let confirmdelete_props = {
    		name: ctx.type,
    		errors: ctx.errors,
    		loading: ctx.loading,
    		$$slots: { default: [create_default_slot_1] },
    		$$scope: { ctx }
    	};
    	if (ctx.open !== void 0) {
    		confirmdelete_props.open = ctx.open;
    	}
    	var confirmdelete = new ConfirmDelete({
    		props: confirmdelete_props,
    		$$inline: true
    	});

    	binding_callbacks.push(() => bind(confirmdelete, 'open', confirmdelete_open_binding));
    	confirmdelete.$on("delete", ctx.handleDelete);

    	return {
    		c: function create() {
    			confirmdelete.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(confirmdelete, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var confirmdelete_changes = {};
    			if (changed.type) confirmdelete_changes.name = ctx.type;
    			if (changed.errors) confirmdelete_changes.errors = ctx.errors;
    			if (changed.loading) confirmdelete_changes.loading = ctx.loading;
    			if (changed.$$scope || changed.name || changed.type) confirmdelete_changes.$$scope = { changed, ctx };
    			if (!updating_open && changed.open) {
    				confirmdelete_changes.open = ctx.open;
    			}
    			confirmdelete.$set(confirmdelete_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(confirmdelete.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(confirmdelete.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(confirmdelete, detaching);
    		}
    	};
    }

    // (36:2) <ConfirmDelete name={type} on:delete={handleDelete} {errors} {loading} bind:open>
    function create_default_slot_1(ctx) {
    	var t0, t1, t2, t3, t4;

    	return {
    		c: function create() {
    			t0 = text("the ");
    			t1 = text(ctx.type);
    			t2 = text(" '");
    			t3 = text(ctx.name);
    			t4 = text("'");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t0, anchor);
    			insert(target, t1, anchor);
    			insert(target, t2, anchor);
    			insert(target, t3, anchor);
    			insert(target, t4, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (changed.type) {
    				set_data(t1, ctx.type);
    			}

    			if (changed.name) {
    				set_data(t3, ctx.name);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t0);
    				detach(t1);
    				detach(t2);
    				detach(t3);
    				detach(t4);
    			}
    		}
    	};
    }

    // (34:0) <Modal bind:open>
    function create_default_slot(ctx) {
    	var if_block_anchor, current;

    	var if_block = (ctx.open) && create_if_block$4(ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.open) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$4(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function create_fragment$8(ctx) {
    	var updating_open, current;

    	function modal_open_binding(value) {
    		ctx.modal_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let modal_props = {
    		$$slots: { default: [create_default_slot] },
    		$$scope: { ctx }
    	};
    	if (ctx.open !== void 0) {
    		modal_props.open = ctx.open;
    	}
    	var modal = new Modal({ props: modal_props, $$inline: true });

    	binding_callbacks.push(() => bind(modal, 'open', modal_open_binding));

    	return {
    		c: function create() {
    			modal.$$.fragment.c();
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			mount_component(modal, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var modal_changes = {};
    			if (changed.$$scope || changed.open || changed.type || changed.errors || changed.loading || changed.name) modal_changes.$$scope = { changed, ctx };
    			if (!updating_open && changed.open) {
    				modal_changes.open = ctx.open;
    			}
    			modal.$set(modal_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(modal, detaching);
    		}
    	};
    }

    function instance$7($$self, $$props, $$invalidate) {
    	

      let { id, store, type = '', name = '', open = false } = $$props;
      let errors = '';
      let loading = false;
      let { next = '' } = $$props;

      const handleDelete = async () => {
        $$invalidate('loading', loading = true);
        try {
          await store.remove(id);
          next ? push(next) : pop();
          $$invalidate('open', open = false);
          notifications.add({ text: `${type} '${name}' deleted`, type: 'success' });
        } catch (error) {
          $$invalidate('errors', errors = error);
          notifications.add({
            text: `Could not delete ${type} '${name}'`, type: 'danger'
          });
        } finally {
          $$invalidate('loading', loading = false);
        }
      };

    	const writable_props = ['id', 'store', 'type', 'name', 'open', 'next'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<DeleteItem> was created with unknown prop '${key}'`);
    	});

    	function confirmdelete_open_binding(value) {
    		open = value;
    		$$invalidate('open', open);
    	}

    	function modal_open_binding(value) {
    		open = value;
    		$$invalidate('open', open);
    	}

    	$$self.$set = $$props => {
    		if ('id' in $$props) $$invalidate('id', id = $$props.id);
    		if ('store' in $$props) $$invalidate('store', store = $$props.store);
    		if ('type' in $$props) $$invalidate('type', type = $$props.type);
    		if ('name' in $$props) $$invalidate('name', name = $$props.name);
    		if ('open' in $$props) $$invalidate('open', open = $$props.open);
    		if ('next' in $$props) $$invalidate('next', next = $$props.next);
    	};

    	return {
    		id,
    		store,
    		type,
    		name,
    		open,
    		errors,
    		loading,
    		next,
    		handleDelete,
    		confirmdelete_open_binding,
    		modal_open_binding
    	};
    }

    class DeleteItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$8, safe_not_equal, ["id", "store", "type", "name", "open", "next"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.id === undefined && !('id' in props)) {
    			console.warn("<DeleteItem> was created without expected prop 'id'");
    		}
    		if (ctx.store === undefined && !('store' in props)) {
    			console.warn("<DeleteItem> was created without expected prop 'store'");
    		}
    	}

    	get id() {
    		throw new Error("<DeleteItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<DeleteItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get store() {
    		throw new Error("<DeleteItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set store(value) {
    		throw new Error("<DeleteItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<DeleteItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<DeleteItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<DeleteItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<DeleteItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get open() {
    		throw new Error("<DeleteItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set open(value) {
    		throw new Error("<DeleteItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get next() {
    		throw new Error("<DeleteItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set next(value) {
    		throw new Error("<DeleteItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/Input.svelte generated by Svelte v3.9.2 */

    const file$7 = "admin/src/components/Input.svelte";

    // (30:4) {#if description}
    function create_if_block_7(ctx) {
    	var p, t;

    	return {
    		c: function create() {
    			p = element("p");
    			t = text(ctx.description);
    			attr(p, "class", "help is-info");
    			attr(p, "id", ctx.descriptionId);
    			add_location(p, file$7, 30, 10, 797);
    		},

    		m: function mount(target, anchor) {
    			insert(target, p, anchor);
    			append(p, t);
    		},

    		p: function update(changed, ctx) {
    			if (changed.description) {
    				set_data(t, ctx.description);
    			}

    			if (changed.descriptionId) {
    				attr(p, "id", ctx.descriptionId);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(p);
    			}
    		}
    	};
    }

    // (36:12) {#if type === 'text'}
    function create_if_block_6(ctx) {
    	var input_1, dispose;

    	return {
    		c: function create() {
    			input_1 = element("input");
    			attr(input_1, "name", ctx.name);
    			attr(input_1, "class", "input svelte-193htxd");
    			attr(input_1, "type", "text");
    			attr(input_1, "pattern", ctx.pattern);
    			attr(input_1, "minlength", ctx.minlength);
    			attr(input_1, "maxlength", ctx.maxlength);
    			input_1.required = ctx.required;
    			attr(input_1, "aria-describedby", ctx.descriptionId);
    			attr(input_1, "placeholder", ctx.placeholder);
    			toggle_class(input_1, "error", ctx.error);
    			add_location(input_1, file$7, 36, 12, 1070);

    			dispose = [
    				listen(input_1, "input", ctx.input_1_input_handler),
    				listen(input_1, "input", ctx.checkValidity),
    				listen(input_1, "invalid", prevent_default(ctx.checkValidity))
    			];
    		},

    		m: function mount(target, anchor) {
    			insert(target, input_1, anchor);

    			set_input_value(input_1, ctx.value);

    			ctx.input_1_binding(input_1);
    		},

    		p: function update(changed, ctx) {
    			if (changed.value && (input_1.value !== ctx.value)) set_input_value(input_1, ctx.value);

    			if (changed.name) {
    				attr(input_1, "name", ctx.name);
    			}

    			if (changed.pattern) {
    				attr(input_1, "pattern", ctx.pattern);
    			}

    			if (changed.minlength) {
    				attr(input_1, "minlength", ctx.minlength);
    			}

    			if (changed.maxlength) {
    				attr(input_1, "maxlength", ctx.maxlength);
    			}

    			if (changed.required) {
    				input_1.required = ctx.required;
    			}

    			if (changed.descriptionId) {
    				attr(input_1, "aria-describedby", ctx.descriptionId);
    			}

    			if (changed.placeholder) {
    				attr(input_1, "placeholder", ctx.placeholder);
    			}

    			if (changed.error) {
    				toggle_class(input_1, "error", ctx.error);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(input_1);
    			}

    			ctx.input_1_binding(null);
    			run_all(dispose);
    		}
    	};
    }

    // (40:12) {#if type === 'password'}
    function create_if_block_5(ctx) {
    	var input_1, dispose;

    	return {
    		c: function create() {
    			input_1 = element("input");
    			attr(input_1, "name", ctx.name);
    			attr(input_1, "class", "input svelte-193htxd");
    			attr(input_1, "type", "password");
    			attr(input_1, "pattern", ctx.pattern);
    			attr(input_1, "minlength", ctx.minlength);
    			attr(input_1, "maxlength", ctx.maxlength);
    			input_1.required = ctx.required;
    			attr(input_1, "aria-describedby", ctx.descriptionId);
    			attr(input_1, "placeholder", ctx.placeholder);
    			toggle_class(input_1, "error", ctx.error);
    			add_location(input_1, file$7, 40, 12, 1403);

    			dispose = [
    				listen(input_1, "input", ctx.input_1_input_handler_1),
    				listen(input_1, "input", ctx.checkValidity),
    				listen(input_1, "invalid", prevent_default(ctx.checkValidity))
    			];
    		},

    		m: function mount(target, anchor) {
    			insert(target, input_1, anchor);

    			set_input_value(input_1, ctx.value);

    			ctx.input_1_binding_1(input_1);
    		},

    		p: function update(changed, ctx) {
    			if (changed.value && (input_1.value !== ctx.value)) set_input_value(input_1, ctx.value);

    			if (changed.name) {
    				attr(input_1, "name", ctx.name);
    			}

    			if (changed.pattern) {
    				attr(input_1, "pattern", ctx.pattern);
    			}

    			if (changed.minlength) {
    				attr(input_1, "minlength", ctx.minlength);
    			}

    			if (changed.maxlength) {
    				attr(input_1, "maxlength", ctx.maxlength);
    			}

    			if (changed.required) {
    				input_1.required = ctx.required;
    			}

    			if (changed.descriptionId) {
    				attr(input_1, "aria-describedby", ctx.descriptionId);
    			}

    			if (changed.placeholder) {
    				attr(input_1, "placeholder", ctx.placeholder);
    			}

    			if (changed.error) {
    				toggle_class(input_1, "error", ctx.error);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(input_1);
    			}

    			ctx.input_1_binding_1(null);
    			run_all(dispose);
    		}
    	};
    }

    // (44:12) {#if type === 'date'}
    function create_if_block_4(ctx) {
    	var input_1, dispose;

    	return {
    		c: function create() {
    			input_1 = element("input");
    			attr(input_1, "name", ctx.name);
    			attr(input_1, "class", "input svelte-193htxd");
    			attr(input_1, "type", "date");
    			attr(input_1, "pattern", "^[0-9]" + 4 + "-(1[0-2]|0[1-9])-([1-3][0-9]|0[1-9])$");
    			input_1.required = ctx.required;
    			attr(input_1, "max", ctx.max);
    			attr(input_1, "aria-describedby", ctx.descriptionId);
    			toggle_class(input_1, "error", ctx.error);
    			add_location(input_1, file$7, 44, 12, 1737);

    			dispose = [
    				listen(input_1, "input", ctx.input_1_input_handler_2),
    				listen(input_1, "input", ctx.checkValidity),
    				listen(input_1, "invalid", prevent_default(ctx.checkValidity))
    			];
    		},

    		m: function mount(target, anchor) {
    			insert(target, input_1, anchor);

    			set_input_value(input_1, ctx.value);

    			ctx.input_1_binding_2(input_1);
    		},

    		p: function update(changed, ctx) {
    			if (changed.value) set_input_value(input_1, ctx.value);

    			if (changed.name) {
    				attr(input_1, "name", ctx.name);
    			}

    			if (changed.required) {
    				input_1.required = ctx.required;
    			}

    			if (changed.max) {
    				attr(input_1, "max", ctx.max);
    			}

    			if (changed.descriptionId) {
    				attr(input_1, "aria-describedby", ctx.descriptionId);
    			}

    			if (changed.error) {
    				toggle_class(input_1, "error", ctx.error);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(input_1);
    			}

    			ctx.input_1_binding_2(null);
    			run_all(dispose);
    		}
    	};
    }

    // (48:12) {#if type === 'datetime-local'}
    function create_if_block_3(ctx) {
    	var input_1, dispose;

    	return {
    		c: function create() {
    			input_1 = element("input");
    			attr(input_1, "name", ctx.name);
    			attr(input_1, "class", "input svelte-193htxd");
    			attr(input_1, "type", "datetime-local");
    			input_1.required = ctx.required;
    			attr(input_1, "max", ctx.max);
    			attr(input_1, "aria-describedby", ctx.descriptionId);
    			toggle_class(input_1, "error", ctx.error);
    			add_location(input_1, file$7, 48, 12, 2092);

    			dispose = [
    				listen(input_1, "input", ctx.input_1_input_handler_3),
    				listen(input_1, "input", ctx.checkValidity),
    				listen(input_1, "invalid", prevent_default(ctx.checkValidity))
    			];
    		},

    		m: function mount(target, anchor) {
    			insert(target, input_1, anchor);

    			set_input_value(input_1, ctx.value);

    			ctx.input_1_binding_3(input_1);
    		},

    		p: function update(changed, ctx) {
    			if (changed.value) set_input_value(input_1, ctx.value);

    			if (changed.name) {
    				attr(input_1, "name", ctx.name);
    			}

    			if (changed.required) {
    				input_1.required = ctx.required;
    			}

    			if (changed.max) {
    				attr(input_1, "max", ctx.max);
    			}

    			if (changed.descriptionId) {
    				attr(input_1, "aria-describedby", ctx.descriptionId);
    			}

    			if (changed.error) {
    				toggle_class(input_1, "error", ctx.error);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(input_1);
    			}

    			ctx.input_1_binding_3(null);
    			run_all(dispose);
    		}
    	};
    }

    // (52:12) {#if leftIcon}
    function create_if_block_2(ctx) {
    	var span, i, i_class_value;

    	return {
    		c: function create() {
    			span = element("span");
    			i = element("i");
    			attr(i, "class", i_class_value = "fas fa-" + ctx.leftIcon);
    			add_location(i, file$7, 53, 14, 2434);
    			attr(span, "class", "icon is-small is-left");
    			add_location(span, file$7, 52, 12, 2383);
    		},

    		m: function mount(target, anchor) {
    			insert(target, span, anchor);
    			append(span, i);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.leftIcon) && i_class_value !== (i_class_value = "fas fa-" + ctx.leftIcon)) {
    				attr(i, "class", i_class_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(span);
    			}
    		}
    	};
    }

    // (56:18) {#if rightIcon}
    function create_if_block_1(ctx) {
    	var span, i, i_class_value;

    	return {
    		c: function create() {
    			span = element("span");
    			i = element("i");
    			attr(i, "class", i_class_value = "fas fa-" + ctx.rightIcon);
    			add_location(i, file$7, 57, 14, 2586);
    			attr(span, "class", "icon is-small is-right");
    			add_location(span, file$7, 56, 12, 2534);
    		},

    		m: function mount(target, anchor) {
    			insert(target, span, anchor);
    			append(span, i);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.rightIcon) && i_class_value !== (i_class_value = "fas fa-" + ctx.rightIcon)) {
    				attr(i, "class", i_class_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(span);
    			}
    		}
    	};
    }

    // (61:12) {#if error}
    function create_if_block$5(ctx) {
    	var p, t;

    	return {
    		c: function create() {
    			p = element("p");
    			t = text(ctx.error);
    			attr(p, "class", "help is-danger");
    			add_location(p, file$7, 61, 12, 2695);
    		},

    		m: function mount(target, anchor) {
    			insert(target, p, anchor);
    			append(p, t);
    		},

    		p: function update(changed, ctx) {
    			if (changed.error) {
    				set_data(t, ctx.error);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(p);
    			}
    		}
    	};
    }

    function create_fragment$9(ctx) {
    	var div2, label_1, t0, t1, t2, div1, div0, t3, t4, t5, t6, t7, t8;

    	var if_block0 = (ctx.description) && create_if_block_7(ctx);

    	var if_block1 = (ctx.type === 'text') && create_if_block_6(ctx);

    	var if_block2 = (ctx.type === 'password') && create_if_block_5(ctx);

    	var if_block3 = (ctx.type === 'date') && create_if_block_4(ctx);

    	var if_block4 = (ctx.type === 'datetime-local') && create_if_block_3(ctx);

    	var if_block5 = (ctx.leftIcon) && create_if_block_2(ctx);

    	var if_block6 = (ctx.rightIcon) && create_if_block_1(ctx);

    	var if_block7 = (ctx.error) && create_if_block$5(ctx);

    	return {
    		c: function create() {
    			div2 = element("div");
    			label_1 = element("label");
    			t0 = text(ctx.label);
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			div1 = element("div");
    			div0 = element("div");
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			t4 = space();
    			if (if_block3) if_block3.c();
    			t5 = space();
    			if (if_block4) if_block4.c();
    			t6 = space();
    			if (if_block5) if_block5.c();
    			t7 = space();
    			if (if_block6) if_block6.c();
    			t8 = space();
    			if (if_block7) if_block7.c();
    			attr(label_1, "class", "label");
    			add_location(label_1, file$7, 28, 2, 736);
    			attr(div0, "class", "control");
    			toggle_class(div0, "has-icons-left", ctx.leftIcon);
    			toggle_class(div0, "has-icons-right", ctx.rightIcon);
    			add_location(div0, file$7, 34, 10, 936);
    			attr(div1, "class", "field-body");
    			add_location(div1, file$7, 33, 8, 901);
    			attr(div2, "class", "field");
    			add_location(div2, file$7, 27, 0, 714);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div2, anchor);
    			append(div2, label_1);
    			append(label_1, t0);
    			append(label_1, t1);
    			if (if_block0) if_block0.m(label_1, null);
    			append(div2, t2);
    			append(div2, div1);
    			append(div1, div0);
    			if (if_block1) if_block1.m(div0, null);
    			append(div0, t3);
    			if (if_block2) if_block2.m(div0, null);
    			append(div0, t4);
    			if (if_block3) if_block3.m(div0, null);
    			append(div0, t5);
    			if (if_block4) if_block4.m(div0, null);
    			append(div0, t6);
    			if (if_block5) if_block5.m(div0, null);
    			append(div0, t7);
    			if (if_block6) if_block6.m(div0, null);
    			append(div0, t8);
    			if (if_block7) if_block7.m(div0, null);
    		},

    		p: function update(changed, ctx) {
    			if (changed.label) {
    				set_data(t0, ctx.label);
    			}

    			if (ctx.description) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    				} else {
    					if_block0 = create_if_block_7(ctx);
    					if_block0.c();
    					if_block0.m(label_1, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (ctx.type === 'text') {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    				} else {
    					if_block1 = create_if_block_6(ctx);
    					if_block1.c();
    					if_block1.m(div0, t3);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (ctx.type === 'password') {
    				if (if_block2) {
    					if_block2.p(changed, ctx);
    				} else {
    					if_block2 = create_if_block_5(ctx);
    					if_block2.c();
    					if_block2.m(div0, t4);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (ctx.type === 'date') {
    				if (if_block3) {
    					if_block3.p(changed, ctx);
    				} else {
    					if_block3 = create_if_block_4(ctx);
    					if_block3.c();
    					if_block3.m(div0, t5);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if (ctx.type === 'datetime-local') {
    				if (if_block4) {
    					if_block4.p(changed, ctx);
    				} else {
    					if_block4 = create_if_block_3(ctx);
    					if_block4.c();
    					if_block4.m(div0, t6);
    				}
    			} else if (if_block4) {
    				if_block4.d(1);
    				if_block4 = null;
    			}

    			if (ctx.leftIcon) {
    				if (if_block5) {
    					if_block5.p(changed, ctx);
    				} else {
    					if_block5 = create_if_block_2(ctx);
    					if_block5.c();
    					if_block5.m(div0, t7);
    				}
    			} else if (if_block5) {
    				if_block5.d(1);
    				if_block5 = null;
    			}

    			if (ctx.rightIcon) {
    				if (if_block6) {
    					if_block6.p(changed, ctx);
    				} else {
    					if_block6 = create_if_block_1(ctx);
    					if_block6.c();
    					if_block6.m(div0, t8);
    				}
    			} else if (if_block6) {
    				if_block6.d(1);
    				if_block6 = null;
    			}

    			if (ctx.error) {
    				if (if_block7) {
    					if_block7.p(changed, ctx);
    				} else {
    					if_block7 = create_if_block$5(ctx);
    					if_block7.c();
    					if_block7.m(div0, null);
    				}
    			} else if (if_block7) {
    				if_block7.d(1);
    				if_block7 = null;
    			}

    			if (changed.leftIcon) {
    				toggle_class(div0, "has-icons-left", ctx.leftIcon);
    			}

    			if (changed.rightIcon) {
    				toggle_class(div0, "has-icons-right", ctx.rightIcon);
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div2);
    			}

    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			if (if_block6) if_block6.d();
    			if (if_block7) if_block7.d();
    		}
    	};
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let input;
      let { value, showDescription = false, label = '' } = $$props;
      let error = false;
      let { required = false, pattern = '^.+$', minlength = 1, maxlength = null, type = 'text', description = '', width = '40rem', min = null, max = null, rightIcon = null, leftIcon = null, placeholder = '' } = $$props;

      function checkValidity () {
        $$invalidate('error', error = !input.validity.valid && input.validationMessage ? input.validationMessage : '');
      }

    	const writable_props = ['value', 'showDescription', 'label', 'required', 'pattern', 'minlength', 'maxlength', 'type', 'description', 'width', 'min', 'max', 'rightIcon', 'leftIcon', 'placeholder'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Input> was created with unknown prop '${key}'`);
    	});

    	function input_1_input_handler() {
    		value = this.value;
    		$$invalidate('value', value);
    	}

    	function input_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('input', input = $$value);
    		});
    	}

    	function input_1_input_handler_1() {
    		value = this.value;
    		$$invalidate('value', value);
    	}

    	function input_1_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('input', input = $$value);
    		});
    	}

    	function input_1_input_handler_2() {
    		value = this.value;
    		$$invalidate('value', value);
    	}

    	function input_1_binding_2($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('input', input = $$value);
    		});
    	}

    	function input_1_input_handler_3() {
    		value = this.value;
    		$$invalidate('value', value);
    	}

    	function input_1_binding_3($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('input', input = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ('value' in $$props) $$invalidate('value', value = $$props.value);
    		if ('showDescription' in $$props) $$invalidate('showDescription', showDescription = $$props.showDescription);
    		if ('label' in $$props) $$invalidate('label', label = $$props.label);
    		if ('required' in $$props) $$invalidate('required', required = $$props.required);
    		if ('pattern' in $$props) $$invalidate('pattern', pattern = $$props.pattern);
    		if ('minlength' in $$props) $$invalidate('minlength', minlength = $$props.minlength);
    		if ('maxlength' in $$props) $$invalidate('maxlength', maxlength = $$props.maxlength);
    		if ('type' in $$props) $$invalidate('type', type = $$props.type);
    		if ('description' in $$props) $$invalidate('description', description = $$props.description);
    		if ('width' in $$props) $$invalidate('width', width = $$props.width);
    		if ('min' in $$props) $$invalidate('min', min = $$props.min);
    		if ('max' in $$props) $$invalidate('max', max = $$props.max);
    		if ('rightIcon' in $$props) $$invalidate('rightIcon', rightIcon = $$props.rightIcon);
    		if ('leftIcon' in $$props) $$invalidate('leftIcon', leftIcon = $$props.leftIcon);
    		if ('placeholder' in $$props) $$invalidate('placeholder', placeholder = $$props.placeholder);
    	};

    	let name, descriptionId;

    	$$self.$$.update = ($$dirty = { label: 1, name: 1 }) => {
    		if ($$dirty.label) { $$invalidate('name', name = label.replace(/\W+(.)/g, (match, chr) => chr.toUpperCase())); }
    		if ($$dirty.name) { $$invalidate('descriptionId', descriptionId = `description${name}`); }
    	};

    	return {
    		input,
    		value,
    		showDescription,
    		label,
    		error,
    		required,
    		pattern,
    		minlength,
    		maxlength,
    		type,
    		description,
    		width,
    		min,
    		max,
    		rightIcon,
    		leftIcon,
    		placeholder,
    		checkValidity,
    		name,
    		descriptionId,
    		input_1_input_handler,
    		input_1_binding,
    		input_1_input_handler_1,
    		input_1_binding_1,
    		input_1_input_handler_2,
    		input_1_binding_2,
    		input_1_input_handler_3,
    		input_1_binding_3
    	};
    }

    class Input extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$9, safe_not_equal, ["value", "showDescription", "label", "required", "pattern", "minlength", "maxlength", "type", "description", "width", "min", "max", "rightIcon", "leftIcon", "placeholder"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.value === undefined && !('value' in props)) {
    			console.warn("<Input> was created without expected prop 'value'");
    		}
    	}

    	get value() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showDescription() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showDescription(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get required() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set required(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pattern() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pattern(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get minlength() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minlength(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get maxlength() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set maxlength(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get description() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set description(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get min() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set min(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get max() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set max(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get rightIcon() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set rightIcon(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get leftIcon() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set leftIcon(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var flatpickr = createCommonjsModule(function (module, exports) {
    /* flatpickr v4.6.2, @license MIT */
    (function (global, factory) {
         module.exports = factory() ;
    }(commonjsGlobal, function () {
        /*! *****************************************************************************
        Copyright (c) Microsoft Corporation. All rights reserved.
        Licensed under the Apache License, Version 2.0 (the "License"); you may not use
        this file except in compliance with the License. You may obtain a copy of the
        License at http://www.apache.org/licenses/LICENSE-2.0

        THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
        KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
        WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
        MERCHANTABLITY OR NON-INFRINGEMENT.

        See the Apache Version 2.0 License for specific language governing permissions
        and limitations under the License.
        ***************************************************************************** */

        var __assign = function() {
            __assign = Object.assign || function __assign(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
            };
            return __assign.apply(this, arguments);
        };

        var HOOKS = [
            "onChange",
            "onClose",
            "onDayCreate",
            "onDestroy",
            "onKeyDown",
            "onMonthChange",
            "onOpen",
            "onParseConfig",
            "onReady",
            "onValueUpdate",
            "onYearChange",
            "onPreCalendarPosition",
        ];
        var defaults = {
            _disable: [],
            _enable: [],
            allowInput: false,
            altFormat: "F j, Y",
            altInput: false,
            altInputClass: "form-control input",
            animate: typeof window === "object" &&
                window.navigator.userAgent.indexOf("MSIE") === -1,
            ariaDateFormat: "F j, Y",
            clickOpens: true,
            closeOnSelect: true,
            conjunction: ", ",
            dateFormat: "Y-m-d",
            defaultHour: 12,
            defaultMinute: 0,
            defaultSeconds: 0,
            disable: [],
            disableMobile: false,
            enable: [],
            enableSeconds: false,
            enableTime: false,
            errorHandler: function (err) {
                return typeof console !== "undefined" && console.warn(err);
            },
            getWeek: function (givenDate) {
                var date = new Date(givenDate.getTime());
                date.setHours(0, 0, 0, 0);
                // Thursday in current week decides the year.
                date.setDate(date.getDate() + 3 - ((date.getDay() + 6) % 7));
                // January 4 is always in week 1.
                var week1 = new Date(date.getFullYear(), 0, 4);
                // Adjust to Thursday in week 1 and count number of weeks from date to week1.
                return (1 +
                    Math.round(((date.getTime() - week1.getTime()) / 86400000 -
                        3 +
                        ((week1.getDay() + 6) % 7)) /
                        7));
            },
            hourIncrement: 1,
            ignoredFocusElements: [],
            inline: false,
            locale: "default",
            minuteIncrement: 5,
            mode: "single",
            monthSelectorType: "dropdown",
            nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
            noCalendar: false,
            now: new Date(),
            onChange: [],
            onClose: [],
            onDayCreate: [],
            onDestroy: [],
            onKeyDown: [],
            onMonthChange: [],
            onOpen: [],
            onParseConfig: [],
            onReady: [],
            onValueUpdate: [],
            onYearChange: [],
            onPreCalendarPosition: [],
            plugins: [],
            position: "auto",
            positionElement: undefined,
            prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
            shorthandCurrentMonth: false,
            showMonths: 1,
            static: false,
            time_24hr: false,
            weekNumbers: false,
            wrap: false
        };

        var english = {
            weekdays: {
                shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                longhand: [
                    "Sunday",
                    "Monday",
                    "Tuesday",
                    "Wednesday",
                    "Thursday",
                    "Friday",
                    "Saturday",
                ]
            },
            months: {
                shorthand: [
                    "Jan",
                    "Feb",
                    "Mar",
                    "Apr",
                    "May",
                    "Jun",
                    "Jul",
                    "Aug",
                    "Sep",
                    "Oct",
                    "Nov",
                    "Dec",
                ],
                longhand: [
                    "January",
                    "February",
                    "March",
                    "April",
                    "May",
                    "June",
                    "July",
                    "August",
                    "September",
                    "October",
                    "November",
                    "December",
                ]
            },
            daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
            firstDayOfWeek: 0,
            ordinal: function (nth) {
                var s = nth % 100;
                if (s > 3 && s < 21)
                    return "th";
                switch (s % 10) {
                    case 1:
                        return "st";
                    case 2:
                        return "nd";
                    case 3:
                        return "rd";
                    default:
                        return "th";
                }
            },
            rangeSeparator: " to ",
            weekAbbreviation: "Wk",
            scrollTitle: "Scroll to increment",
            toggleTitle: "Click to toggle",
            amPM: ["AM", "PM"],
            yearAriaLabel: "Year",
            hourAriaLabel: "Hour",
            minuteAriaLabel: "Minute",
            time_24hr: false
        };

        var pad = function (number) { return ("0" + number).slice(-2); };
        var int = function (bool) { return (bool === true ? 1 : 0); };
        /* istanbul ignore next */
        function debounce(func, wait, immediate) {
            if (immediate === void 0) { immediate = false; }
            var timeout;
            return function () {
                var context = this, args = arguments;
                timeout !== null && clearTimeout(timeout);
                timeout = window.setTimeout(function () {
                    timeout = null;
                    if (!immediate)
                        func.apply(context, args);
                }, wait);
                if (immediate && !timeout)
                    func.apply(context, args);
            };
        }
        var arrayify = function (obj) {
            return obj instanceof Array ? obj : [obj];
        };

        function toggleClass(elem, className, bool) {
            if (bool === true)
                return elem.classList.add(className);
            elem.classList.remove(className);
        }
        function createElement(tag, className, content) {
            var e = window.document.createElement(tag);
            className = className || "";
            content = content || "";
            e.className = className;
            if (content !== undefined)
                e.textContent = content;
            return e;
        }
        function clearNode(node) {
            while (node.firstChild)
                node.removeChild(node.firstChild);
        }
        function findParent(node, condition) {
            if (condition(node))
                return node;
            else if (node.parentNode)
                return findParent(node.parentNode, condition);
            return undefined; // nothing found
        }
        function createNumberInput(inputClassName, opts) {
            var wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
            if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
                numInput.type = "number";
            }
            else {
                numInput.type = "text";
                numInput.pattern = "\\d*";
            }
            if (opts !== undefined)
                for (var key in opts)
                    numInput.setAttribute(key, opts[key]);
            wrapper.appendChild(numInput);
            wrapper.appendChild(arrowUp);
            wrapper.appendChild(arrowDown);
            return wrapper;
        }
        function getEventTarget(event) {
            if (typeof event.composedPath === "function") {
                var path = event.composedPath();
                return path[0];
            }
            return event.target;
        }

        var doNothing = function () { return undefined; };
        var monthToStr = function (monthNumber, shorthand, locale) { return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber]; };
        var revFormat = {
            D: doNothing,
            F: function (dateObj, monthName, locale) {
                dateObj.setMonth(locale.months.longhand.indexOf(monthName));
            },
            G: function (dateObj, hour) {
                dateObj.setHours(parseFloat(hour));
            },
            H: function (dateObj, hour) {
                dateObj.setHours(parseFloat(hour));
            },
            J: function (dateObj, day) {
                dateObj.setDate(parseFloat(day));
            },
            K: function (dateObj, amPM, locale) {
                dateObj.setHours((dateObj.getHours() % 12) +
                    12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
            },
            M: function (dateObj, shortMonth, locale) {
                dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
            },
            S: function (dateObj, seconds) {
                dateObj.setSeconds(parseFloat(seconds));
            },
            U: function (_, unixSeconds) { return new Date(parseFloat(unixSeconds) * 1000); },
            W: function (dateObj, weekNum, locale) {
                var weekNumber = parseInt(weekNum);
                var date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
                date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
                return date;
            },
            Y: function (dateObj, year) {
                dateObj.setFullYear(parseFloat(year));
            },
            Z: function (_, ISODate) { return new Date(ISODate); },
            d: function (dateObj, day) {
                dateObj.setDate(parseFloat(day));
            },
            h: function (dateObj, hour) {
                dateObj.setHours(parseFloat(hour));
            },
            i: function (dateObj, minutes) {
                dateObj.setMinutes(parseFloat(minutes));
            },
            j: function (dateObj, day) {
                dateObj.setDate(parseFloat(day));
            },
            l: doNothing,
            m: function (dateObj, month) {
                dateObj.setMonth(parseFloat(month) - 1);
            },
            n: function (dateObj, month) {
                dateObj.setMonth(parseFloat(month) - 1);
            },
            s: function (dateObj, seconds) {
                dateObj.setSeconds(parseFloat(seconds));
            },
            u: function (_, unixMillSeconds) {
                return new Date(parseFloat(unixMillSeconds));
            },
            w: doNothing,
            y: function (dateObj, year) {
                dateObj.setFullYear(2000 + parseFloat(year));
            }
        };
        var tokenRegex = {
            D: "(\\w+)",
            F: "(\\w+)",
            G: "(\\d\\d|\\d)",
            H: "(\\d\\d|\\d)",
            J: "(\\d\\d|\\d)\\w+",
            K: "",
            M: "(\\w+)",
            S: "(\\d\\d|\\d)",
            U: "(.+)",
            W: "(\\d\\d|\\d)",
            Y: "(\\d{4})",
            Z: "(.+)",
            d: "(\\d\\d|\\d)",
            h: "(\\d\\d|\\d)",
            i: "(\\d\\d|\\d)",
            j: "(\\d\\d|\\d)",
            l: "(\\w+)",
            m: "(\\d\\d|\\d)",
            n: "(\\d\\d|\\d)",
            s: "(\\d\\d|\\d)",
            u: "(.+)",
            w: "(\\d\\d|\\d)",
            y: "(\\d{2})"
        };
        var formats = {
            // get the date in UTC
            Z: function (date) { return date.toISOString(); },
            // weekday name, short, e.g. Thu
            D: function (date, locale, options) {
                return locale.weekdays.shorthand[formats.w(date, locale, options)];
            },
            // full month name e.g. January
            F: function (date, locale, options) {
                return monthToStr(formats.n(date, locale, options) - 1, false, locale);
            },
            // padded hour 1-12
            G: function (date, locale, options) {
                return pad(formats.h(date, locale, options));
            },
            // hours with leading zero e.g. 03
            H: function (date) { return pad(date.getHours()); },
            // day (1-30) with ordinal suffix e.g. 1st, 2nd
            J: function (date, locale) {
                return locale.ordinal !== undefined
                    ? date.getDate() + locale.ordinal(date.getDate())
                    : date.getDate();
            },
            // AM/PM
            K: function (date, locale) { return locale.amPM[int(date.getHours() > 11)]; },
            // shorthand month e.g. Jan, Sep, Oct, etc
            M: function (date, locale) {
                return monthToStr(date.getMonth(), true, locale);
            },
            // seconds 00-59
            S: function (date) { return pad(date.getSeconds()); },
            // unix timestamp
            U: function (date) { return date.getTime() / 1000; },
            W: function (date, _, options) {
                return options.getWeek(date);
            },
            // full year e.g. 2016
            Y: function (date) { return date.getFullYear(); },
            // day in month, padded (01-30)
            d: function (date) { return pad(date.getDate()); },
            // hour from 1-12 (am/pm)
            h: function (date) { return (date.getHours() % 12 ? date.getHours() % 12 : 12); },
            // minutes, padded with leading zero e.g. 09
            i: function (date) { return pad(date.getMinutes()); },
            // day in month (1-30)
            j: function (date) { return date.getDate(); },
            // weekday name, full, e.g. Thursday
            l: function (date, locale) {
                return locale.weekdays.longhand[date.getDay()];
            },
            // padded month number (01-12)
            m: function (date) { return pad(date.getMonth() + 1); },
            // the month number (1-12)
            n: function (date) { return date.getMonth() + 1; },
            // seconds 0-59
            s: function (date) { return date.getSeconds(); },
            // Unix Milliseconds
            u: function (date) { return date.getTime(); },
            // number of the day of the week
            w: function (date) { return date.getDay(); },
            // last two digits of year e.g. 16 for 2016
            y: function (date) { return String(date.getFullYear()).substring(2); }
        };

        var createDateFormatter = function (_a) {
            var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
            return function (dateObj, frmt, overrideLocale) {
                var locale = overrideLocale || l10n;
                if (config.formatDate !== undefined) {
                    return config.formatDate(dateObj, frmt, locale);
                }
                return frmt
                    .split("")
                    .map(function (c, i, arr) {
                    return formats[c] && arr[i - 1] !== "\\"
                        ? formats[c](dateObj, locale, config)
                        : c !== "\\"
                            ? c
                            : "";
                })
                    .join("");
            };
        };
        var createDateParser = function (_a) {
            var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
            return function (date, givenFormat, timeless, customLocale) {
                if (date !== 0 && !date)
                    return undefined;
                var locale = customLocale || l10n;
                var parsedDate;
                var dateOrig = date;
                if (date instanceof Date)
                    parsedDate = new Date(date.getTime());
                else if (typeof date !== "string" &&
                    date.toFixed !== undefined // timestamp
                )
                    // create a copy
                    parsedDate = new Date(date);
                else if (typeof date === "string") {
                    // date string
                    var format = givenFormat || (config || defaults).dateFormat;
                    var datestr = String(date).trim();
                    if (datestr === "today") {
                        parsedDate = new Date();
                        timeless = true;
                    }
                    else if (/Z$/.test(datestr) ||
                        /GMT$/.test(datestr) // datestrings w/ timezone
                    )
                        parsedDate = new Date(date);
                    else if (config && config.parseDate)
                        parsedDate = config.parseDate(date, format);
                    else {
                        parsedDate =
                            !config || !config.noCalendar
                                ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0)
                                : new Date(new Date().setHours(0, 0, 0, 0));
                        var matched = void 0, ops = [];
                        for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
                            var token_1 = format[i];
                            var isBackSlash = token_1 === "\\";
                            var escaped = format[i - 1] === "\\" || isBackSlash;
                            if (tokenRegex[token_1] && !escaped) {
                                regexStr += tokenRegex[token_1];
                                var match = new RegExp(regexStr).exec(date);
                                if (match && (matched = true)) {
                                    ops[token_1 !== "Y" ? "push" : "unshift"]({
                                        fn: revFormat[token_1],
                                        val: match[++matchIndex]
                                    });
                                }
                            }
                            else if (!isBackSlash)
                                regexStr += "."; // don't really care
                            ops.forEach(function (_a) {
                                var fn = _a.fn, val = _a.val;
                                return (parsedDate = fn(parsedDate, val, locale) || parsedDate);
                            });
                        }
                        parsedDate = matched ? parsedDate : undefined;
                    }
                }
                /* istanbul ignore next */
                if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
                    config.errorHandler(new Error("Invalid date provided: " + dateOrig));
                    return undefined;
                }
                if (timeless === true)
                    parsedDate.setHours(0, 0, 0, 0);
                return parsedDate;
            };
        };
        /**
         * Compute the difference in dates, measured in ms
         */
        function compareDates(date1, date2, timeless) {
            if (timeless === void 0) { timeless = true; }
            if (timeless !== false) {
                return (new Date(date1.getTime()).setHours(0, 0, 0, 0) -
                    new Date(date2.getTime()).setHours(0, 0, 0, 0));
            }
            return date1.getTime() - date2.getTime();
        }
        var isBetween = function (ts, ts1, ts2) {
            return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
        };
        var duration = {
            DAY: 86400000
        };

        if (typeof Object.assign !== "function") {
            Object.assign = function (target) {
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                if (!target) {
                    throw TypeError("Cannot convert undefined or null to object");
                }
                var _loop_1 = function (source) {
                    if (source) {
                        Object.keys(source).forEach(function (key) { return (target[key] = source[key]); });
                    }
                };
                for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
                    var source = args_1[_a];
                    _loop_1(source);
                }
                return target;
            };
        }

        var DEBOUNCED_CHANGE_MS = 300;
        function FlatpickrInstance(element, instanceConfig) {
            var self = {
                config: __assign({}, defaults, flatpickr.defaultConfig),
                l10n: english
            };
            self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
            self._handlers = [];
            self.pluginElements = [];
            self.loadedPlugins = [];
            self._bind = bind;
            self._setHoursFromDate = setHoursFromDate;
            self._positionCalendar = positionCalendar;
            self.changeMonth = changeMonth;
            self.changeYear = changeYear;
            self.clear = clear;
            self.close = close;
            self._createElement = createElement;
            self.destroy = destroy;
            self.isEnabled = isEnabled;
            self.jumpToDate = jumpToDate;
            self.open = open;
            self.redraw = redraw;
            self.set = set;
            self.setDate = setDate;
            self.toggle = toggle;
            function setupHelperFunctions() {
                self.utils = {
                    getDaysInMonth: function (month, yr) {
                        if (month === void 0) { month = self.currentMonth; }
                        if (yr === void 0) { yr = self.currentYear; }
                        if (month === 1 && ((yr % 4 === 0 && yr % 100 !== 0) || yr % 400 === 0))
                            return 29;
                        return self.l10n.daysInMonth[month];
                    }
                };
            }
            function init() {
                self.element = self.input = element;
                self.isOpen = false;
                parseConfig();
                setupLocale();
                setupInputs();
                setupDates();
                setupHelperFunctions();
                if (!self.isMobile)
                    build();
                bindEvents();
                if (self.selectedDates.length || self.config.noCalendar) {
                    if (self.config.enableTime) {
                        setHoursFromDate(self.config.noCalendar
                            ? self.latestSelectedDateObj || self.config.minDate
                            : undefined);
                    }
                    updateValue(false);
                }
                setCalendarWidth();
                self.showTimeInput =
                    self.selectedDates.length > 0 || self.config.noCalendar;
                var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
                /* TODO: investigate this further
            
                  Currently, there is weird positioning behavior in safari causing pages
                  to scroll up. https://github.com/chmln/flatpickr/issues/563
            
                  However, most browsers are not Safari and positioning is expensive when used
                  in scale. https://github.com/chmln/flatpickr/issues/1096
                */
                if (!self.isMobile && isSafari) {
                    positionCalendar();
                }
                triggerEvent("onReady");
            }
            function bindToInstance(fn) {
                return fn.bind(self);
            }
            function setCalendarWidth() {
                var config = self.config;
                if (config.weekNumbers === false && config.showMonths === 1)
                    return;
                else if (config.noCalendar !== true) {
                    window.requestAnimationFrame(function () {
                        if (self.calendarContainer !== undefined) {
                            self.calendarContainer.style.visibility = "hidden";
                            self.calendarContainer.style.display = "block";
                        }
                        if (self.daysContainer !== undefined) {
                            var daysWidth = (self.days.offsetWidth + 1) * config.showMonths;
                            self.daysContainer.style.width = daysWidth + "px";
                            self.calendarContainer.style.width =
                                daysWidth +
                                    (self.weekWrapper !== undefined
                                        ? self.weekWrapper.offsetWidth
                                        : 0) +
                                    "px";
                            self.calendarContainer.style.removeProperty("visibility");
                            self.calendarContainer.style.removeProperty("display");
                        }
                    });
                }
            }
            /**
             * The handler for all events targeting the time inputs
             */
            function updateTime(e) {
                if (self.selectedDates.length === 0) {
                    setDefaultTime();
                }
                if (e !== undefined && e.type !== "blur") {
                    timeWrapper(e);
                }
                var prevValue = self._input.value;
                setHoursFromInputs();
                updateValue();
                if (self._input.value !== prevValue) {
                    self._debouncedChange();
                }
            }
            function ampm2military(hour, amPM) {
                return (hour % 12) + 12 * int(amPM === self.l10n.amPM[1]);
            }
            function military2ampm(hour) {
                switch (hour % 24) {
                    case 0:
                    case 12:
                        return 12;
                    default:
                        return hour % 12;
                }
            }
            /**
             * Syncs the selected date object time with user's time input
             */
            function setHoursFromInputs() {
                if (self.hourElement === undefined || self.minuteElement === undefined)
                    return;
                var hours = (parseInt(self.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60, seconds = self.secondElement !== undefined
                    ? (parseInt(self.secondElement.value, 10) || 0) % 60
                    : 0;
                if (self.amPM !== undefined) {
                    hours = ampm2military(hours, self.amPM.textContent);
                }
                var limitMinHours = self.config.minTime !== undefined ||
                    (self.config.minDate &&
                        self.minDateHasTime &&
                        self.latestSelectedDateObj &&
                        compareDates(self.latestSelectedDateObj, self.config.minDate, true) ===
                            0);
                var limitMaxHours = self.config.maxTime !== undefined ||
                    (self.config.maxDate &&
                        self.maxDateHasTime &&
                        self.latestSelectedDateObj &&
                        compareDates(self.latestSelectedDateObj, self.config.maxDate, true) ===
                            0);
                if (limitMaxHours) {
                    var maxTime = self.config.maxTime !== undefined
                        ? self.config.maxTime
                        : self.config.maxDate;
                    hours = Math.min(hours, maxTime.getHours());
                    if (hours === maxTime.getHours())
                        minutes = Math.min(minutes, maxTime.getMinutes());
                    if (minutes === maxTime.getMinutes())
                        seconds = Math.min(seconds, maxTime.getSeconds());
                }
                if (limitMinHours) {
                    var minTime = self.config.minTime !== undefined
                        ? self.config.minTime
                        : self.config.minDate;
                    hours = Math.max(hours, minTime.getHours());
                    if (hours === minTime.getHours())
                        minutes = Math.max(minutes, minTime.getMinutes());
                    if (minutes === minTime.getMinutes())
                        seconds = Math.max(seconds, minTime.getSeconds());
                }
                setHours(hours, minutes, seconds);
            }
            /**
             * Syncs time input values with a date
             */
            function setHoursFromDate(dateObj) {
                var date = dateObj || self.latestSelectedDateObj;
                if (date)
                    setHours(date.getHours(), date.getMinutes(), date.getSeconds());
            }
            function setDefaultHours() {
                var hours = self.config.defaultHour;
                var minutes = self.config.defaultMinute;
                var seconds = self.config.defaultSeconds;
                if (self.config.minDate !== undefined) {
                    var minHr = self.config.minDate.getHours();
                    var minMinutes = self.config.minDate.getMinutes();
                    hours = Math.max(hours, minHr);
                    if (hours === minHr)
                        minutes = Math.max(minMinutes, minutes);
                    if (hours === minHr && minutes === minMinutes)
                        seconds = self.config.minDate.getSeconds();
                }
                if (self.config.maxDate !== undefined) {
                    var maxHr = self.config.maxDate.getHours();
                    var maxMinutes = self.config.maxDate.getMinutes();
                    hours = Math.min(hours, maxHr);
                    if (hours === maxHr)
                        minutes = Math.min(maxMinutes, minutes);
                    if (hours === maxHr && minutes === maxMinutes)
                        seconds = self.config.maxDate.getSeconds();
                }
                setHours(hours, minutes, seconds);
            }
            /**
             * Sets the hours, minutes, and optionally seconds
             * of the latest selected date object and the
             * corresponding time inputs
             * @param {Number} hours the hour. whether its military
             *                 or am-pm gets inferred from config
             * @param {Number} minutes the minutes
             * @param {Number} seconds the seconds (optional)
             */
            function setHours(hours, minutes, seconds) {
                if (self.latestSelectedDateObj !== undefined) {
                    self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
                }
                if (!self.hourElement || !self.minuteElement || self.isMobile)
                    return;
                self.hourElement.value = pad(!self.config.time_24hr
                    ? ((12 + hours) % 12) + 12 * int(hours % 12 === 0)
                    : hours);
                self.minuteElement.value = pad(minutes);
                if (self.amPM !== undefined)
                    self.amPM.textContent = self.l10n.amPM[int(hours >= 12)];
                if (self.secondElement !== undefined)
                    self.secondElement.value = pad(seconds);
            }
            /**
             * Handles the year input and incrementing events
             * @param {Event} event the keyup or increment event
             */
            function onYearInput(event) {
                var year = parseInt(event.target.value) + (event.delta || 0);
                if (year / 1000 > 1 ||
                    (event.key === "Enter" && !/[^\d]/.test(year.toString()))) {
                    changeYear(year);
                }
            }
            /**
             * Essentially addEventListener + tracking
             * @param {Element} element the element to addEventListener to
             * @param {String} event the event name
             * @param {Function} handler the event handler
             */
            function bind(element, event, handler, options) {
                if (event instanceof Array)
                    return event.forEach(function (ev) { return bind(element, ev, handler, options); });
                if (element instanceof Array)
                    return element.forEach(function (el) { return bind(el, event, handler, options); });
                element.addEventListener(event, handler, options);
                self._handlers.push({
                    element: element,
                    event: event,
                    handler: handler,
                    options: options
                });
            }
            /**
             * A mousedown handler which mimics click.
             * Minimizes latency, since we don't need to wait for mouseup in most cases.
             * Also, avoids handling right clicks.
             *
             * @param {Function} handler the event handler
             */
            function onClick(handler) {
                return function (evt) {
                    evt.which === 1 && handler(evt);
                };
            }
            function triggerChange() {
                triggerEvent("onChange");
            }
            /**
             * Adds all the necessary event listeners
             */
            function bindEvents() {
                if (self.config.wrap) {
                    ["open", "close", "toggle", "clear"].forEach(function (evt) {
                        Array.prototype.forEach.call(self.element.querySelectorAll("[data-" + evt + "]"), function (el) {
                            return bind(el, "click", self[evt]);
                        });
                    });
                }
                if (self.isMobile) {
                    setupMobile();
                    return;
                }
                var debouncedResize = debounce(onResize, 50);
                self._debouncedChange = debounce(triggerChange, DEBOUNCED_CHANGE_MS);
                if (self.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
                    bind(self.daysContainer, "mouseover", function (e) {
                        if (self.config.mode === "range")
                            onMouseOver(e.target);
                    });
                bind(window.document.body, "keydown", onKeyDown);
                if (!self.config.inline && !self.config.static)
                    bind(window, "resize", debouncedResize);
                if (window.ontouchstart !== undefined)
                    bind(window.document, "touchstart", documentClick);
                else
                    bind(window.document, "mousedown", onClick(documentClick));
                bind(window.document, "focus", documentClick, { capture: true });
                if (self.config.clickOpens === true) {
                    bind(self._input, "focus", self.open);
                    bind(self._input, "mousedown", onClick(self.open));
                }
                if (self.daysContainer !== undefined) {
                    bind(self.monthNav, "mousedown", onClick(onMonthNavClick));
                    bind(self.monthNav, ["keyup", "increment"], onYearInput);
                    bind(self.daysContainer, "mousedown", onClick(selectDate));
                }
                if (self.timeContainer !== undefined &&
                    self.minuteElement !== undefined &&
                    self.hourElement !== undefined) {
                    var selText = function (e) {
                        return e.target.select();
                    };
                    bind(self.timeContainer, ["increment"], updateTime);
                    bind(self.timeContainer, "blur", updateTime, { capture: true });
                    bind(self.timeContainer, "mousedown", onClick(timeIncrement));
                    bind([self.hourElement, self.minuteElement], ["focus", "click"], selText);
                    if (self.secondElement !== undefined)
                        bind(self.secondElement, "focus", function () { return self.secondElement && self.secondElement.select(); });
                    if (self.amPM !== undefined) {
                        bind(self.amPM, "mousedown", onClick(function (e) {
                            updateTime(e);
                            triggerChange();
                        }));
                    }
                }
            }
            /**
             * Set the calendar view to a particular date.
             * @param {Date} jumpDate the date to set the view to
             * @param {boolean} triggerChange if change events should be triggered
             */
            function jumpToDate(jumpDate, triggerChange) {
                var jumpTo = jumpDate !== undefined
                    ? self.parseDate(jumpDate)
                    : self.latestSelectedDateObj ||
                        (self.config.minDate && self.config.minDate > self.now
                            ? self.config.minDate
                            : self.config.maxDate && self.config.maxDate < self.now
                                ? self.config.maxDate
                                : self.now);
                var oldYear = self.currentYear;
                var oldMonth = self.currentMonth;
                try {
                    if (jumpTo !== undefined) {
                        self.currentYear = jumpTo.getFullYear();
                        self.currentMonth = jumpTo.getMonth();
                    }
                }
                catch (e) {
                    /* istanbul ignore next */
                    e.message = "Invalid date supplied: " + jumpTo;
                    self.config.errorHandler(e);
                }
                if (triggerChange && self.currentYear !== oldYear) {
                    triggerEvent("onYearChange");
                    buildMonthSwitch();
                }
                if (triggerChange &&
                    (self.currentYear !== oldYear || self.currentMonth !== oldMonth)) {
                    triggerEvent("onMonthChange");
                }
                self.redraw();
            }
            /**
             * The up/down arrow handler for time inputs
             * @param {Event} e the click event
             */
            function timeIncrement(e) {
                if (~e.target.className.indexOf("arrow"))
                    incrementNumInput(e, e.target.classList.contains("arrowUp") ? 1 : -1);
            }
            /**
             * Increments/decrements the value of input associ-
             * ated with the up/down arrow by dispatching an
             * "increment" event on the input.
             *
             * @param {Event} e the click event
             * @param {Number} delta the diff (usually 1 or -1)
             * @param {Element} inputElem the input element
             */
            function incrementNumInput(e, delta, inputElem) {
                var target = e && e.target;
                var input = inputElem ||
                    (target && target.parentNode && target.parentNode.firstChild);
                var event = createEvent("increment");
                event.delta = delta;
                input && input.dispatchEvent(event);
            }
            function build() {
                var fragment = window.document.createDocumentFragment();
                self.calendarContainer = createElement("div", "flatpickr-calendar");
                self.calendarContainer.tabIndex = -1;
                if (!self.config.noCalendar) {
                    fragment.appendChild(buildMonthNav());
                    self.innerContainer = createElement("div", "flatpickr-innerContainer");
                    if (self.config.weekNumbers) {
                        var _a = buildWeeks(), weekWrapper = _a.weekWrapper, weekNumbers = _a.weekNumbers;
                        self.innerContainer.appendChild(weekWrapper);
                        self.weekNumbers = weekNumbers;
                        self.weekWrapper = weekWrapper;
                    }
                    self.rContainer = createElement("div", "flatpickr-rContainer");
                    self.rContainer.appendChild(buildWeekdays());
                    if (!self.daysContainer) {
                        self.daysContainer = createElement("div", "flatpickr-days");
                        self.daysContainer.tabIndex = -1;
                    }
                    buildDays();
                    self.rContainer.appendChild(self.daysContainer);
                    self.innerContainer.appendChild(self.rContainer);
                    fragment.appendChild(self.innerContainer);
                }
                if (self.config.enableTime) {
                    fragment.appendChild(buildTime());
                }
                toggleClass(self.calendarContainer, "rangeMode", self.config.mode === "range");
                toggleClass(self.calendarContainer, "animate", self.config.animate === true);
                toggleClass(self.calendarContainer, "multiMonth", self.config.showMonths > 1);
                self.calendarContainer.appendChild(fragment);
                var customAppend = self.config.appendTo !== undefined &&
                    self.config.appendTo.nodeType !== undefined;
                if (self.config.inline || self.config.static) {
                    self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");
                    if (self.config.inline) {
                        if (!customAppend && self.element.parentNode)
                            self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);
                        else if (self.config.appendTo !== undefined)
                            self.config.appendTo.appendChild(self.calendarContainer);
                    }
                    if (self.config.static) {
                        var wrapper = createElement("div", "flatpickr-wrapper");
                        if (self.element.parentNode)
                            self.element.parentNode.insertBefore(wrapper, self.element);
                        wrapper.appendChild(self.element);
                        if (self.altInput)
                            wrapper.appendChild(self.altInput);
                        wrapper.appendChild(self.calendarContainer);
                    }
                }
                if (!self.config.static && !self.config.inline)
                    (self.config.appendTo !== undefined
                        ? self.config.appendTo
                        : window.document.body).appendChild(self.calendarContainer);
            }
            function createDay(className, date, dayNumber, i) {
                var dateIsEnabled = isEnabled(date, true), dayElement = createElement("span", "flatpickr-day " + className, date.getDate().toString());
                dayElement.dateObj = date;
                dayElement.$i = i;
                dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));
                if (className.indexOf("hidden") === -1 &&
                    compareDates(date, self.now) === 0) {
                    self.todayDateElem = dayElement;
                    dayElement.classList.add("today");
                    dayElement.setAttribute("aria-current", "date");
                }
                if (dateIsEnabled) {
                    dayElement.tabIndex = -1;
                    if (isDateSelected(date)) {
                        dayElement.classList.add("selected");
                        self.selectedDateElem = dayElement;
                        if (self.config.mode === "range") {
                            toggleClass(dayElement, "startRange", self.selectedDates[0] &&
                                compareDates(date, self.selectedDates[0], true) === 0);
                            toggleClass(dayElement, "endRange", self.selectedDates[1] &&
                                compareDates(date, self.selectedDates[1], true) === 0);
                            if (className === "nextMonthDay")
                                dayElement.classList.add("inRange");
                        }
                    }
                }
                else {
                    dayElement.classList.add("flatpickr-disabled");
                }
                if (self.config.mode === "range") {
                    if (isDateInRange(date) && !isDateSelected(date))
                        dayElement.classList.add("inRange");
                }
                if (self.weekNumbers &&
                    self.config.showMonths === 1 &&
                    className !== "prevMonthDay" &&
                    dayNumber % 7 === 1) {
                    self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self.config.getWeek(date) + "</span>");
                }
                triggerEvent("onDayCreate", dayElement);
                return dayElement;
            }
            function focusOnDayElem(targetNode) {
                targetNode.focus();
                if (self.config.mode === "range")
                    onMouseOver(targetNode);
            }
            function getFirstAvailableDay(delta) {
                var startMonth = delta > 0 ? 0 : self.config.showMonths - 1;
                var endMonth = delta > 0 ? self.config.showMonths : -1;
                for (var m = startMonth; m != endMonth; m += delta) {
                    var month = self.daysContainer.children[m];
                    var startIndex = delta > 0 ? 0 : month.children.length - 1;
                    var endIndex = delta > 0 ? month.children.length : -1;
                    for (var i = startIndex; i != endIndex; i += delta) {
                        var c = month.children[i];
                        if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj))
                            return c;
                    }
                }
                return undefined;
            }
            function getNextAvailableDay(current, delta) {
                var givenMonth = current.className.indexOf("Month") === -1
                    ? current.dateObj.getMonth()
                    : self.currentMonth;
                var endMonth = delta > 0 ? self.config.showMonths : -1;
                var loopDelta = delta > 0 ? 1 : -1;
                for (var m = givenMonth - self.currentMonth; m != endMonth; m += loopDelta) {
                    var month = self.daysContainer.children[m];
                    var startIndex = givenMonth - self.currentMonth === m
                        ? current.$i + delta
                        : delta < 0
                            ? month.children.length - 1
                            : 0;
                    var numMonthDays = month.children.length;
                    for (var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
                        var c = month.children[i];
                        if (c.className.indexOf("hidden") === -1 &&
                            isEnabled(c.dateObj) &&
                            Math.abs(current.$i - i) >= Math.abs(delta))
                            return focusOnDayElem(c);
                    }
                }
                self.changeMonth(loopDelta);
                focusOnDay(getFirstAvailableDay(loopDelta), 0);
                return undefined;
            }
            function focusOnDay(current, offset) {
                var dayFocused = isInView(document.activeElement || document.body);
                var startElem = current !== undefined
                    ? current
                    : dayFocused
                        ? document.activeElement
                        : self.selectedDateElem !== undefined && isInView(self.selectedDateElem)
                            ? self.selectedDateElem
                            : self.todayDateElem !== undefined && isInView(self.todayDateElem)
                                ? self.todayDateElem
                                : getFirstAvailableDay(offset > 0 ? 1 : -1);
                if (startElem === undefined)
                    return self._input.focus();
                if (!dayFocused)
                    return focusOnDayElem(startElem);
                getNextAvailableDay(startElem, offset);
            }
            function buildMonthDays(year, month) {
                var firstOfMonth = (new Date(year, month, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7;
                var prevMonthDays = self.utils.getDaysInMonth((month - 1 + 12) % 12);
                var daysInMonth = self.utils.getDaysInMonth(month), days = window.document.createDocumentFragment(), isMultiMonth = self.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
                var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
                // prepend days from the ending of previous month
                for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
                    days.appendChild(createDay(prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
                }
                // Start at 1 since there is no 0th day
                for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
                    days.appendChild(createDay("", new Date(year, month, dayNumber), dayNumber, dayIndex));
                }
                // append days from the next month
                for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth &&
                    (self.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
                    days.appendChild(createDay(nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
                }
                //updateNavigationCurrentMonth();
                var dayContainer = createElement("div", "dayContainer");
                dayContainer.appendChild(days);
                return dayContainer;
            }
            function buildDays() {
                if (self.daysContainer === undefined) {
                    return;
                }
                clearNode(self.daysContainer);
                // TODO: week numbers for each month
                if (self.weekNumbers)
                    clearNode(self.weekNumbers);
                var frag = document.createDocumentFragment();
                for (var i = 0; i < self.config.showMonths; i++) {
                    var d = new Date(self.currentYear, self.currentMonth, 1);
                    d.setMonth(self.currentMonth + i);
                    frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
                }
                self.daysContainer.appendChild(frag);
                self.days = self.daysContainer.firstChild;
                if (self.config.mode === "range" && self.selectedDates.length === 1) {
                    onMouseOver();
                }
            }
            function buildMonthSwitch() {
                if (self.config.showMonths > 1 ||
                    self.config.monthSelectorType !== "dropdown")
                    return;
                var shouldBuildMonth = function (month) {
                    if (self.config.minDate !== undefined &&
                        self.currentYear === self.config.minDate.getFullYear() &&
                        month < self.config.minDate.getMonth()) {
                        return false;
                    }
                    return !(self.config.maxDate !== undefined &&
                        self.currentYear === self.config.maxDate.getFullYear() &&
                        month > self.config.maxDate.getMonth());
                };
                self.monthsDropdownContainer.tabIndex = -1;
                self.monthsDropdownContainer.innerHTML = "";
                for (var i = 0; i < 12; i++) {
                    if (!shouldBuildMonth(i))
                        continue;
                    var month = createElement("option", "flatpickr-monthDropdown-month");
                    month.value = new Date(self.currentYear, i).getMonth().toString();
                    month.textContent = monthToStr(i, self.config.shorthandCurrentMonth, self.l10n);
                    month.tabIndex = -1;
                    if (self.currentMonth === i) {
                        month.selected = true;
                    }
                    self.monthsDropdownContainer.appendChild(month);
                }
            }
            function buildMonth() {
                var container = createElement("div", "flatpickr-month");
                var monthNavFragment = window.document.createDocumentFragment();
                var monthElement;
                if (self.config.showMonths > 1 ||
                    self.config.monthSelectorType === "static") {
                    monthElement = createElement("span", "cur-month");
                }
                else {
                    self.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
                    bind(self.monthsDropdownContainer, "change", function (e) {
                        var target = e.target;
                        var selectedMonth = parseInt(target.value, 10);
                        self.changeMonth(selectedMonth - self.currentMonth);
                        triggerEvent("onMonthChange");
                    });
                    buildMonthSwitch();
                    monthElement = self.monthsDropdownContainer;
                }
                var yearInput = createNumberInput("cur-year", { tabindex: "-1" });
                var yearElement = yearInput.getElementsByTagName("input")[0];
                yearElement.setAttribute("aria-label", self.l10n.yearAriaLabel);
                if (self.config.minDate) {
                    yearElement.setAttribute("min", self.config.minDate.getFullYear().toString());
                }
                if (self.config.maxDate) {
                    yearElement.setAttribute("max", self.config.maxDate.getFullYear().toString());
                    yearElement.disabled =
                        !!self.config.minDate &&
                            self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
                }
                var currentMonth = createElement("div", "flatpickr-current-month");
                currentMonth.appendChild(monthElement);
                currentMonth.appendChild(yearInput);
                monthNavFragment.appendChild(currentMonth);
                container.appendChild(monthNavFragment);
                return {
                    container: container,
                    yearElement: yearElement,
                    monthElement: monthElement
                };
            }
            function buildMonths() {
                clearNode(self.monthNav);
                self.monthNav.appendChild(self.prevMonthNav);
                if (self.config.showMonths) {
                    self.yearElements = [];
                    self.monthElements = [];
                }
                for (var m = self.config.showMonths; m--;) {
                    var month = buildMonth();
                    self.yearElements.push(month.yearElement);
                    self.monthElements.push(month.monthElement);
                    self.monthNav.appendChild(month.container);
                }
                self.monthNav.appendChild(self.nextMonthNav);
            }
            function buildMonthNav() {
                self.monthNav = createElement("div", "flatpickr-months");
                self.yearElements = [];
                self.monthElements = [];
                self.prevMonthNav = createElement("span", "flatpickr-prev-month");
                self.prevMonthNav.innerHTML = self.config.prevArrow;
                self.nextMonthNav = createElement("span", "flatpickr-next-month");
                self.nextMonthNav.innerHTML = self.config.nextArrow;
                buildMonths();
                Object.defineProperty(self, "_hidePrevMonthArrow", {
                    get: function () { return self.__hidePrevMonthArrow; },
                    set: function (bool) {
                        if (self.__hidePrevMonthArrow !== bool) {
                            toggleClass(self.prevMonthNav, "flatpickr-disabled", bool);
                            self.__hidePrevMonthArrow = bool;
                        }
                    }
                });
                Object.defineProperty(self, "_hideNextMonthArrow", {
                    get: function () { return self.__hideNextMonthArrow; },
                    set: function (bool) {
                        if (self.__hideNextMonthArrow !== bool) {
                            toggleClass(self.nextMonthNav, "flatpickr-disabled", bool);
                            self.__hideNextMonthArrow = bool;
                        }
                    }
                });
                self.currentYearElement = self.yearElements[0];
                updateNavigationCurrentMonth();
                return self.monthNav;
            }
            function buildTime() {
                self.calendarContainer.classList.add("hasTime");
                if (self.config.noCalendar)
                    self.calendarContainer.classList.add("noCalendar");
                self.timeContainer = createElement("div", "flatpickr-time");
                self.timeContainer.tabIndex = -1;
                var separator = createElement("span", "flatpickr-time-separator", ":");
                var hourInput = createNumberInput("flatpickr-hour", {
                    "aria-label": self.l10n.hourAriaLabel
                });
                self.hourElement = hourInput.getElementsByTagName("input")[0];
                var minuteInput = createNumberInput("flatpickr-minute", {
                    "aria-label": self.l10n.minuteAriaLabel
                });
                self.minuteElement = minuteInput.getElementsByTagName("input")[0];
                self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;
                self.hourElement.value = pad(self.latestSelectedDateObj
                    ? self.latestSelectedDateObj.getHours()
                    : self.config.time_24hr
                        ? self.config.defaultHour
                        : military2ampm(self.config.defaultHour));
                self.minuteElement.value = pad(self.latestSelectedDateObj
                    ? self.latestSelectedDateObj.getMinutes()
                    : self.config.defaultMinute);
                self.hourElement.setAttribute("step", self.config.hourIncrement.toString());
                self.minuteElement.setAttribute("step", self.config.minuteIncrement.toString());
                self.hourElement.setAttribute("min", self.config.time_24hr ? "0" : "1");
                self.hourElement.setAttribute("max", self.config.time_24hr ? "23" : "12");
                self.minuteElement.setAttribute("min", "0");
                self.minuteElement.setAttribute("max", "59");
                self.timeContainer.appendChild(hourInput);
                self.timeContainer.appendChild(separator);
                self.timeContainer.appendChild(minuteInput);
                if (self.config.time_24hr)
                    self.timeContainer.classList.add("time24hr");
                if (self.config.enableSeconds) {
                    self.timeContainer.classList.add("hasSeconds");
                    var secondInput = createNumberInput("flatpickr-second");
                    self.secondElement = secondInput.getElementsByTagName("input")[0];
                    self.secondElement.value = pad(self.latestSelectedDateObj
                        ? self.latestSelectedDateObj.getSeconds()
                        : self.config.defaultSeconds);
                    self.secondElement.setAttribute("step", self.minuteElement.getAttribute("step"));
                    self.secondElement.setAttribute("min", "0");
                    self.secondElement.setAttribute("max", "59");
                    self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
                    self.timeContainer.appendChild(secondInput);
                }
                if (!self.config.time_24hr) {
                    // add self.amPM if appropriate
                    self.amPM = createElement("span", "flatpickr-am-pm", self.l10n.amPM[int((self.latestSelectedDateObj
                        ? self.hourElement.value
                        : self.config.defaultHour) > 11)]);
                    self.amPM.title = self.l10n.toggleTitle;
                    self.amPM.tabIndex = -1;
                    self.timeContainer.appendChild(self.amPM);
                }
                return self.timeContainer;
            }
            function buildWeekdays() {
                if (!self.weekdayContainer)
                    self.weekdayContainer = createElement("div", "flatpickr-weekdays");
                else
                    clearNode(self.weekdayContainer);
                for (var i = self.config.showMonths; i--;) {
                    var container = createElement("div", "flatpickr-weekdaycontainer");
                    self.weekdayContainer.appendChild(container);
                }
                updateWeekdays();
                return self.weekdayContainer;
            }
            function updateWeekdays() {
                var firstDayOfWeek = self.l10n.firstDayOfWeek;
                var weekdays = self.l10n.weekdays.shorthand.slice();
                if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
                    weekdays = weekdays.splice(firstDayOfWeek, weekdays.length).concat(weekdays.splice(0, firstDayOfWeek));
                }
                for (var i = self.config.showMonths; i--;) {
                    self.weekdayContainer.children[i].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
                }
            }
            /* istanbul ignore next */
            function buildWeeks() {
                self.calendarContainer.classList.add("hasWeeks");
                var weekWrapper = createElement("div", "flatpickr-weekwrapper");
                weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
                var weekNumbers = createElement("div", "flatpickr-weeks");
                weekWrapper.appendChild(weekNumbers);
                return {
                    weekWrapper: weekWrapper,
                    weekNumbers: weekNumbers
                };
            }
            function changeMonth(value, isOffset) {
                if (isOffset === void 0) { isOffset = true; }
                var delta = isOffset ? value : value - self.currentMonth;
                if ((delta < 0 && self._hidePrevMonthArrow === true) ||
                    (delta > 0 && self._hideNextMonthArrow === true))
                    return;
                self.currentMonth += delta;
                if (self.currentMonth < 0 || self.currentMonth > 11) {
                    self.currentYear += self.currentMonth > 11 ? 1 : -1;
                    self.currentMonth = (self.currentMonth + 12) % 12;
                    triggerEvent("onYearChange");
                    buildMonthSwitch();
                }
                buildDays();
                triggerEvent("onMonthChange");
                updateNavigationCurrentMonth();
            }
            function clear(triggerChangeEvent, toInitial) {
                if (triggerChangeEvent === void 0) { triggerChangeEvent = true; }
                if (toInitial === void 0) { toInitial = true; }
                self.input.value = "";
                if (self.altInput !== undefined)
                    self.altInput.value = "";
                if (self.mobileInput !== undefined)
                    self.mobileInput.value = "";
                self.selectedDates = [];
                self.latestSelectedDateObj = undefined;
                if (toInitial === true) {
                    self.currentYear = self._initialDate.getFullYear();
                    self.currentMonth = self._initialDate.getMonth();
                }
                self.showTimeInput = false;
                if (self.config.enableTime === true) {
                    setDefaultHours();
                }
                self.redraw();
                if (triggerChangeEvent)
                    // triggerChangeEvent is true (default) or an Event
                    triggerEvent("onChange");
            }
            function close() {
                self.isOpen = false;
                if (!self.isMobile) {
                    if (self.calendarContainer !== undefined) {
                        self.calendarContainer.classList.remove("open");
                    }
                    if (self._input !== undefined) {
                        self._input.classList.remove("active");
                    }
                }
                triggerEvent("onClose");
            }
            function destroy() {
                if (self.config !== undefined)
                    triggerEvent("onDestroy");
                for (var i = self._handlers.length; i--;) {
                    var h = self._handlers[i];
                    h.element.removeEventListener(h.event, h.handler, h.options);
                }
                self._handlers = [];
                if (self.mobileInput) {
                    if (self.mobileInput.parentNode)
                        self.mobileInput.parentNode.removeChild(self.mobileInput);
                    self.mobileInput = undefined;
                }
                else if (self.calendarContainer && self.calendarContainer.parentNode) {
                    if (self.config.static && self.calendarContainer.parentNode) {
                        var wrapper = self.calendarContainer.parentNode;
                        wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
                        if (wrapper.parentNode) {
                            while (wrapper.firstChild)
                                wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
                            wrapper.parentNode.removeChild(wrapper);
                        }
                    }
                    else
                        self.calendarContainer.parentNode.removeChild(self.calendarContainer);
                }
                if (self.altInput) {
                    self.input.type = "text";
                    if (self.altInput.parentNode)
                        self.altInput.parentNode.removeChild(self.altInput);
                    delete self.altInput;
                }
                if (self.input) {
                    self.input.type = self.input._type;
                    self.input.classList.remove("flatpickr-input");
                    self.input.removeAttribute("readonly");
                    self.input.value = "";
                }
                [
                    "_showTimeInput",
                    "latestSelectedDateObj",
                    "_hideNextMonthArrow",
                    "_hidePrevMonthArrow",
                    "__hideNextMonthArrow",
                    "__hidePrevMonthArrow",
                    "isMobile",
                    "isOpen",
                    "selectedDateElem",
                    "minDateHasTime",
                    "maxDateHasTime",
                    "days",
                    "daysContainer",
                    "_input",
                    "_positionElement",
                    "innerContainer",
                    "rContainer",
                    "monthNav",
                    "todayDateElem",
                    "calendarContainer",
                    "weekdayContainer",
                    "prevMonthNav",
                    "nextMonthNav",
                    "monthsDropdownContainer",
                    "currentMonthElement",
                    "currentYearElement",
                    "navigationCurrentMonth",
                    "selectedDateElem",
                    "config",
                ].forEach(function (k) {
                    try {
                        delete self[k];
                    }
                    catch (_) { }
                });
            }
            function isCalendarElem(elem) {
                if (self.config.appendTo && self.config.appendTo.contains(elem))
                    return true;
                return self.calendarContainer.contains(elem);
            }
            function documentClick(e) {
                if (self.isOpen && !self.config.inline) {
                    var eventTarget_1 = getEventTarget(e);
                    var isCalendarElement = isCalendarElem(eventTarget_1);
                    var isInput = eventTarget_1 === self.input ||
                        eventTarget_1 === self.altInput ||
                        self.element.contains(eventTarget_1) ||
                        // web components
                        // e.path is not present in all browsers. circumventing typechecks
                        (e.path &&
                            e.path.indexOf &&
                            (~e.path.indexOf(self.input) ||
                                ~e.path.indexOf(self.altInput)));
                    var lostFocus = e.type === "blur"
                        ? isInput &&
                            e.relatedTarget &&
                            !isCalendarElem(e.relatedTarget)
                        : !isInput &&
                            !isCalendarElement &&
                            !isCalendarElem(e.relatedTarget);
                    var isIgnored = !self.config.ignoredFocusElements.some(function (elem) {
                        return elem.contains(eventTarget_1);
                    });
                    if (lostFocus && isIgnored) {
                        self.close();
                        if (self.config.mode === "range" && self.selectedDates.length === 1) {
                            self.clear(false);
                            self.redraw();
                        }
                    }
                }
            }
            function changeYear(newYear) {
                if (!newYear ||
                    (self.config.minDate && newYear < self.config.minDate.getFullYear()) ||
                    (self.config.maxDate && newYear > self.config.maxDate.getFullYear()))
                    return;
                var newYearNum = newYear, isNewYear = self.currentYear !== newYearNum;
                self.currentYear = newYearNum || self.currentYear;
                if (self.config.maxDate &&
                    self.currentYear === self.config.maxDate.getFullYear()) {
                    self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);
                }
                else if (self.config.minDate &&
                    self.currentYear === self.config.minDate.getFullYear()) {
                    self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
                }
                if (isNewYear) {
                    self.redraw();
                    triggerEvent("onYearChange");
                    buildMonthSwitch();
                }
            }
            function isEnabled(date, timeless) {
                if (timeless === void 0) { timeless = true; }
                var dateToCheck = self.parseDate(date, undefined, timeless); // timeless
                if ((self.config.minDate &&
                    dateToCheck &&
                    compareDates(dateToCheck, self.config.minDate, timeless !== undefined ? timeless : !self.minDateHasTime) < 0) ||
                    (self.config.maxDate &&
                        dateToCheck &&
                        compareDates(dateToCheck, self.config.maxDate, timeless !== undefined ? timeless : !self.maxDateHasTime) > 0))
                    return false;
                if (self.config.enable.length === 0 && self.config.disable.length === 0)
                    return true;
                if (dateToCheck === undefined)
                    return false;
                var bool = self.config.enable.length > 0, array = bool ? self.config.enable : self.config.disable;
                for (var i = 0, d = void 0; i < array.length; i++) {
                    d = array[i];
                    if (typeof d === "function" &&
                        d(dateToCheck) // disabled by function
                    )
                        return bool;
                    else if (d instanceof Date &&
                        dateToCheck !== undefined &&
                        d.getTime() === dateToCheck.getTime())
                        // disabled by date
                        return bool;
                    else if (typeof d === "string" && dateToCheck !== undefined) {
                        // disabled by date string
                        var parsed = self.parseDate(d, undefined, true);
                        return parsed && parsed.getTime() === dateToCheck.getTime()
                            ? bool
                            : !bool;
                    }
                    else if (
                    // disabled by range
                    typeof d === "object" &&
                        dateToCheck !== undefined &&
                        d.from &&
                        d.to &&
                        dateToCheck.getTime() >= d.from.getTime() &&
                        dateToCheck.getTime() <= d.to.getTime())
                        return bool;
                }
                return !bool;
            }
            function isInView(elem) {
                if (self.daysContainer !== undefined)
                    return (elem.className.indexOf("hidden") === -1 &&
                        self.daysContainer.contains(elem));
                return false;
            }
            function onKeyDown(e) {
                // e.key                      e.keyCode
                // "Backspace"                        8
                // "Tab"                              9
                // "Enter"                           13
                // "Escape"     (IE "Esc")           27
                // "ArrowLeft"  (IE "Left")          37
                // "ArrowUp"    (IE "Up")            38
                // "ArrowRight" (IE "Right")         39
                // "ArrowDown"  (IE "Down")          40
                // "Delete"     (IE "Del")           46
                var isInput = e.target === self._input;
                var allowInput = self.config.allowInput;
                var allowKeydown = self.isOpen && (!allowInput || !isInput);
                var allowInlineKeydown = self.config.inline && isInput && !allowInput;
                if (e.keyCode === 13 && isInput) {
                    if (allowInput) {
                        self.setDate(self._input.value, true, e.target === self.altInput
                            ? self.config.altFormat
                            : self.config.dateFormat);
                        return e.target.blur();
                    }
                    else {
                        self.open();
                    }
                }
                else if (isCalendarElem(e.target) ||
                    allowKeydown ||
                    allowInlineKeydown) {
                    var isTimeObj = !!self.timeContainer &&
                        self.timeContainer.contains(e.target);
                    switch (e.keyCode) {
                        case 13:
                            if (isTimeObj) {
                                e.preventDefault();
                                updateTime();
                                focusAndClose();
                            }
                            else
                                selectDate(e);
                            break;
                        case 27: // escape
                            e.preventDefault();
                            focusAndClose();
                            break;
                        case 8:
                        case 46:
                            if (isInput && !self.config.allowInput) {
                                e.preventDefault();
                                self.clear();
                            }
                            break;
                        case 37:
                        case 39:
                            if (!isTimeObj && !isInput) {
                                e.preventDefault();
                                if (self.daysContainer !== undefined &&
                                    (allowInput === false ||
                                        (document.activeElement && isInView(document.activeElement)))) {
                                    var delta_1 = e.keyCode === 39 ? 1 : -1;
                                    if (!e.ctrlKey)
                                        focusOnDay(undefined, delta_1);
                                    else {
                                        e.stopPropagation();
                                        changeMonth(delta_1);
                                        focusOnDay(getFirstAvailableDay(1), 0);
                                    }
                                }
                            }
                            else if (self.hourElement)
                                self.hourElement.focus();
                            break;
                        case 38:
                        case 40:
                            e.preventDefault();
                            var delta = e.keyCode === 40 ? 1 : -1;
                            if ((self.daysContainer && e.target.$i !== undefined) ||
                                e.target === self.input) {
                                if (e.ctrlKey) {
                                    e.stopPropagation();
                                    changeYear(self.currentYear - delta);
                                    focusOnDay(getFirstAvailableDay(1), 0);
                                }
                                else if (!isTimeObj)
                                    focusOnDay(undefined, delta * 7);
                            }
                            else if (e.target === self.currentYearElement) {
                                changeYear(self.currentYear - delta);
                            }
                            else if (self.config.enableTime) {
                                if (!isTimeObj && self.hourElement)
                                    self.hourElement.focus();
                                updateTime(e);
                                self._debouncedChange();
                            }
                            break;
                        case 9:
                            if (isTimeObj) {
                                var elems = [
                                    self.hourElement,
                                    self.minuteElement,
                                    self.secondElement,
                                    self.amPM,
                                ]
                                    .concat(self.pluginElements)
                                    .filter(function (x) { return x; });
                                var i = elems.indexOf(e.target);
                                if (i !== -1) {
                                    var target = elems[i + (e.shiftKey ? -1 : 1)];
                                    e.preventDefault();
                                    (target || self._input).focus();
                                }
                            }
                            else if (!self.config.noCalendar &&
                                self.daysContainer &&
                                self.daysContainer.contains(e.target) &&
                                e.shiftKey) {
                                e.preventDefault();
                                self._input.focus();
                            }
                            break;
                        default:
                            break;
                    }
                }
                if (self.amPM !== undefined && e.target === self.amPM) {
                    switch (e.key) {
                        case self.l10n.amPM[0].charAt(0):
                        case self.l10n.amPM[0].charAt(0).toLowerCase():
                            self.amPM.textContent = self.l10n.amPM[0];
                            setHoursFromInputs();
                            updateValue();
                            break;
                        case self.l10n.amPM[1].charAt(0):
                        case self.l10n.amPM[1].charAt(0).toLowerCase():
                            self.amPM.textContent = self.l10n.amPM[1];
                            setHoursFromInputs();
                            updateValue();
                            break;
                    }
                }
                if (isInput || isCalendarElem(e.target)) {
                    triggerEvent("onKeyDown", e);
                }
            }
            function onMouseOver(elem) {
                if (self.selectedDates.length !== 1 ||
                    (elem &&
                        (!elem.classList.contains("flatpickr-day") ||
                            elem.classList.contains("flatpickr-disabled"))))
                    return;
                var hoverDate = elem
                    ? elem.dateObj.getTime()
                    : self.days.firstElementChild.dateObj.getTime(), initialDate = self.parseDate(self.selectedDates[0], undefined, true).getTime(), rangeStartDate = Math.min(hoverDate, self.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self.selectedDates[0].getTime());
                var containsDisabled = false;
                var minRange = 0, maxRange = 0;
                for (var t = rangeStartDate; t < rangeEndDate; t += duration.DAY) {
                    if (!isEnabled(new Date(t), true)) {
                        containsDisabled =
                            containsDisabled || (t > rangeStartDate && t < rangeEndDate);
                        if (t < initialDate && (!minRange || t > minRange))
                            minRange = t;
                        else if (t > initialDate && (!maxRange || t < maxRange))
                            maxRange = t;
                    }
                }
                for (var m = 0; m < self.config.showMonths; m++) {
                    var month = self.daysContainer.children[m];
                    var _loop_1 = function (i, l) {
                        var dayElem = month.children[i], date = dayElem.dateObj;
                        var timestamp = date.getTime();
                        var outOfRange = (minRange > 0 && timestamp < minRange) ||
                            (maxRange > 0 && timestamp > maxRange);
                        if (outOfRange) {
                            dayElem.classList.add("notAllowed");
                            ["inRange", "startRange", "endRange"].forEach(function (c) {
                                dayElem.classList.remove(c);
                            });
                            return "continue";
                        }
                        else if (containsDisabled && !outOfRange)
                            return "continue";
                        ["startRange", "inRange", "endRange", "notAllowed"].forEach(function (c) {
                            dayElem.classList.remove(c);
                        });
                        if (elem !== undefined) {
                            elem.classList.add(hoverDate <= self.selectedDates[0].getTime()
                                ? "startRange"
                                : "endRange");
                            if (initialDate < hoverDate && timestamp === initialDate)
                                dayElem.classList.add("startRange");
                            else if (initialDate > hoverDate && timestamp === initialDate)
                                dayElem.classList.add("endRange");
                            if (timestamp >= minRange &&
                                (maxRange === 0 || timestamp <= maxRange) &&
                                isBetween(timestamp, initialDate, hoverDate))
                                dayElem.classList.add("inRange");
                        }
                    };
                    for (var i = 0, l = month.children.length; i < l; i++) {
                        _loop_1(i, l);
                    }
                }
            }
            function onResize() {
                if (self.isOpen && !self.config.static && !self.config.inline)
                    positionCalendar();
            }
            function setDefaultTime() {
                self.setDate(self.config.minDate !== undefined
                    ? new Date(self.config.minDate.getTime())
                    : new Date(), true);
                setDefaultHours();
                updateValue();
            }
            function open(e, positionElement) {
                if (positionElement === void 0) { positionElement = self._positionElement; }
                if (self.isMobile === true) {
                    if (e) {
                        e.preventDefault();
                        e.target && e.target.blur();
                    }
                    if (self.mobileInput !== undefined) {
                        self.mobileInput.focus();
                        self.mobileInput.click();
                    }
                    triggerEvent("onOpen");
                    return;
                }
                if (self._input.disabled || self.config.inline)
                    return;
                var wasOpen = self.isOpen;
                self.isOpen = true;
                if (!wasOpen) {
                    self.calendarContainer.classList.add("open");
                    self._input.classList.add("active");
                    triggerEvent("onOpen");
                    positionCalendar(positionElement);
                }
                if (self.config.enableTime === true && self.config.noCalendar === true) {
                    if (self.selectedDates.length === 0) {
                        setDefaultTime();
                    }
                    if (self.config.allowInput === false &&
                        (e === undefined ||
                            !self.timeContainer.contains(e.relatedTarget))) {
                        setTimeout(function () { return self.hourElement.select(); }, 50);
                    }
                }
            }
            function minMaxDateSetter(type) {
                return function (date) {
                    var dateObj = (self.config["_" + type + "Date"] = self.parseDate(date, self.config.dateFormat));
                    var inverseDateObj = self.config["_" + (type === "min" ? "max" : "min") + "Date"];
                    if (dateObj !== undefined) {
                        self[type === "min" ? "minDateHasTime" : "maxDateHasTime"] =
                            dateObj.getHours() > 0 ||
                                dateObj.getMinutes() > 0 ||
                                dateObj.getSeconds() > 0;
                    }
                    if (self.selectedDates) {
                        self.selectedDates = self.selectedDates.filter(function (d) { return isEnabled(d); });
                        if (!self.selectedDates.length && type === "min")
                            setHoursFromDate(dateObj);
                        updateValue();
                    }
                    if (self.daysContainer) {
                        redraw();
                        if (dateObj !== undefined)
                            self.currentYearElement[type] = dateObj.getFullYear().toString();
                        else
                            self.currentYearElement.removeAttribute(type);
                        self.currentYearElement.disabled =
                            !!inverseDateObj &&
                                dateObj !== undefined &&
                                inverseDateObj.getFullYear() === dateObj.getFullYear();
                    }
                };
            }
            function parseConfig() {
                var boolOpts = [
                    "wrap",
                    "weekNumbers",
                    "allowInput",
                    "clickOpens",
                    "time_24hr",
                    "enableTime",
                    "noCalendar",
                    "altInput",
                    "shorthandCurrentMonth",
                    "inline",
                    "static",
                    "enableSeconds",
                    "disableMobile",
                ];
                var userConfig = __assign({}, instanceConfig, JSON.parse(JSON.stringify(element.dataset || {})));
                var formats = {};
                self.config.parseDate = userConfig.parseDate;
                self.config.formatDate = userConfig.formatDate;
                Object.defineProperty(self.config, "enable", {
                    get: function () { return self.config._enable; },
                    set: function (dates) {
                        self.config._enable = parseDateRules(dates);
                    }
                });
                Object.defineProperty(self.config, "disable", {
                    get: function () { return self.config._disable; },
                    set: function (dates) {
                        self.config._disable = parseDateRules(dates);
                    }
                });
                var timeMode = userConfig.mode === "time";
                if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
                    var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults.dateFormat;
                    formats.dateFormat =
                        userConfig.noCalendar || timeMode
                            ? "H:i" + (userConfig.enableSeconds ? ":S" : "")
                            : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
                }
                if (userConfig.altInput &&
                    (userConfig.enableTime || timeMode) &&
                    !userConfig.altFormat) {
                    var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults.altFormat;
                    formats.altFormat =
                        userConfig.noCalendar || timeMode
                            ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K")
                            : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
                }
                if (!userConfig.altInputClass) {
                    self.config.altInputClass =
                        self.input.className + " " + self.config.altInputClass;
                }
                Object.defineProperty(self.config, "minDate", {
                    get: function () { return self.config._minDate; },
                    set: minMaxDateSetter("min")
                });
                Object.defineProperty(self.config, "maxDate", {
                    get: function () { return self.config._maxDate; },
                    set: minMaxDateSetter("max")
                });
                var minMaxTimeSetter = function (type) { return function (val) {
                    self.config[type === "min" ? "_minTime" : "_maxTime"] = self.parseDate(val, "H:i");
                }; };
                Object.defineProperty(self.config, "minTime", {
                    get: function () { return self.config._minTime; },
                    set: minMaxTimeSetter("min")
                });
                Object.defineProperty(self.config, "maxTime", {
                    get: function () { return self.config._maxTime; },
                    set: minMaxTimeSetter("max")
                });
                if (userConfig.mode === "time") {
                    self.config.noCalendar = true;
                    self.config.enableTime = true;
                }
                Object.assign(self.config, formats, userConfig);
                for (var i = 0; i < boolOpts.length; i++)
                    self.config[boolOpts[i]] =
                        self.config[boolOpts[i]] === true ||
                            self.config[boolOpts[i]] === "true";
                HOOKS.filter(function (hook) { return self.config[hook] !== undefined; }).forEach(function (hook) {
                    self.config[hook] = arrayify(self.config[hook] || []).map(bindToInstance);
                });
                self.isMobile =
                    !self.config.disableMobile &&
                        !self.config.inline &&
                        self.config.mode === "single" &&
                        !self.config.disable.length &&
                        !self.config.enable.length &&
                        !self.config.weekNumbers &&
                        /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                for (var i = 0; i < self.config.plugins.length; i++) {
                    var pluginConf = self.config.plugins[i](self) || {};
                    for (var key in pluginConf) {
                        if (HOOKS.indexOf(key) > -1) {
                            self.config[key] = arrayify(pluginConf[key])
                                .map(bindToInstance)
                                .concat(self.config[key]);
                        }
                        else if (typeof userConfig[key] === "undefined")
                            self.config[key] = pluginConf[key];
                    }
                }
                triggerEvent("onParseConfig");
            }
            function setupLocale() {
                if (typeof self.config.locale !== "object" &&
                    typeof flatpickr.l10ns[self.config.locale] === "undefined")
                    self.config.errorHandler(new Error("flatpickr: invalid locale " + self.config.locale));
                self.l10n = __assign({}, flatpickr.l10ns["default"], (typeof self.config.locale === "object"
                    ? self.config.locale
                    : self.config.locale !== "default"
                        ? flatpickr.l10ns[self.config.locale]
                        : undefined));
                tokenRegex.K = "(" + self.l10n.amPM[0] + "|" + self.l10n.amPM[1] + "|" + self.l10n.amPM[0].toLowerCase() + "|" + self.l10n.amPM[1].toLowerCase() + ")";
                var userConfig = __assign({}, instanceConfig, JSON.parse(JSON.stringify(element.dataset || {})));
                if (userConfig.time_24hr === undefined &&
                    flatpickr.defaultConfig.time_24hr === undefined) {
                    self.config.time_24hr = self.l10n.time_24hr;
                }
                self.formatDate = createDateFormatter(self);
                self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
            }
            function positionCalendar(customPositionElement) {
                if (self.calendarContainer === undefined)
                    return;
                triggerEvent("onPreCalendarPosition");
                var positionElement = customPositionElement || self._positionElement;
                var calendarHeight = Array.prototype.reduce.call(self.calendarContainer.children, (function (acc, child) { return acc + child.offsetHeight; }), 0), calendarWidth = self.calendarContainer.offsetWidth, configPos = self.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" ||
                    (configPosVertical !== "below" &&
                        distanceFromBottom < calendarHeight &&
                        inputBounds.top > calendarHeight);
                var top = window.pageYOffset +
                    inputBounds.top +
                    (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
                toggleClass(self.calendarContainer, "arrowTop", !showOnTop);
                toggleClass(self.calendarContainer, "arrowBottom", showOnTop);
                if (self.config.inline)
                    return;
                var left = window.pageXOffset +
                    inputBounds.left -
                    (configPosHorizontal != null && configPosHorizontal === "center"
                        ? (calendarWidth - inputBounds.width) / 2
                        : 0);
                var right = window.document.body.offsetWidth - inputBounds.right;
                var rightMost = left + calendarWidth > window.document.body.offsetWidth;
                var centerMost = right + calendarWidth > window.document.body.offsetWidth;
                toggleClass(self.calendarContainer, "rightMost", rightMost);
                if (self.config.static)
                    return;
                self.calendarContainer.style.top = top + "px";
                if (!rightMost) {
                    self.calendarContainer.style.left = left + "px";
                    self.calendarContainer.style.right = "auto";
                }
                else if (!centerMost) {
                    self.calendarContainer.style.left = "auto";
                    self.calendarContainer.style.right = right + "px";
                }
                else {
                    var doc = document.styleSheets[0];
                    // some testing environments don't have css support
                    if (doc === undefined)
                        return;
                    var bodyWidth = window.document.body.offsetWidth;
                    var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
                    var centerBefore = ".flatpickr-calendar.centerMost:before";
                    var centerAfter = ".flatpickr-calendar.centerMost:after";
                    var centerIndex = doc.cssRules.length;
                    var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
                    toggleClass(self.calendarContainer, "rightMost", false);
                    toggleClass(self.calendarContainer, "centerMost", true);
                    doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
                    self.calendarContainer.style.left = centerLeft + "px";
                    self.calendarContainer.style.right = "auto";
                }
            }
            function redraw() {
                if (self.config.noCalendar || self.isMobile)
                    return;
                updateNavigationCurrentMonth();
                buildDays();
            }
            function focusAndClose() {
                self._input.focus();
                if (window.navigator.userAgent.indexOf("MSIE") !== -1 ||
                    navigator.msMaxTouchPoints !== undefined) {
                    // hack - bugs in the way IE handles focus keeps the calendar open
                    setTimeout(self.close, 0);
                }
                else {
                    self.close();
                }
            }
            function selectDate(e) {
                e.preventDefault();
                e.stopPropagation();
                var isSelectable = function (day) {
                    return day.classList &&
                        day.classList.contains("flatpickr-day") &&
                        !day.classList.contains("flatpickr-disabled") &&
                        !day.classList.contains("notAllowed");
                };
                var t = findParent(e.target, isSelectable);
                if (t === undefined)
                    return;
                var target = t;
                var selectedDate = (self.latestSelectedDateObj = new Date(target.dateObj.getTime()));
                var shouldChangeMonth = (selectedDate.getMonth() < self.currentMonth ||
                    selectedDate.getMonth() >
                        self.currentMonth + self.config.showMonths - 1) &&
                    self.config.mode !== "range";
                self.selectedDateElem = target;
                if (self.config.mode === "single")
                    self.selectedDates = [selectedDate];
                else if (self.config.mode === "multiple") {
                    var selectedIndex = isDateSelected(selectedDate);
                    if (selectedIndex)
                        self.selectedDates.splice(parseInt(selectedIndex), 1);
                    else
                        self.selectedDates.push(selectedDate);
                }
                else if (self.config.mode === "range") {
                    if (self.selectedDates.length === 2) {
                        self.clear(false, false);
                    }
                    self.latestSelectedDateObj = selectedDate;
                    self.selectedDates.push(selectedDate);
                    // unless selecting same date twice, sort ascendingly
                    if (compareDates(selectedDate, self.selectedDates[0], true) !== 0)
                        self.selectedDates.sort(function (a, b) { return a.getTime() - b.getTime(); });
                }
                setHoursFromInputs();
                if (shouldChangeMonth) {
                    var isNewYear = self.currentYear !== selectedDate.getFullYear();
                    self.currentYear = selectedDate.getFullYear();
                    self.currentMonth = selectedDate.getMonth();
                    if (isNewYear) {
                        triggerEvent("onYearChange");
                        buildMonthSwitch();
                    }
                    triggerEvent("onMonthChange");
                }
                updateNavigationCurrentMonth();
                buildDays();
                updateValue();
                if (self.config.enableTime)
                    setTimeout(function () { return (self.showTimeInput = true); }, 50);
                // maintain focus
                if (!shouldChangeMonth &&
                    self.config.mode !== "range" &&
                    self.config.showMonths === 1)
                    focusOnDayElem(target);
                else if (self.selectedDateElem !== undefined &&
                    self.hourElement === undefined) {
                    self.selectedDateElem && self.selectedDateElem.focus();
                }
                if (self.hourElement !== undefined)
                    self.hourElement !== undefined && self.hourElement.focus();
                if (self.config.closeOnSelect) {
                    var single = self.config.mode === "single" && !self.config.enableTime;
                    var range = self.config.mode === "range" &&
                        self.selectedDates.length === 2 &&
                        !self.config.enableTime;
                    if (single || range) {
                        focusAndClose();
                    }
                }
                triggerChange();
            }
            var CALLBACKS = {
                locale: [setupLocale, updateWeekdays],
                showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
                minDate: [jumpToDate],
                maxDate: [jumpToDate]
            };
            function set(option, value) {
                if (option !== null && typeof option === "object") {
                    Object.assign(self.config, option);
                    for (var key in option) {
                        if (CALLBACKS[key] !== undefined)
                            CALLBACKS[key].forEach(function (x) { return x(); });
                    }
                }
                else {
                    self.config[option] = value;
                    if (CALLBACKS[option] !== undefined)
                        CALLBACKS[option].forEach(function (x) { return x(); });
                    else if (HOOKS.indexOf(option) > -1)
                        self.config[option] = arrayify(value);
                }
                self.redraw();
                updateValue(false);
            }
            function setSelectedDate(inputDate, format) {
                var dates = [];
                if (inputDate instanceof Array)
                    dates = inputDate.map(function (d) { return self.parseDate(d, format); });
                else if (inputDate instanceof Date || typeof inputDate === "number")
                    dates = [self.parseDate(inputDate, format)];
                else if (typeof inputDate === "string") {
                    switch (self.config.mode) {
                        case "single":
                        case "time":
                            dates = [self.parseDate(inputDate, format)];
                            break;
                        case "multiple":
                            dates = inputDate
                                .split(self.config.conjunction)
                                .map(function (date) { return self.parseDate(date, format); });
                            break;
                        case "range":
                            dates = inputDate
                                .split(self.l10n.rangeSeparator)
                                .map(function (date) { return self.parseDate(date, format); });
                            break;
                        default:
                            break;
                    }
                }
                else
                    self.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
                self.selectedDates = dates.filter(function (d) { return d instanceof Date && isEnabled(d, false); });
                if (self.config.mode === "range")
                    self.selectedDates.sort(function (a, b) { return a.getTime() - b.getTime(); });
            }
            function setDate(date, triggerChange, format) {
                if (triggerChange === void 0) { triggerChange = false; }
                if (format === void 0) { format = self.config.dateFormat; }
                if ((date !== 0 && !date) || (date instanceof Array && date.length === 0))
                    return self.clear(triggerChange);
                setSelectedDate(date, format);
                self.showTimeInput = self.selectedDates.length > 0;
                self.latestSelectedDateObj =
                    self.selectedDates[self.selectedDates.length - 1];
                self.redraw();
                jumpToDate();
                setHoursFromDate();
                if (self.selectedDates.length === 0) {
                    self.clear(false);
                }
                updateValue(triggerChange);
                if (triggerChange)
                    triggerEvent("onChange");
            }
            function parseDateRules(arr) {
                return arr
                    .slice()
                    .map(function (rule) {
                    if (typeof rule === "string" ||
                        typeof rule === "number" ||
                        rule instanceof Date) {
                        return self.parseDate(rule, undefined, true);
                    }
                    else if (rule &&
                        typeof rule === "object" &&
                        rule.from &&
                        rule.to)
                        return {
                            from: self.parseDate(rule.from, undefined),
                            to: self.parseDate(rule.to, undefined)
                        };
                    return rule;
                })
                    .filter(function (x) { return x; }); // remove falsy values
            }
            function setupDates() {
                self.selectedDates = [];
                self.now = self.parseDate(self.config.now) || new Date();
                // Workaround IE11 setting placeholder as the input's value
                var preloadedDate = self.config.defaultDate ||
                    ((self.input.nodeName === "INPUT" ||
                        self.input.nodeName === "TEXTAREA") &&
                        self.input.placeholder &&
                        self.input.value === self.input.placeholder
                        ? null
                        : self.input.value);
                if (preloadedDate)
                    setSelectedDate(preloadedDate, self.config.dateFormat);
                self._initialDate =
                    self.selectedDates.length > 0
                        ? self.selectedDates[0]
                        : self.config.minDate &&
                            self.config.minDate.getTime() > self.now.getTime()
                            ? self.config.minDate
                            : self.config.maxDate &&
                                self.config.maxDate.getTime() < self.now.getTime()
                                ? self.config.maxDate
                                : self.now;
                self.currentYear = self._initialDate.getFullYear();
                self.currentMonth = self._initialDate.getMonth();
                if (self.selectedDates.length > 0)
                    self.latestSelectedDateObj = self.selectedDates[0];
                if (self.config.minTime !== undefined)
                    self.config.minTime = self.parseDate(self.config.minTime, "H:i");
                if (self.config.maxTime !== undefined)
                    self.config.maxTime = self.parseDate(self.config.maxTime, "H:i");
                self.minDateHasTime =
                    !!self.config.minDate &&
                        (self.config.minDate.getHours() > 0 ||
                            self.config.minDate.getMinutes() > 0 ||
                            self.config.minDate.getSeconds() > 0);
                self.maxDateHasTime =
                    !!self.config.maxDate &&
                        (self.config.maxDate.getHours() > 0 ||
                            self.config.maxDate.getMinutes() > 0 ||
                            self.config.maxDate.getSeconds() > 0);
                Object.defineProperty(self, "showTimeInput", {
                    get: function () { return self._showTimeInput; },
                    set: function (bool) {
                        self._showTimeInput = bool;
                        if (self.calendarContainer)
                            toggleClass(self.calendarContainer, "showTimeInput", bool);
                        self.isOpen && positionCalendar();
                    }
                });
            }
            function setupInputs() {
                self.input = self.config.wrap
                    ? element.querySelector("[data-input]")
                    : element;
                /* istanbul ignore next */
                if (!self.input) {
                    self.config.errorHandler(new Error("Invalid input element specified"));
                    return;
                }
                // hack: store previous type to restore it after destroy()
                self.input._type = self.input.type;
                self.input.type = "text";
                self.input.classList.add("flatpickr-input");
                self._input = self.input;
                if (self.config.altInput) {
                    // replicate self.element
                    self.altInput = createElement(self.input.nodeName, self.config.altInputClass);
                    self._input = self.altInput;
                    self.altInput.placeholder = self.input.placeholder;
                    self.altInput.disabled = self.input.disabled;
                    self.altInput.required = self.input.required;
                    self.altInput.tabIndex = self.input.tabIndex;
                    self.altInput.type = "text";
                    self.input.setAttribute("type", "hidden");
                    if (!self.config.static && self.input.parentNode)
                        self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
                }
                if (!self.config.allowInput)
                    self._input.setAttribute("readonly", "readonly");
                self._positionElement = self.config.positionElement || self._input;
            }
            function setupMobile() {
                var inputType = self.config.enableTime
                    ? self.config.noCalendar
                        ? "time"
                        : "datetime-local"
                    : "date";
                self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile");
                self.mobileInput.step = self.input.getAttribute("step") || "any";
                self.mobileInput.tabIndex = 1;
                self.mobileInput.type = inputType;
                self.mobileInput.disabled = self.input.disabled;
                self.mobileInput.required = self.input.required;
                self.mobileInput.placeholder = self.input.placeholder;
                self.mobileFormatStr =
                    inputType === "datetime-local"
                        ? "Y-m-d\\TH:i:S"
                        : inputType === "date"
                            ? "Y-m-d"
                            : "H:i:S";
                if (self.selectedDates.length > 0) {
                    self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);
                }
                if (self.config.minDate)
                    self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");
                if (self.config.maxDate)
                    self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");
                self.input.type = "hidden";
                if (self.altInput !== undefined)
                    self.altInput.type = "hidden";
                try {
                    if (self.input.parentNode)
                        self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
                }
                catch (_a) { }
                bind(self.mobileInput, "change", function (e) {
                    self.setDate(e.target.value, false, self.mobileFormatStr);
                    triggerEvent("onChange");
                    triggerEvent("onClose");
                });
            }
            function toggle(e) {
                if (self.isOpen === true)
                    return self.close();
                self.open(e);
            }
            function triggerEvent(event, data) {
                // If the instance has been destroyed already, all hooks have been removed
                if (self.config === undefined)
                    return;
                var hooks = self.config[event];
                if (hooks !== undefined && hooks.length > 0) {
                    for (var i = 0; hooks[i] && i < hooks.length; i++)
                        hooks[i](self.selectedDates, self.input.value, self, data);
                }
                if (event === "onChange") {
                    self.input.dispatchEvent(createEvent("change"));
                    // many front-end frameworks bind to the input event
                    self.input.dispatchEvent(createEvent("input"));
                }
            }
            function createEvent(name) {
                var e = document.createEvent("Event");
                e.initEvent(name, true, true);
                return e;
            }
            function isDateSelected(date) {
                for (var i = 0; i < self.selectedDates.length; i++) {
                    if (compareDates(self.selectedDates[i], date) === 0)
                        return "" + i;
                }
                return false;
            }
            function isDateInRange(date) {
                if (self.config.mode !== "range" || self.selectedDates.length < 2)
                    return false;
                return (compareDates(date, self.selectedDates[0]) >= 0 &&
                    compareDates(date, self.selectedDates[1]) <= 0);
            }
            function updateNavigationCurrentMonth() {
                if (self.config.noCalendar || self.isMobile || !self.monthNav)
                    return;
                self.yearElements.forEach(function (yearElement, i) {
                    var d = new Date(self.currentYear, self.currentMonth, 1);
                    d.setMonth(self.currentMonth + i);
                    if (self.config.showMonths > 1 ||
                        self.config.monthSelectorType === "static") {
                        self.monthElements[i].textContent =
                            monthToStr(d.getMonth(), self.config.shorthandCurrentMonth, self.l10n) + " ";
                    }
                    else {
                        self.monthsDropdownContainer.value = d.getMonth().toString();
                    }
                    yearElement.value = d.getFullYear().toString();
                });
                self._hidePrevMonthArrow =
                    self.config.minDate !== undefined &&
                        (self.currentYear === self.config.minDate.getFullYear()
                            ? self.currentMonth <= self.config.minDate.getMonth()
                            : self.currentYear < self.config.minDate.getFullYear());
                self._hideNextMonthArrow =
                    self.config.maxDate !== undefined &&
                        (self.currentYear === self.config.maxDate.getFullYear()
                            ? self.currentMonth + 1 > self.config.maxDate.getMonth()
                            : self.currentYear > self.config.maxDate.getFullYear());
            }
            function getDateStr(format) {
                return self.selectedDates
                    .map(function (dObj) { return self.formatDate(dObj, format); })
                    .filter(function (d, i, arr) {
                    return self.config.mode !== "range" ||
                        self.config.enableTime ||
                        arr.indexOf(d) === i;
                })
                    .join(self.config.mode !== "range"
                    ? self.config.conjunction
                    : self.l10n.rangeSeparator);
            }
            /**
             * Updates the values of inputs associated with the calendar
             */
            function updateValue(triggerChange) {
                if (triggerChange === void 0) { triggerChange = true; }
                if (self.mobileInput !== undefined && self.mobileFormatStr) {
                    self.mobileInput.value =
                        self.latestSelectedDateObj !== undefined
                            ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr)
                            : "";
                }
                self.input.value = getDateStr(self.config.dateFormat);
                if (self.altInput !== undefined) {
                    self.altInput.value = getDateStr(self.config.altFormat);
                }
                if (triggerChange !== false)
                    triggerEvent("onValueUpdate");
            }
            function onMonthNavClick(e) {
                var isPrevMonth = self.prevMonthNav.contains(e.target);
                var isNextMonth = self.nextMonthNav.contains(e.target);
                if (isPrevMonth || isNextMonth) {
                    changeMonth(isPrevMonth ? -1 : 1);
                }
                else if (self.yearElements.indexOf(e.target) >= 0) {
                    e.target.select();
                }
                else if (e.target.classList.contains("arrowUp")) {
                    self.changeYear(self.currentYear + 1);
                }
                else if (e.target.classList.contains("arrowDown")) {
                    self.changeYear(self.currentYear - 1);
                }
            }
            function timeWrapper(e) {
                e.preventDefault();
                var isKeyDown = e.type === "keydown", input = e.target;
                if (self.amPM !== undefined && e.target === self.amPM) {
                    self.amPM.textContent =
                        self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
                }
                var min = parseFloat(input.getAttribute("min")), max = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e.delta ||
                    (isKeyDown ? (e.which === 38 ? 1 : -1) : 0);
                var newValue = curValue + step * delta;
                if (typeof input.value !== "undefined" && input.value.length === 2) {
                    var isHourElem = input === self.hourElement, isMinuteElem = input === self.minuteElement;
                    if (newValue < min) {
                        newValue =
                            max +
                                newValue +
                                int(!isHourElem) +
                                (int(isHourElem) && int(!self.amPM));
                        if (isMinuteElem)
                            incrementNumInput(undefined, -1, self.hourElement);
                    }
                    else if (newValue > max) {
                        newValue =
                            input === self.hourElement ? newValue - max - int(!self.amPM) : min;
                        if (isMinuteElem)
                            incrementNumInput(undefined, 1, self.hourElement);
                    }
                    if (self.amPM &&
                        isHourElem &&
                        (step === 1
                            ? newValue + curValue === 23
                            : Math.abs(newValue - curValue) > step)) {
                        self.amPM.textContent =
                            self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
                    }
                    input.value = pad(newValue);
                }
            }
            init();
            return self;
        }
        /* istanbul ignore next */
        function _flatpickr(nodeList, config) {
            // static list
            var nodes = Array.prototype.slice
                .call(nodeList)
                .filter(function (x) { return x instanceof HTMLElement; });
            var instances = [];
            for (var i = 0; i < nodes.length; i++) {
                var node = nodes[i];
                try {
                    if (node.getAttribute("data-fp-omit") !== null)
                        continue;
                    if (node._flatpickr !== undefined) {
                        node._flatpickr.destroy();
                        node._flatpickr = undefined;
                    }
                    node._flatpickr = FlatpickrInstance(node, config || {});
                    instances.push(node._flatpickr);
                }
                catch (e) {
                    console.error(e);
                }
            }
            return instances.length === 1 ? instances[0] : instances;
        }
        /* istanbul ignore next */
        if (typeof HTMLElement !== "undefined" &&
            typeof HTMLCollection !== "undefined" &&
            typeof NodeList !== "undefined") {
            // browser env
            HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (config) {
                return _flatpickr(this, config);
            };
            HTMLElement.prototype.flatpickr = function (config) {
                return _flatpickr([this], config);
            };
        }
        /* istanbul ignore next */
        var flatpickr = function (selector, config) {
            if (typeof selector === "string") {
                return _flatpickr(window.document.querySelectorAll(selector), config);
            }
            else if (selector instanceof Node) {
                return _flatpickr([selector], config);
            }
            else {
                return _flatpickr(selector, config);
            }
        };
        /* istanbul ignore next */
        flatpickr.defaultConfig = {};
        flatpickr.l10ns = {
            en: __assign({}, english),
            "default": __assign({}, english)
        };
        flatpickr.localize = function (l10n) {
            flatpickr.l10ns["default"] = __assign({}, flatpickr.l10ns["default"], l10n);
        };
        flatpickr.setDefaults = function (config) {
            flatpickr.defaultConfig = __assign({}, flatpickr.defaultConfig, config);
        };
        flatpickr.parseDate = createDateParser({});
        flatpickr.formatDate = createDateFormatter({});
        flatpickr.compareDates = compareDates;
        /* istanbul ignore next */
        if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
            jQuery.fn.flatpickr = function (config) {
                return _flatpickr(this, config);
            };
        }
        // eslint-disable-next-line @typescript-eslint/camelcase
        Date.prototype.fp_incr = function (days) {
            return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
        };
        if (typeof window !== "undefined") {
            window.flatpickr = flatpickr;
        }

        return flatpickr;

    }));
    });

    function styleInject(css, ref) {
      if ( ref === void 0 ) ref = {};
      var insertAt = ref.insertAt;

      if (!css || typeof document === 'undefined') { return; }

      var head = document.head || document.getElementsByTagName('head')[0];
      var style = document.createElement('style');
      style.type = 'text/css';

      if (insertAt === 'top') {
        if (head.firstChild) {
          head.insertBefore(style, head.firstChild);
        } else {
          head.appendChild(style);
        }
      } else {
        head.appendChild(style);
      }

      if (style.styleSheet) {
        style.styleSheet.cssText = css;
      } else {
        style.appendChild(document.createTextNode(css));
      }
    }

    var css = ".flatpickr-calendar {\n  background: transparent;\n  opacity: 0;\n  display: none;\n  text-align: center;\n  visibility: hidden;\n  padding: 0;\n  -webkit-animation: none;\n          animation: none;\n  direction: ltr;\n  border: 0;\n  font-size: 14px;\n  line-height: 24px;\n  border-radius: 5px;\n  position: absolute;\n  width: 307.875px;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  -ms-touch-action: manipulation;\n      touch-action: manipulation;\n  background: #fff;\n  -webkit-box-shadow: 1px 0 0 #e6e6e6, -1px 0 0 #e6e6e6, 0 1px 0 #e6e6e6, 0 -1px 0 #e6e6e6, 0 3px 13px rgba(0,0,0,0.08);\n          box-shadow: 1px 0 0 #e6e6e6, -1px 0 0 #e6e6e6, 0 1px 0 #e6e6e6, 0 -1px 0 #e6e6e6, 0 3px 13px rgba(0,0,0,0.08);\n}\n.flatpickr-calendar.open,\n.flatpickr-calendar.inline {\n  opacity: 1;\n  max-height: 640px;\n  visibility: visible;\n}\n.flatpickr-calendar.open {\n  display: inline-block;\n  z-index: 99999;\n}\n.flatpickr-calendar.animate.open {\n  -webkit-animation: fpFadeInDown 300ms cubic-bezier(0.23, 1, 0.32, 1);\n          animation: fpFadeInDown 300ms cubic-bezier(0.23, 1, 0.32, 1);\n}\n.flatpickr-calendar.inline {\n  display: block;\n  position: relative;\n  top: 2px;\n}\n.flatpickr-calendar.static {\n  position: absolute;\n  top: calc(100% + 2px);\n}\n.flatpickr-calendar.static.open {\n  z-index: 999;\n  display: block;\n}\n.flatpickr-calendar.multiMonth .flatpickr-days .dayContainer:nth-child(n+1) .flatpickr-day.inRange:nth-child(7n+7) {\n  -webkit-box-shadow: none !important;\n          box-shadow: none !important;\n}\n.flatpickr-calendar.multiMonth .flatpickr-days .dayContainer:nth-child(n+2) .flatpickr-day.inRange:nth-child(7n+1) {\n  -webkit-box-shadow: -2px 0 0 #e6e6e6, 5px 0 0 #e6e6e6;\n          box-shadow: -2px 0 0 #e6e6e6, 5px 0 0 #e6e6e6;\n}\n.flatpickr-calendar .hasWeeks .dayContainer,\n.flatpickr-calendar .hasTime .dayContainer {\n  border-bottom: 0;\n  border-bottom-right-radius: 0;\n  border-bottom-left-radius: 0;\n}\n.flatpickr-calendar .hasWeeks .dayContainer {\n  border-left: 0;\n}\n.flatpickr-calendar.showTimeInput.hasTime .flatpickr-time {\n  height: 40px;\n  border-top: 1px solid #e6e6e6;\n}\n.flatpickr-calendar.noCalendar.hasTime .flatpickr-time {\n  height: auto;\n}\n.flatpickr-calendar:before,\n.flatpickr-calendar:after {\n  position: absolute;\n  display: block;\n  pointer-events: none;\n  border: solid transparent;\n  content: '';\n  height: 0;\n  width: 0;\n  left: 22px;\n}\n.flatpickr-calendar.rightMost:before,\n.flatpickr-calendar.rightMost:after {\n  left: auto;\n  right: 22px;\n}\n.flatpickr-calendar:before {\n  border-width: 5px;\n  margin: 0 -5px;\n}\n.flatpickr-calendar:after {\n  border-width: 4px;\n  margin: 0 -4px;\n}\n.flatpickr-calendar.arrowTop:before,\n.flatpickr-calendar.arrowTop:after {\n  bottom: 100%;\n}\n.flatpickr-calendar.arrowTop:before {\n  border-bottom-color: #e6e6e6;\n}\n.flatpickr-calendar.arrowTop:after {\n  border-bottom-color: #fff;\n}\n.flatpickr-calendar.arrowBottom:before,\n.flatpickr-calendar.arrowBottom:after {\n  top: 100%;\n}\n.flatpickr-calendar.arrowBottom:before {\n  border-top-color: #e6e6e6;\n}\n.flatpickr-calendar.arrowBottom:after {\n  border-top-color: #fff;\n}\n.flatpickr-calendar:focus {\n  outline: 0;\n}\n.flatpickr-wrapper {\n  position: relative;\n  display: inline-block;\n}\n.flatpickr-months {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n}\n.flatpickr-months .flatpickr-month {\n  background: transparent;\n  color: rgba(0,0,0,0.9);\n  fill: rgba(0,0,0,0.9);\n  height: 34px;\n  line-height: 1;\n  text-align: center;\n  position: relative;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  overflow: hidden;\n  -webkit-box-flex: 1;\n  -webkit-flex: 1;\n      -ms-flex: 1;\n          flex: 1;\n}\n.flatpickr-months .flatpickr-prev-month,\n.flatpickr-months .flatpickr-next-month {\n  text-decoration: none;\n  cursor: pointer;\n  position: absolute;\n  top: 0;\n  height: 34px;\n  padding: 10px;\n  z-index: 3;\n  color: rgba(0,0,0,0.9);\n  fill: rgba(0,0,0,0.9);\n}\n.flatpickr-months .flatpickr-prev-month.flatpickr-disabled,\n.flatpickr-months .flatpickr-next-month.flatpickr-disabled {\n  display: none;\n}\n.flatpickr-months .flatpickr-prev-month i,\n.flatpickr-months .flatpickr-next-month i {\n  position: relative;\n}\n.flatpickr-months .flatpickr-prev-month.flatpickr-prev-month,\n.flatpickr-months .flatpickr-next-month.flatpickr-prev-month {\n/*\n      /*rtl:begin:ignore*/\n/*\n      */\n  left: 0;\n/*\n      /*rtl:end:ignore*/\n/*\n      */\n}\n/*\n      /*rtl:begin:ignore*/\n/*\n      /*rtl:end:ignore*/\n.flatpickr-months .flatpickr-prev-month.flatpickr-next-month,\n.flatpickr-months .flatpickr-next-month.flatpickr-next-month {\n/*\n      /*rtl:begin:ignore*/\n/*\n      */\n  right: 0;\n/*\n      /*rtl:end:ignore*/\n/*\n      */\n}\n/*\n      /*rtl:begin:ignore*/\n/*\n      /*rtl:end:ignore*/\n.flatpickr-months .flatpickr-prev-month:hover,\n.flatpickr-months .flatpickr-next-month:hover {\n  color: #959ea9;\n}\n.flatpickr-months .flatpickr-prev-month:hover svg,\n.flatpickr-months .flatpickr-next-month:hover svg {\n  fill: #f64747;\n}\n.flatpickr-months .flatpickr-prev-month svg,\n.flatpickr-months .flatpickr-next-month svg {\n  width: 14px;\n  height: 14px;\n}\n.flatpickr-months .flatpickr-prev-month svg path,\n.flatpickr-months .flatpickr-next-month svg path {\n  -webkit-transition: fill 0.1s;\n  transition: fill 0.1s;\n  fill: inherit;\n}\n.numInputWrapper {\n  position: relative;\n  height: auto;\n}\n.numInputWrapper input,\n.numInputWrapper span {\n  display: inline-block;\n}\n.numInputWrapper input {\n  width: 100%;\n}\n.numInputWrapper input::-ms-clear {\n  display: none;\n}\n.numInputWrapper input::-webkit-outer-spin-button,\n.numInputWrapper input::-webkit-inner-spin-button {\n  margin: 0;\n  -webkit-appearance: none;\n}\n.numInputWrapper span {\n  position: absolute;\n  right: 0;\n  width: 14px;\n  padding: 0 4px 0 2px;\n  height: 50%;\n  line-height: 50%;\n  opacity: 0;\n  cursor: pointer;\n  border: 1px solid rgba(57,57,57,0.15);\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n}\n.numInputWrapper span:hover {\n  background: rgba(0,0,0,0.1);\n}\n.numInputWrapper span:active {\n  background: rgba(0,0,0,0.2);\n}\n.numInputWrapper span:after {\n  display: block;\n  content: \"\";\n  position: absolute;\n}\n.numInputWrapper span.arrowUp {\n  top: 0;\n  border-bottom: 0;\n}\n.numInputWrapper span.arrowUp:after {\n  border-left: 4px solid transparent;\n  border-right: 4px solid transparent;\n  border-bottom: 4px solid rgba(57,57,57,0.6);\n  top: 26%;\n}\n.numInputWrapper span.arrowDown {\n  top: 50%;\n}\n.numInputWrapper span.arrowDown:after {\n  border-left: 4px solid transparent;\n  border-right: 4px solid transparent;\n  border-top: 4px solid rgba(57,57,57,0.6);\n  top: 40%;\n}\n.numInputWrapper span svg {\n  width: inherit;\n  height: auto;\n}\n.numInputWrapper span svg path {\n  fill: rgba(0,0,0,0.5);\n}\n.numInputWrapper:hover {\n  background: rgba(0,0,0,0.05);\n}\n.numInputWrapper:hover span {\n  opacity: 1;\n}\n.flatpickr-current-month {\n  font-size: 135%;\n  line-height: inherit;\n  font-weight: 300;\n  color: inherit;\n  position: absolute;\n  width: 75%;\n  left: 12.5%;\n  padding: 7.48px 0 0 0;\n  line-height: 1;\n  height: 34px;\n  display: inline-block;\n  text-align: center;\n  -webkit-transform: translate3d(0px, 0px, 0px);\n          transform: translate3d(0px, 0px, 0px);\n}\n.flatpickr-current-month span.cur-month {\n  font-family: inherit;\n  font-weight: 700;\n  color: inherit;\n  display: inline-block;\n  margin-left: 0.5ch;\n  padding: 0;\n}\n.flatpickr-current-month span.cur-month:hover {\n  background: rgba(0,0,0,0.05);\n}\n.flatpickr-current-month .numInputWrapper {\n  width: 6ch;\n  width: 7ch\\0;\n  display: inline-block;\n}\n.flatpickr-current-month .numInputWrapper span.arrowUp:after {\n  border-bottom-color: rgba(0,0,0,0.9);\n}\n.flatpickr-current-month .numInputWrapper span.arrowDown:after {\n  border-top-color: rgba(0,0,0,0.9);\n}\n.flatpickr-current-month input.cur-year {\n  background: transparent;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  color: inherit;\n  cursor: text;\n  padding: 0 0 0 0.5ch;\n  margin: 0;\n  display: inline-block;\n  font-size: inherit;\n  font-family: inherit;\n  font-weight: 300;\n  line-height: inherit;\n  height: auto;\n  border: 0;\n  border-radius: 0;\n  vertical-align: initial;\n  -webkit-appearance: textfield;\n  -moz-appearance: textfield;\n  appearance: textfield;\n}\n.flatpickr-current-month input.cur-year:focus {\n  outline: 0;\n}\n.flatpickr-current-month input.cur-year[disabled],\n.flatpickr-current-month input.cur-year[disabled]:hover {\n  font-size: 100%;\n  color: rgba(0,0,0,0.5);\n  background: transparent;\n  pointer-events: none;\n}\n.flatpickr-current-month .flatpickr-monthDropdown-months {\n  appearance: menulist;\n  background: transparent;\n  border: none;\n  border-radius: 0;\n  box-sizing: border-box;\n  color: inherit;\n  cursor: pointer;\n  font-size: inherit;\n  font-family: inherit;\n  font-weight: 300;\n  height: auto;\n  line-height: inherit;\n  margin: -1px 0 0 0;\n  outline: none;\n  padding: 0 0 0 0.5ch;\n  position: relative;\n  vertical-align: initial;\n  -webkit-box-sizing: border-box;\n  -webkit-appearance: menulist;\n  -moz-appearance: menulist;\n  width: auto;\n}\n.flatpickr-current-month .flatpickr-monthDropdown-months:focus,\n.flatpickr-current-month .flatpickr-monthDropdown-months:active {\n  outline: none;\n}\n.flatpickr-current-month .flatpickr-monthDropdown-months:hover {\n  background: rgba(0,0,0,0.05);\n}\n.flatpickr-current-month .flatpickr-monthDropdown-months .flatpickr-monthDropdown-month {\n  background-color: transparent;\n  outline: none;\n  padding: 0;\n}\n.flatpickr-weekdays {\n  background: transparent;\n  text-align: center;\n  overflow: hidden;\n  width: 100%;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-align: center;\n  -webkit-align-items: center;\n      -ms-flex-align: center;\n          align-items: center;\n  height: 28px;\n}\n.flatpickr-weekdays .flatpickr-weekdaycontainer {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-flex: 1;\n  -webkit-flex: 1;\n      -ms-flex: 1;\n          flex: 1;\n}\nspan.flatpickr-weekday {\n  cursor: default;\n  font-size: 90%;\n  background: transparent;\n  color: rgba(0,0,0,0.54);\n  line-height: 1;\n  margin: 0;\n  text-align: center;\n  display: block;\n  -webkit-box-flex: 1;\n  -webkit-flex: 1;\n      -ms-flex: 1;\n          flex: 1;\n  font-weight: bolder;\n}\n.dayContainer,\n.flatpickr-weeks {\n  padding: 1px 0 0 0;\n}\n.flatpickr-days {\n  position: relative;\n  overflow: hidden;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-align: start;\n  -webkit-align-items: flex-start;\n      -ms-flex-align: start;\n          align-items: flex-start;\n  width: 307.875px;\n}\n.flatpickr-days:focus {\n  outline: 0;\n}\n.dayContainer {\n  padding: 0;\n  outline: 0;\n  text-align: left;\n  width: 307.875px;\n  min-width: 307.875px;\n  max-width: 307.875px;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  display: inline-block;\n  display: -ms-flexbox;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: flex;\n  -webkit-flex-wrap: wrap;\n          flex-wrap: wrap;\n  -ms-flex-wrap: wrap;\n  -ms-flex-pack: justify;\n  -webkit-justify-content: space-around;\n          justify-content: space-around;\n  -webkit-transform: translate3d(0px, 0px, 0px);\n          transform: translate3d(0px, 0px, 0px);\n  opacity: 1;\n}\n.dayContainer + .dayContainer {\n  -webkit-box-shadow: -1px 0 0 #e6e6e6;\n          box-shadow: -1px 0 0 #e6e6e6;\n}\n.flatpickr-day {\n  background: none;\n  border: 1px solid transparent;\n  border-radius: 150px;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  color: #393939;\n  cursor: pointer;\n  font-weight: 400;\n  width: 14.2857143%;\n  -webkit-flex-basis: 14.2857143%;\n      -ms-flex-preferred-size: 14.2857143%;\n          flex-basis: 14.2857143%;\n  max-width: 39px;\n  height: 39px;\n  line-height: 39px;\n  margin: 0;\n  display: inline-block;\n  position: relative;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n      -ms-flex-pack: center;\n          justify-content: center;\n  text-align: center;\n}\n.flatpickr-day.inRange,\n.flatpickr-day.prevMonthDay.inRange,\n.flatpickr-day.nextMonthDay.inRange,\n.flatpickr-day.today.inRange,\n.flatpickr-day.prevMonthDay.today.inRange,\n.flatpickr-day.nextMonthDay.today.inRange,\n.flatpickr-day:hover,\n.flatpickr-day.prevMonthDay:hover,\n.flatpickr-day.nextMonthDay:hover,\n.flatpickr-day:focus,\n.flatpickr-day.prevMonthDay:focus,\n.flatpickr-day.nextMonthDay:focus {\n  cursor: pointer;\n  outline: 0;\n  background: #e6e6e6;\n  border-color: #e6e6e6;\n}\n.flatpickr-day.today {\n  border-color: #959ea9;\n}\n.flatpickr-day.today:hover,\n.flatpickr-day.today:focus {\n  border-color: #959ea9;\n  background: #959ea9;\n  color: #fff;\n}\n.flatpickr-day.selected,\n.flatpickr-day.startRange,\n.flatpickr-day.endRange,\n.flatpickr-day.selected.inRange,\n.flatpickr-day.startRange.inRange,\n.flatpickr-day.endRange.inRange,\n.flatpickr-day.selected:focus,\n.flatpickr-day.startRange:focus,\n.flatpickr-day.endRange:focus,\n.flatpickr-day.selected:hover,\n.flatpickr-day.startRange:hover,\n.flatpickr-day.endRange:hover,\n.flatpickr-day.selected.prevMonthDay,\n.flatpickr-day.startRange.prevMonthDay,\n.flatpickr-day.endRange.prevMonthDay,\n.flatpickr-day.selected.nextMonthDay,\n.flatpickr-day.startRange.nextMonthDay,\n.flatpickr-day.endRange.nextMonthDay {\n  background: #569ff7;\n  -webkit-box-shadow: none;\n          box-shadow: none;\n  color: #fff;\n  border-color: #569ff7;\n}\n.flatpickr-day.selected.startRange,\n.flatpickr-day.startRange.startRange,\n.flatpickr-day.endRange.startRange {\n  border-radius: 50px 0 0 50px;\n}\n.flatpickr-day.selected.endRange,\n.flatpickr-day.startRange.endRange,\n.flatpickr-day.endRange.endRange {\n  border-radius: 0 50px 50px 0;\n}\n.flatpickr-day.selected.startRange + .endRange:not(:nth-child(7n+1)),\n.flatpickr-day.startRange.startRange + .endRange:not(:nth-child(7n+1)),\n.flatpickr-day.endRange.startRange + .endRange:not(:nth-child(7n+1)) {\n  -webkit-box-shadow: -10px 0 0 #569ff7;\n          box-shadow: -10px 0 0 #569ff7;\n}\n.flatpickr-day.selected.startRange.endRange,\n.flatpickr-day.startRange.startRange.endRange,\n.flatpickr-day.endRange.startRange.endRange {\n  border-radius: 50px;\n}\n.flatpickr-day.inRange {\n  border-radius: 0;\n  -webkit-box-shadow: -5px 0 0 #e6e6e6, 5px 0 0 #e6e6e6;\n          box-shadow: -5px 0 0 #e6e6e6, 5px 0 0 #e6e6e6;\n}\n.flatpickr-day.flatpickr-disabled,\n.flatpickr-day.flatpickr-disabled:hover,\n.flatpickr-day.prevMonthDay,\n.flatpickr-day.nextMonthDay,\n.flatpickr-day.notAllowed,\n.flatpickr-day.notAllowed.prevMonthDay,\n.flatpickr-day.notAllowed.nextMonthDay {\n  color: rgba(57,57,57,0.3);\n  background: transparent;\n  border-color: transparent;\n  cursor: default;\n}\n.flatpickr-day.flatpickr-disabled,\n.flatpickr-day.flatpickr-disabled:hover {\n  cursor: not-allowed;\n  color: rgba(57,57,57,0.1);\n}\n.flatpickr-day.week.selected {\n  border-radius: 0;\n  -webkit-box-shadow: -5px 0 0 #569ff7, 5px 0 0 #569ff7;\n          box-shadow: -5px 0 0 #569ff7, 5px 0 0 #569ff7;\n}\n.flatpickr-day.hidden {\n  visibility: hidden;\n}\n.rangeMode .flatpickr-day {\n  margin-top: 1px;\n}\n.flatpickr-weekwrapper {\n  float: left;\n}\n.flatpickr-weekwrapper .flatpickr-weeks {\n  padding: 0 12px;\n  -webkit-box-shadow: 1px 0 0 #e6e6e6;\n          box-shadow: 1px 0 0 #e6e6e6;\n}\n.flatpickr-weekwrapper .flatpickr-weekday {\n  float: none;\n  width: 100%;\n  line-height: 28px;\n}\n.flatpickr-weekwrapper span.flatpickr-day,\n.flatpickr-weekwrapper span.flatpickr-day:hover {\n  display: block;\n  width: 100%;\n  max-width: none;\n  color: rgba(57,57,57,0.3);\n  background: transparent;\n  cursor: default;\n  border: none;\n}\n.flatpickr-innerContainer {\n  display: block;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  overflow: hidden;\n}\n.flatpickr-rContainer {\n  display: inline-block;\n  padding: 0;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n}\n.flatpickr-time {\n  text-align: center;\n  outline: 0;\n  display: block;\n  height: 0;\n  line-height: 40px;\n  max-height: 40px;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  overflow: hidden;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n}\n.flatpickr-time:after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n.flatpickr-time .numInputWrapper {\n  -webkit-box-flex: 1;\n  -webkit-flex: 1;\n      -ms-flex: 1;\n          flex: 1;\n  width: 40%;\n  height: 40px;\n  float: left;\n}\n.flatpickr-time .numInputWrapper span.arrowUp:after {\n  border-bottom-color: #393939;\n}\n.flatpickr-time .numInputWrapper span.arrowDown:after {\n  border-top-color: #393939;\n}\n.flatpickr-time.hasSeconds .numInputWrapper {\n  width: 26%;\n}\n.flatpickr-time.time24hr .numInputWrapper {\n  width: 49%;\n}\n.flatpickr-time input {\n  background: transparent;\n  -webkit-box-shadow: none;\n          box-shadow: none;\n  border: 0;\n  border-radius: 0;\n  text-align: center;\n  margin: 0;\n  padding: 0;\n  height: inherit;\n  line-height: inherit;\n  color: #393939;\n  font-size: 14px;\n  position: relative;\n  -webkit-box-sizing: border-box;\n          box-sizing: border-box;\n  -webkit-appearance: textfield;\n  -moz-appearance: textfield;\n  appearance: textfield;\n}\n.flatpickr-time input.flatpickr-hour {\n  font-weight: bold;\n}\n.flatpickr-time input.flatpickr-minute,\n.flatpickr-time input.flatpickr-second {\n  font-weight: 400;\n}\n.flatpickr-time input:focus {\n  outline: 0;\n  border: 0;\n}\n.flatpickr-time .flatpickr-time-separator,\n.flatpickr-time .flatpickr-am-pm {\n  height: inherit;\n  float: left;\n  line-height: inherit;\n  color: #393939;\n  font-weight: bold;\n  width: 2%;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n      -ms-user-select: none;\n          user-select: none;\n  -webkit-align-self: center;\n      -ms-flex-item-align: center;\n          align-self: center;\n}\n.flatpickr-time .flatpickr-am-pm {\n  outline: 0;\n  width: 18%;\n  cursor: pointer;\n  text-align: center;\n  font-weight: 400;\n}\n.flatpickr-time input:hover,\n.flatpickr-time .flatpickr-am-pm:hover,\n.flatpickr-time input:focus,\n.flatpickr-time .flatpickr-am-pm:focus {\n  background: #eee;\n}\n.flatpickr-input[readonly] {\n  cursor: pointer;\n}\n@-webkit-keyframes fpFadeInDown {\n  from {\n    opacity: 0;\n    -webkit-transform: translate3d(0, -20px, 0);\n            transform: translate3d(0, -20px, 0);\n  }\n  to {\n    opacity: 1;\n    -webkit-transform: translate3d(0, 0, 0);\n            transform: translate3d(0, 0, 0);\n  }\n}\n@keyframes fpFadeInDown {\n  from {\n    opacity: 0;\n    -webkit-transform: translate3d(0, -20px, 0);\n            transform: translate3d(0, -20px, 0);\n  }\n  to {\n    opacity: 1;\n    -webkit-transform: translate3d(0, 0, 0);\n            transform: translate3d(0, 0, 0);\n  }\n}\n";
    styleInject(css);

    var css$1 = ".flatpickr-calendar {\n  opacity: 0;\n  display: none;\n  text-align: center;\n  visibility: hidden;\n  padding: 0;\n  -webkit-animation: none;\n  animation: none;\n  direction: ltr;\n  border: 0;\n  font-size: 14px;\n  line-height: 24px;\n  border-radius: 4px;\n  position: absolute;\n  width: 307.875px;\n  -webkit-box-shadow: none !important;\n  box-shadow: none !important;\n  background: rgba(0, 0, 0, 0.9);\n}\n.flatpickr-calendar.open,\n.flatpickr-calendar.inline {\n  opacity: 1;\n  max-height: 640px;\n  visibility: visible;\n}\n.flatpickr-calendar.open {\n  display: inline-block;\n  z-index: 99999;\n}\n.flatpickr-calendar.animate.open {\n  -webkit-animation: fpFadeInDown 300ms cubic-bezier(0.23, 1, 0.32, 1);\n  animation: fpFadeInDown 300ms cubic-bezier(0.23, 1, 0.32, 1);\n}\n.flatpickr-calendar.inline {\n  display: block;\n  position: relative;\n  top: 4px;\n}\n.flatpickr-calendar.static {\n  position: absolute;\n  top: calc(100% + 4px);\n}\n.flatpickr-calendar.static.open {\n  z-index: 999;\n  display: block;\n}\n.flatpickr-calendar.multiMonth\n  .flatpickr-days\n  .dayContainer:nth-child(n + 1)\n  .flatpickr-day.inRange:nth-child(7n + 7) {\n  -webkit-box-shadow: none !important;\n  box-shadow: none !important;\n}\n.flatpickr-calendar.multiMonth\n  .flatpickr-days\n  .dayContainer:nth-child(n + 2)\n  .flatpickr-day.inRange:nth-child(7n + 1) {\n  -webkit-box-shadow: -2px 0 0 #e6e6e6, 5px 0 0 #e6e6e6;\n  box-shadow: -2px 0 0 #e6e6e6, 5px 0 0 #e6e6e6;\n}\n.flatpickr-calendar .hasWeeks .dayContainer,\n.flatpickr-calendar .hasTime .dayContainer {\n  border-bottom: 0;\n  border-bottom-right-radius: 0;\n  border-bottom-left-radius: 0;\n}\n.flatpickr-calendar .hasWeeks .dayContainer {\n  border-left: 0;\n}\n.flatpickr-calendar.showTimeInput.hasTime .flatpickr-time {\n  height: 40px;\n  border-top: 1px solid #20222c;\n}\n.flatpickr-calendar.noCalendar.hasTime .flatpickr-time {\n  height: auto;\n}\n.flatpickr-calendar:before,\n.flatpickr-calendar:after {\n  position: absolute;\n  display: block;\n  pointer-events: none;\n  border: solid transparent;\n  content: \"\";\n  height: 0;\n  width: 0;\n  left: 22px;\n}\n.flatpickr-calendar.rightMost:before,\n.flatpickr-calendar.rightMost:after {\n  left: auto;\n  right: 22px;\n}\n.flatpickr-calendar:before {\n  border-width: 5px;\n  margin: 0 -5px;\n}\n.flatpickr-calendar:after {\n  border-width: 4px;\n  margin: 0 -4px;\n}\n.flatpickr-calendar.arrowTop:before,\n.flatpickr-calendar.arrowTop:after {\n  bottom: 100%;\n}\n.flatpickr-calendar.arrowTop:before {\n  border-bottom-color: #20222c;\n}\n.flatpickr-calendar.arrowTop:after {\n  border-bottom-color: #3f4458;\n}\n.flatpickr-calendar.arrowBottom:before,\n.flatpickr-calendar.arrowBottom:after {\n  top: 100%;\n}\n.flatpickr-calendar.arrowBottom:before {\n  border-top-color: #20222c;\n}\n.flatpickr-calendar.arrowBottom:after {\n  border-top-color: #3f4458;\n}\n.flatpickr-calendar:focus {\n  outline: 0;\n}\n.flatpickr-wrapper {\n  position: relative;\n  display: inline-block;\n}\n.flatpickr-months {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n}\n.flatpickr-months .flatpickr-month {\n  background: transparent;\n  color: #fff;\n  fill: #fff;\n  height: 28px;\n  line-height: 1;\n  text-align: center;\n  position: relative;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  overflow: hidden;\n  -webkit-box-flex: 1;\n  -webkit-flex: 1;\n  -ms-flex: 1;\n  flex: 1;\n}\n.flatpickr-months .flatpickr-prev-month,\n.flatpickr-months .flatpickr-next-month {\n  text-decoration: none;\n  cursor: pointer;\n  position: absolute;\n  top: 0px;\n  line-height: 16px;\n  height: 28px;\n  padding: 10px;\n  z-index: 3;\n  color: #fff;\n  fill: #fff;\n}\n.flatpickr-months .flatpickr-prev-month.disabled,\n.flatpickr-months .flatpickr-next-month.disabled {\n  display: none;\n}\n.flatpickr-months .flatpickr-prev-month i,\n.flatpickr-months .flatpickr-next-month i {\n  position: relative;\n}\n.flatpickr-months .flatpickr-prev-month.flatpickr-prev-month,\n.flatpickr-months .flatpickr-next-month.flatpickr-prev-month {\n  /*\n      /*rtl:begin:ignore*/\n  /*\n      */\n  left: 0;\n  /*\n      /*rtl:end:ignore*/\n  /*\n      */\n}\n/*\n      /*rtl:begin:ignore*/\n/*\n      /*rtl:end:ignore*/\n.flatpickr-months .flatpickr-prev-month.flatpickr-next-month,\n.flatpickr-months .flatpickr-next-month.flatpickr-next-month {\n  /*\n      /*rtl:begin:ignore*/\n  /*\n      */\n  right: 0;\n  /*\n      /*rtl:end:ignore*/\n  /*\n      */\n}\n/*\n      /*rtl:begin:ignore*/\n/*\n      /*rtl:end:ignore*/\n.flatpickr-months .flatpickr-prev-month:hover,\n.flatpickr-months .flatpickr-next-month:hover {\n  color: #eee;\n}\n.flatpickr-months .flatpickr-prev-month:hover svg,\n.flatpickr-months .flatpickr-next-month:hover svg {\n  fill: #f64747;\n}\n.flatpickr-months .flatpickr-prev-month svg,\n.flatpickr-months .flatpickr-next-month svg {\n  width: 14px;\n  height: 14px;\n}\n.flatpickr-months .flatpickr-prev-month svg path,\n.flatpickr-months .flatpickr-next-month svg path {\n  -webkit-transition: fill 0.1s;\n  transition: fill 0.1s;\n  fill: inherit;\n}\n.numInputWrapper {\n  position: relative;\n  height: auto;\n}\n.numInputWrapper input,\n.numInputWrapper span {\n  display: inline-block;\n}\n.numInputWrapper input {\n  width: 100%;\n}\n.numInputWrapper input::-ms-clear {\n  display: none;\n}\n.numInputWrapper span {\n  position: absolute;\n  right: 0;\n  width: 14px;\n  padding: 0 4px 0 2px;\n  height: 50%;\n  line-height: 50%;\n  opacity: 0;\n  cursor: pointer;\n  border: 1px solid rgba(255, 255, 255, 0.15);\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box;\n}\n.numInputWrapper span:hover {\n  background: rgba(192, 187, 167, 0.1);\n}\n.numInputWrapper span:active {\n  background: rgba(192, 187, 167, 0.2);\n}\n.numInputWrapper span:after {\n  display: block;\n  content: \"\";\n  position: absolute;\n}\n.numInputWrapper span.arrowUp {\n  top: 0;\n  border-bottom: 0;\n}\n.numInputWrapper span.arrowUp:after {\n  border-left: 4px solid transparent;\n  border-right: 4px solid transparent;\n  border-bottom: 4px solid rgba(255, 255, 255, 0.6);\n  top: 26%;\n}\n.numInputWrapper span.arrowDown {\n  top: 50%;\n}\n.numInputWrapper span.arrowDown:after {\n  border-left: 4px solid transparent;\n  border-right: 4px solid transparent;\n  border-top: 4px solid rgba(255, 255, 255, 0.6);\n  top: 40%;\n}\n.numInputWrapper span svg {\n  width: inherit;\n  height: auto;\n}\n.numInputWrapper span svg path {\n  fill: rgba(255, 255, 255, 0.5);\n}\n.numInputWrapper:hover {\n  background: rgba(192, 187, 167, 0.05);\n}\n.numInputWrapper:hover span {\n  opacity: 1;\n}\n.flatpickr-current-month {\n  font-size: 135%;\n  line-height: inherit;\n  font-weight: 300;\n  color: inherit;\n  position: absolute;\n  width: 75%;\n  left: 12.5%;\n  padding: 6.16px 0 0 0;\n  line-height: 1;\n  height: 28px;\n  display: inline-block;\n  text-align: center;\n  -webkit-transform: translate3d(0px, 0px, 0px);\n  transform: translate3d(0px, 0px, 0px);\n}\n.flatpickr-current-month span.cur-month {\n  font-family: inherit;\n  font-weight: 700;\n  color: inherit;\n  display: inline-block;\n  margin-left: 0.5ch;\n  padding: 0;\n}\n.flatpickr-current-month span.cur-month:hover {\n  background: rgba(192, 187, 167, 0.05);\n}\n.flatpickr-current-month .numInputWrapper {\n  width: 6ch;\n  width: 7ch\\0;\n  display: inline-block;\n}\n.flatpickr-current-month .numInputWrapper span.arrowUp:after {\n  border-bottom-color: #fff;\n}\n.flatpickr-current-month .numInputWrapper span.arrowDown:after {\n  border-top-color: #fff;\n}\n.flatpickr-current-month input.cur-year {\n  background: transparent;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box;\n  color: inherit;\n  cursor: text;\n  padding: 0 0 0 0.5ch;\n  margin: 0;\n  display: inline-block;\n  font-size: inherit;\n  font-family: inherit;\n  font-weight: 300;\n  line-height: inherit;\n  height: auto;\n  border: 0;\n  border-radius: 0;\n  vertical-align: initial;\n}\n.flatpickr-current-month input.cur-year:focus {\n  outline: 0;\n}\n.flatpickr-current-month input.cur-year[disabled],\n.flatpickr-current-month input.cur-year[disabled]:hover {\n  font-size: 100%;\n  color: rgba(255, 255, 255, 0.5);\n  background: transparent;\n  pointer-events: none;\n}\n.flatpickr-weekdays {\n  background: transparent;\n  text-align: center;\n  overflow: hidden;\n  width: 100%;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-align: center;\n  -webkit-align-items: center;\n  -ms-flex-align: center;\n  align-items: center;\n  height: 28px;\n}\n.flatpickr-weekdays .flatpickr-weekdaycontainer {\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-flex: 1;\n  -webkit-flex: 1;\n  -ms-flex: 1;\n  flex: 1;\n}\nspan.flatpickr-weekday {\n  cursor: default;\n  font-size: 90%;\n  background: transparent;\n  color: #fff;\n  line-height: 1;\n  margin: 0;\n  text-align: center;\n  display: block;\n  -webkit-box-flex: 1;\n  -webkit-flex: 1;\n  -ms-flex: 1;\n  flex: 1;\n  font-weight: bolder;\n}\n.dayContainer,\n.flatpickr-weeks {\n  padding: 1px 0 0 0;\n}\n.flatpickr-days {\n  position: relative;\n  overflow: hidden;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-align: start;\n  -webkit-align-items: flex-start;\n  -ms-flex-align: start;\n  align-items: flex-start;\n  width: 307.875px;\n}\n.flatpickr-days:focus {\n  outline: 0;\n}\n.dayContainer {\n  padding: 0;\n  outline: 0;\n  text-align: left;\n  width: 307.875px;\n  min-width: 307.875px;\n  max-width: 307.875px;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box;\n  display: inline-block;\n  display: -ms-flexbox;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: flex;\n  -webkit-flex-wrap: wrap;\n  flex-wrap: wrap;\n  -ms-flex-wrap: wrap;\n  -ms-flex-pack: justify;\n  -webkit-justify-content: space-around;\n  justify-content: space-around;\n  -webkit-transform: translate3d(0px, 0px, 0px);\n  transform: translate3d(0px, 0px, 0px);\n  opacity: 1;\n}\n.dayContainer + .dayContainer {\n  -webkit-box-shadow: -1px 0 0 #20222c;\n  box-shadow: -1px 0 0 #20222c;\n}\n.flatpickr-day {\n  background: none;\n  border: 1px solid transparent;\n  border-radius: 150px;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box;\n  color: rgba(255, 255, 255, 0.95);\n  cursor: pointer;\n  font-weight: 400;\n  width: 14.2857143%;\n  -webkit-flex-basis: 14.2857143%;\n  -ms-flex-preferred-size: 14.2857143%;\n  flex-basis: 14.2857143%;\n  max-width: 39px;\n  height: 39px;\n  line-height: 39px;\n  margin: 0;\n  display: inline-block;\n  position: relative;\n  -webkit-box-pack: center;\n  -webkit-justify-content: center;\n  -ms-flex-pack: center;\n  justify-content: center;\n  text-align: center;\n}\n.flatpickr-day.inRange,\n.flatpickr-day.prevMonthDay.inRange,\n.flatpickr-day.nextMonthDay.inRange,\n.flatpickr-day.today.inRange,\n.flatpickr-day.prevMonthDay.today.inRange,\n.flatpickr-day.nextMonthDay.today.inRange,\n.flatpickr-day:hover,\n.flatpickr-day.prevMonthDay:hover,\n.flatpickr-day.nextMonthDay:hover,\n.flatpickr-day:focus,\n.flatpickr-day.prevMonthDay:focus,\n.flatpickr-day.nextMonthDay:focus {\n  cursor: pointer;\n  outline: 0;\n  background: #98003c;\n  border-color: #98003c;\n}\n.flatpickr-day.today {\n  border-color: #eee;\n}\n.flatpickr-day.today:hover,\n.flatpickr-day.today:focus {\n  border-color: #eee;\n  background: #eee;\n  color: #3f4458;\n}\n.flatpickr-day.selected,\n.flatpickr-day.startRange,\n.flatpickr-day.endRange,\n.flatpickr-day.selected.inRange,\n.flatpickr-day.startRange.inRange,\n.flatpickr-day.endRange.inRange,\n.flatpickr-day.selected:focus,\n.flatpickr-day.startRange:focus,\n.flatpickr-day.endRange:focus,\n.flatpickr-day.selected:hover,\n.flatpickr-day.startRange:hover,\n.flatpickr-day.endRange:hover,\n.flatpickr-day.selected.prevMonthDay,\n.flatpickr-day.startRange.prevMonthDay,\n.flatpickr-day.endRange.prevMonthDay,\n.flatpickr-day.selected.nextMonthDay,\n.flatpickr-day.startRange.nextMonthDay,\n.flatpickr-day.endRange.nextMonthDay {\n  background: #cb2d6f;\n  -webkit-box-shadow: none;\n  box-shadow: none;\n  color: #fff;\n  border-color: #cb2d6f;\n}\n.flatpickr-day.selected.startRange,\n.flatpickr-day.startRange.startRange,\n.flatpickr-day.endRange.startRange {\n  border-radius: 50px 0 0 50px;\n}\n.flatpickr-day.selected.endRange,\n.flatpickr-day.startRange.endRange,\n.flatpickr-day.endRange.endRange {\n  border-radius: 0 50px 50px 0;\n}\n.flatpickr-day.selected.startRange + .endRange:not(:nth-child(7n + 1)),\n.flatpickr-day.startRange.startRange + .endRange:not(:nth-child(7n + 1)),\n.flatpickr-day.endRange.startRange + .endRange:not(:nth-child(7n + 1)) {\n  -webkit-box-shadow: -10px 0 0 #98003c;\n  box-shadow: -10px 0 0 #98003c;\n}\n.flatpickr-day.selected.startRange.endRange,\n.flatpickr-day.startRange.startRange.endRange,\n.flatpickr-day.endRange.startRange.endRange {\n  border-radius: 50px;\n}\n.flatpickr-day.inRange {\n  border-radius: 0;\n  -webkit-box-shadow: -5px 0 0 #98003c, 5px 0 0 #98003c;\n  box-shadow: -5px 0 0 #98003c, 5px 0 0 #98003c;\n}\n.flatpickr-day.disabled,\n.flatpickr-day.disabled:hover,\n.flatpickr-day.prevMonthDay,\n.flatpickr-day.nextMonthDay,\n.flatpickr-day.notAllowed,\n.flatpickr-day.notAllowed.prevMonthDay,\n.flatpickr-day.notAllowed.nextMonthDay {\n  color: rgba(255, 255, 255, 0.3);\n  background: transparent;\n  border-color: transparent;\n  cursor: default;\n}\n.flatpickr-day.disabled,\n.flatpickr-day.disabled:hover {\n  cursor: not-allowed;\n  color: rgba(255, 255, 255, 0.1);\n}\n.flatpickr-day.week.selected {\n  border-radius: 0;\n  -webkit-box-shadow: -5px 0 0 #80cbc4, 5px 0 0 #80cbc4;\n  box-shadow: -5px 0 0 #80cbc4, 5px 0 0 #80cbc4;\n}\n.flatpickr-day.hidden {\n  visibility: hidden;\n}\n.rangeMode .flatpickr-day {\n  margin-top: 1px;\n}\n.flatpickr-weekwrapper {\n  display: inline-block;\n  float: left;\n}\n.flatpickr-weekwrapper .flatpickr-weeks {\n  padding: 0 12px;\n  -webkit-box-shadow: 1px 0 0 #20222c;\n  box-shadow: 1px 0 0 #20222c;\n}\n.flatpickr-weekwrapper .flatpickr-weekday {\n  float: none;\n  width: 100%;\n  line-height: 28px;\n}\n.flatpickr-weekwrapper span.flatpickr-day,\n.flatpickr-weekwrapper span.flatpickr-day:hover {\n  display: block;\n  width: 100%;\n  max-width: none;\n  color: rgba(255, 255, 255, 0.3);\n  background: transparent;\n  cursor: default;\n  border: none;\n}\n.flatpickr-innerContainer {\n  display: block;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box;\n  overflow: hidden;\n}\n.flatpickr-rContainer {\n  display: inline-block;\n  padding: 0;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box;\n}\n.flatpickr-time {\n  text-align: center;\n  outline: 0;\n  display: block;\n  height: 0;\n  line-height: 40px;\n  max-height: 40px;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box;\n  overflow: hidden;\n  display: -webkit-box;\n  display: -webkit-flex;\n  display: -ms-flexbox;\n  display: flex;\n}\n.flatpickr-time:after {\n  content: \"\";\n  display: table;\n  clear: both;\n}\n.flatpickr-time .numInputWrapper {\n  -webkit-box-flex: 1;\n  -webkit-flex: 1;\n  -ms-flex: 1;\n  flex: 1;\n  width: 40%;\n  height: 40px;\n  float: left;\n}\n.flatpickr-time .numInputWrapper span.arrowUp:after {\n  border-bottom-color: rgba(255, 255, 255, 0.95);\n}\n.flatpickr-time .numInputWrapper span.arrowDown:after {\n  border-top-color: rgba(255, 255, 255, 0.95);\n}\n.flatpickr-time.hasSeconds .numInputWrapper {\n  width: 26%;\n}\n.flatpickr-time.time24hr .numInputWrapper {\n  width: 49%;\n}\n.flatpickr-time input {\n  background: transparent;\n  -webkit-box-shadow: none;\n  box-shadow: none;\n  border: 0;\n  border-radius: 0;\n  text-align: center;\n  margin: 0;\n  padding: 0;\n  height: inherit;\n  line-height: inherit;\n  color: rgba(255, 255, 255, 0.95);\n  font-size: 14px;\n  position: relative;\n  -webkit-box-sizing: border-box;\n  box-sizing: border-box;\n}\n.flatpickr-time input.flatpickr-hour {\n  font-weight: bold;\n}\n.flatpickr-time input.flatpickr-minute,\n.flatpickr-time input.flatpickr-second {\n  font-weight: 400;\n}\n.flatpickr-time input:focus {\n  outline: 0;\n  border: 0;\n}\n.flatpickr-time .flatpickr-time-separator,\n.flatpickr-time .flatpickr-am-pm {\n  height: inherit;\n  display: inline-block;\n  float: left;\n  line-height: inherit;\n  color: rgba(255, 255, 255, 0.95);\n  font-weight: bold;\n  width: 2%;\n  -webkit-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  -webkit-align-self: center;\n  -ms-flex-item-align: center;\n  align-self: center;\n}\n.flatpickr-time .flatpickr-am-pm {\n  outline: 0;\n  width: 18%;\n  cursor: pointer;\n  text-align: center;\n  font-weight: 400;\n}\n.flatpickr-time input:hover,\n.flatpickr-time .flatpickr-am-pm:hover,\n.flatpickr-time input:focus,\n.flatpickr-time .flatpickr-am-pm:focus {\n  background: #707999;\n}\n.flatpickr-input[readonly] {\n  cursor: pointer;\n}\n@-webkit-keyframes fpFadeInDown {\n  from {\n    opacity: 0;\n    -webkit-transform: translate3d(0, -20px, 0);\n    transform: translate3d(0, -20px, 0);\n  }\n  to {\n    opacity: 1;\n    -webkit-transform: translate3d(0, 0, 0);\n    transform: translate3d(0, 0, 0);\n  }\n}\n@keyframes fpFadeInDown {\n  from {\n    opacity: 0;\n    -webkit-transform: translate3d(0, -20px, 0);\n    transform: translate3d(0, -20px, 0);\n  }\n  to {\n    opacity: 1;\n    -webkit-transform: translate3d(0, 0, 0);\n    transform: translate3d(0, 0, 0);\n  }\n}\n";
    styleInject(css$1);

    /* admin/src/components/DatePicker.svelte generated by Svelte v3.9.2 */
    const { Object: Object_1$1 } = globals;

    const file$8 = "admin/src/components/DatePicker.svelte";

    function create_fragment$a(ctx) {
    	var input, dispose;

    	return {
    		c: function create() {
    			input = element("input");
    			attr(input, "type", "date");
    			attr(input, "class", "" + null_to_empty(ctx.className) + " svelte-4yoq4p");
    			attr(input, "placeholder", ctx.placeholder);
    			add_location(input, file$8, 75, 0, 1784);
    			dispose = listen(input, "input", ctx.input_input_handler);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, input, anchor);

    			set_input_value(input, ctx.value);

    			ctx.input_binding(input);
    		},

    		p: function update(changed, ctx) {
    			if (changed.value) set_input_value(input, ctx.value);

    			if (changed.className) {
    				attr(input, "class", "" + null_to_empty(ctx.className) + " svelte-4yoq4p");
    			}

    			if (changed.placeholder) {
    				attr(input, "placeholder", ctx.placeholder);
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(input);
    			}

    			ctx.input_binding(null);
    			dispose();
    		}
    	};
    }

    function instance$9($$self, $$props, $$invalidate) {
    	

      const dispatch = createEventDispatcher();

      let dateInput;
      let fp;
      let { value, placeholder = '', className = '', options = {} } = $$props;

      const hooks = new Set([
        'onChange',
        'onOpen',
        'onClose',
        'onMonthChange',
        'onYearChange',
        'onReady',
        'onValueUpdate',
        'onDayCreate'
      ]);

      onMount(() => {
        $$invalidate('fp', fp = flatpickr(dateInput, addHooks(options)));
      });

      onDestroy(() => { if (fp && 'destroy' in fp) fp.destroy(); });

      const addHooks = (options) => {
        options = Object.assign({}, options);
        for (let hook of hooks) {
          let dispatcher = (selectedDates, dateString, instance) => {
            dispatch(stripOn(hook), [selectedDates, dateString, instance]);
          };
          if (hook in options) {
            // Hooks must be arrays
            if (!Array.isArray(options[hook])) {
              options[hook] = [options[hook]];
            }
            options[hook].push(dispatcher);
          } else {
            options[hook] = [dispatcher];
          }
        }
        if (options.onChange && !options.onChange.includes(updateValue)) {
          options.onChange.push(updateValue);
        }
        return options
      };
      const updateValue = (newValue) => {
        if (Array.isArray(newValue) && newValue.length === 1) {
          newValue = newValue[0];
        }
        $$invalidate('value', value = newValue);
      };
      const stripOn = (hook) => {
        return hook.charAt(2).toLowerCase() + hook.substring(3)
      };

    	const writable_props = ['value', 'placeholder', 'className', 'options'];
    	Object_1$1.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<DatePicker> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		value = this.value;
    		$$invalidate('value', value);
    	}

    	function input_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('dateInput', dateInput = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ('value' in $$props) $$invalidate('value', value = $$props.value);
    		if ('placeholder' in $$props) $$invalidate('placeholder', placeholder = $$props.placeholder);
    		if ('className' in $$props) $$invalidate('className', className = $$props.className);
    		if ('options' in $$props) $$invalidate('options', options = $$props.options);
    	};

    	$$self.$$.update = ($$dirty = { fp: 1, value: 1 }) => {
    		if ($$dirty.fp || $$dirty.value) { if (fp && value) {
            fp.setDate(value);
          } }
    	};

    	return {
    		dateInput,
    		value,
    		placeholder,
    		className,
    		options,
    		input_input_handler,
    		input_binding
    	};
    }

    class DatePicker extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$a, safe_not_equal, ["value", "placeholder", "className", "options"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.value === undefined && !('value' in props)) {
    			console.warn("<DatePicker> was created without expected prop 'value'");
    		}
    	}

    	get value() {
    		throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get className() {
    		throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set className(value) {
    		throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get options() {
    		throw new Error("<DatePicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<DatePicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/semesters/SemesterForm.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$3 } = globals;

    const file$9 = "admin/src/components/semesters/SemesterForm.svelte";

    // (58:39) {:else}
    function create_else_block$1(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Create");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (58:18) {#if defaultDate}
    function create_if_block$6(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Edit");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    function create_fragment$b(ctx) {
    	var h1, t0, t1, form_1, t2, updating_value, t3, label, t5, updating_value_1, t6, div, button, t8, input1, current, dispose;

    	function select_block_type(changed, ctx) {
    		if (ctx.defaultDate) return create_if_block$6;
    		return create_else_block$1;
    	}

    	var current_block_type = select_block_type(null, ctx);
    	var if_block = current_block_type(ctx);

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	function input0_value_binding(value) {
    		ctx.input0_value_binding.call(null, value);
    		updating_value = true;
    		add_flush_callback(() => updating_value = false);
    	}

    	let input0_props = {
    		label: "Name",
    		placeholder: "i.e. 'Autumn 1978'",
    		required: true
    	};
    	if (ctx.name !== void 0) {
    		input0_props.value = ctx.name;
    	}
    	var input0 = new Input({ props: input0_props, $$inline: true });

    	binding_callbacks.push(() => bind(input0, 'value', input0_value_binding));

    	function datepicker_value_binding(value_1) {
    		ctx.datepicker_value_binding.call(null, value_1);
    		updating_value_1 = true;
    		add_flush_callback(() => updating_value_1 = false);
    	}

    	let datepicker_props = {
    		placeholder: "Pick two dates below",
    		className: "input",
    		options: ctx.options
    	};
    	if (ctx.defaultDate !== void 0) {
    		datepicker_props.value = ctx.defaultDate;
    	}
    	var datepicker = new DatePicker({ props: datepicker_props, $$inline: true });

    	binding_callbacks.push(() => bind(datepicker, 'value', datepicker_value_binding));
    	datepicker.$on("change", ctx.change_handler);

    	return {
    		c: function create() {
    			h1 = element("h1");
    			if_block.c();
    			t0 = text(" semester");
    			t1 = space();
    			form_1 = element("form");
    			error.$$.fragment.c();
    			t2 = space();
    			input0.$$.fragment.c();
    			t3 = space();
    			label = element("label");
    			label.textContent = "Start and end dates";
    			t5 = space();
    			datepicker.$$.fragment.c();
    			t6 = space();
    			div = element("div");
    			button = element("button");
    			button.textContent = "Save semester";
    			t8 = space();
    			input1 = element("input");
    			attr(h1, "class", "title");
    			add_location(h1, file$9, 57, 0, 1244);
    			attr(label, "class", "label");
    			add_location(label, file$9, 62, 4, 1517);
    			attr(button, "type", "submit");
    			attr(button, "class", "button is-primary");
    			toggle_class(button, "is-loading", ctx.loading);
    			add_location(button, file$9, 68, 6, 1778);
    			attr(input1, "type", "reset");
    			attr(input1, "class", "button");
    			input1.value = "Cancel";
    			add_location(input1, file$9, 69, 6, 1905);
    			attr(div, "class", "buttons svelte-oih4d0");
    			add_location(div, file$9, 67, 4, 1750);
    			form_1.noValidate = true;
    			attr(form_1, "class", "svelte-oih4d0");
    			add_location(form_1, file$9, 59, 2, 1319);

    			dispose = [
    				listen(form_1, "submit", prevent_default(ctx.handleSubmit)),
    				listen(form_1, "reset", ctx.reset_handler)
    			];
    		},

    		l: function claim(nodes) {
    			throw new Error_1$3("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, h1, anchor);
    			if_block.m(h1, null);
    			append(h1, t0);
    			insert(target, t1, anchor);
    			insert(target, form_1, anchor);
    			mount_component(error, form_1, null);
    			append(form_1, t2);
    			mount_component(input0, form_1, null);
    			append(form_1, t3);
    			append(form_1, label);
    			append(form_1, t5);
    			mount_component(datepicker, form_1, null);
    			append(form_1, t6);
    			append(form_1, div);
    			append(div, button);
    			ctx.button_binding(button);
    			append(div, t8);
    			append(div, input1);
    			ctx.form_1_binding(form_1);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type !== (current_block_type = select_block_type(changed, ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);
    				if (if_block) {
    					if_block.c();
    					if_block.m(h1, t0);
    				}
    			}

    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);

    			var input0_changes = {};
    			if (!updating_value && changed.name) {
    				input0_changes.value = ctx.name;
    			}
    			input0.$set(input0_changes);

    			var datepicker_changes = {};
    			if (changed.options) datepicker_changes.options = ctx.options;
    			if (!updating_value_1 && changed.defaultDate) {
    				datepicker_changes.value = ctx.defaultDate;
    			}
    			datepicker.$set(datepicker_changes);

    			if (changed.loading) {
    				toggle_class(button, "is-loading", ctx.loading);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);

    			transition_in(input0.$$.fragment, local);

    			transition_in(datepicker.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			transition_out(input0.$$.fragment, local);
    			transition_out(datepicker.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h1);
    			}

    			if_block.d();

    			if (detaching) {
    				detach(t1);
    				detach(form_1);
    			}

    			destroy_component(error);

    			destroy_component(input0);

    			destroy_component(datepicker);

    			ctx.button_binding(null);
    			ctx.form_1_binding(null);
    			run_all(dispose);
    		}
    	};
    }

    function instance$a($$self, $$props, $$invalidate) {
    	

      let saveButton;
      let form;
      let startDate;
      let endDate;
      let { errors, loading, name = '', defaultDate = null } = $$props;
      const options = {
        inline: true,
        mode: 'range',
        enableTime: false,
        altInput: true,
        altFormat: 'M j, Y',
        dateFormat: 'Y-m-d'
      };

      const dispatch = createEventDispatcher();

      const handleChange = (selectedDates) => {
        if (selectedDates.length === 2) {
          startDate = selectedDates[0].toISOString();
          endDate = new Date(selectedDates[1].setHours(23, 59, 59, 999)).toISOString();
        }
      };
      const handleSubmit = () => {
        const isValid = form.checkValidity();
        if (!isValid) {
          notifications.add({
            text: 'Please fix form errors first.',
            type: 'danger'
          });
          return
        }
        dispatch('submit', { name, startDate, endDate });
      };

    	const writable_props = ['errors', 'loading', 'name', 'defaultDate'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<SemesterForm> was created with unknown prop '${key}'`);
    	});

    	function reset_handler(event) {
    		bubble($$self, event);
    	}

    	function input0_value_binding(value) {
    		name = value;
    		$$invalidate('name', name);
    	}

    	function datepicker_value_binding(value_1) {
    		defaultDate = value_1;
    		$$invalidate('defaultDate', defaultDate);
    	}

    	function change_handler(event) {
    		return handleChange(...event.detail);
    	}

    	function button_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('saveButton', saveButton = $$value);
    		});
    	}

    	function form_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('form', form = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ('errors' in $$props) $$invalidate('errors', errors = $$props.errors);
    		if ('loading' in $$props) $$invalidate('loading', loading = $$props.loading);
    		if ('name' in $$props) $$invalidate('name', name = $$props.name);
    		if ('defaultDate' in $$props) $$invalidate('defaultDate', defaultDate = $$props.defaultDate);
    	};

    	$$self.$$.update = ($$dirty = { saveButton: 1, loading: 1 }) => {
    		if ($$dirty.saveButton || $$dirty.loading) { if (saveButton) { saveButton.disabled = loading; $$invalidate('saveButton', saveButton), $$invalidate('loading', loading); } }
    	};

    	return {
    		saveButton,
    		form,
    		errors,
    		loading,
    		name,
    		defaultDate,
    		options,
    		handleChange,
    		handleSubmit,
    		reset_handler,
    		input0_value_binding,
    		datepicker_value_binding,
    		change_handler,
    		button_binding,
    		form_1_binding
    	};
    }

    class SemesterForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$b, safe_not_equal, ["errors", "loading", "name", "defaultDate"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.errors === undefined && !('errors' in props)) {
    			console.warn("<SemesterForm> was created without expected prop 'errors'");
    		}
    		if (ctx.loading === undefined && !('loading' in props)) {
    			console.warn("<SemesterForm> was created without expected prop 'loading'");
    		}
    	}

    	get errors() {
    		throw new Error_1$3("<SemesterForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set errors(value) {
    		throw new Error_1$3("<SemesterForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loading() {
    		throw new Error_1$3("<SemesterForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loading(value) {
    		throw new Error_1$3("<SemesterForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error_1$3("<SemesterForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error_1$3("<SemesterForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get defaultDate() {
    		throw new Error_1$3("<SemesterForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set defaultDate(value) {
    		throw new Error_1$3("<SemesterForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/semesters/EditSemester.svelte generated by Svelte v3.9.2 */

    function create_fragment$c(ctx) {
    	var current;

    	var semesterform = new SemesterForm({
    		props: {
    		name: ctx.name,
    		defaultDate: ctx.defaultDate,
    		errors: ctx.errors,
    		loading: ctx.loading
    	},
    		$$inline: true
    	});
    	semesterform.$on("reset", ctx.reset);
    	semesterform.$on("submit", ctx.save);

    	return {
    		c: function create() {
    			semesterform.$$.fragment.c();
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			mount_component(semesterform, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var semesterform_changes = {};
    			if (changed.name) semesterform_changes.name = ctx.name;
    			if (changed.defaultDate) semesterform_changes.defaultDate = ctx.defaultDate;
    			if (changed.errors) semesterform_changes.errors = ctx.errors;
    			if (changed.loading) semesterform_changes.loading = ctx.loading;
    			semesterform.$set(semesterform_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(semesterform.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(semesterform.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(semesterform, detaching);
    		}
    	};
    }

    function instance$b($$self, $$props, $$invalidate) {
    	

      let { id, open = false, semester = {}, name = '', startDate = '', endDate = '' } = $$props;
      let loading = false;
      let errors = '';
      let defaultDate = null;

      onMount(() => {
        $$invalidate('defaultDate', defaultDate = startDate && endDate
          ? [startDate, endDate]
          : null);
      });

      const reset = () => {
        $$invalidate('errors', errors = '');
        $$invalidate('open', open = false);
      };

      const save = async ({ detail }) => {
        $$invalidate('loading', loading = true);
        try {
          await semesters.patch(id, detail);
          notifications.add({ text: `Saved semester '${detail.name}'`, type: 'success' });
          reset();
        } catch (error) {
          $$invalidate('errors', errors = error);
          notifications.add({
            text: 'Could not update semester.',
            type: 'danger'
          });
        } finally {
          $$invalidate('loading', loading = false);
        }
      };

    	const writable_props = ['id', 'open', 'semester', 'name', 'startDate', 'endDate'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<EditSemester> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('id' in $$props) $$invalidate('id', id = $$props.id);
    		if ('open' in $$props) $$invalidate('open', open = $$props.open);
    		if ('semester' in $$props) $$invalidate('semester', semester = $$props.semester);
    		if ('name' in $$props) $$invalidate('name', name = $$props.name);
    		if ('startDate' in $$props) $$invalidate('startDate', startDate = $$props.startDate);
    		if ('endDate' in $$props) $$invalidate('endDate', endDate = $$props.endDate);
    	};

    	return {
    		id,
    		open,
    		semester,
    		name,
    		startDate,
    		endDate,
    		loading,
    		errors,
    		defaultDate,
    		reset,
    		save
    	};
    }

    class EditSemester extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$c, safe_not_equal, ["id", "open", "semester", "name", "startDate", "endDate"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.id === undefined && !('id' in props)) {
    			console.warn("<EditSemester> was created without expected prop 'id'");
    		}
    	}

    	get id() {
    		throw new Error("<EditSemester>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<EditSemester>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get open() {
    		throw new Error("<EditSemester>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set open(value) {
    		throw new Error("<EditSemester>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get semester() {
    		throw new Error("<EditSemester>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set semester(value) {
    		throw new Error("<EditSemester>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<EditSemester>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<EditSemester>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get startDate() {
    		throw new Error("<EditSemester>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set startDate(value) {
    		throw new Error("<EditSemester>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get endDate() {
    		throw new Error("<EditSemester>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set endDate(value) {
    		throw new Error("<EditSemester>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/IconButton.svelte generated by Svelte v3.9.2 */

    const file$a = "admin/src/components/IconButton.svelte";

    function create_fragment$d(ctx) {
    	var button, i, i_class_value, dispose;

    	return {
    		c: function create() {
    			button = element("button");
    			i = element("i");
    			attr(i, "class", i_class_value = "fas fa-" + ctx.name + " svelte-1vxok5w");
    			set_style(i, "--color", ctx.color);
    			add_location(i, file$a, 31, 28, 446);
    			button.disabled = ctx.disabled;
    			attr(button, "class", "svelte-1vxok5w");
    			add_location(button, file$a, 31, 0, 418);
    			dispose = listen(button, "click", ctx.click_handler);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);
    			append(button, i);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.name) && i_class_value !== (i_class_value = "fas fa-" + ctx.name + " svelte-1vxok5w")) {
    				attr(i, "class", i_class_value);
    			}

    			if (changed.color) {
    				set_style(i, "--color", ctx.color);
    			}

    			if (changed.disabled) {
    				button.disabled = ctx.disabled;
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(button);
    			}

    			dispose();
    		}
    	};
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let { name = '', color = 'white', disabled = false } = $$props;

    	const writable_props = ['name', 'color', 'disabled'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<IconButton> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$set = $$props => {
    		if ('name' in $$props) $$invalidate('name', name = $$props.name);
    		if ('color' in $$props) $$invalidate('color', color = $$props.color);
    		if ('disabled' in $$props) $$invalidate('disabled', disabled = $$props.disabled);
    	};

    	return { name, color, disabled, click_handler };
    }

    class IconButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$d, safe_not_equal, ["name", "color", "disabled"]);
    	}

    	get name() {
    		throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<IconButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<IconButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/semesters/SemesterListRow.svelte generated by Svelte v3.9.2 */

    const file$b = "admin/src/components/semesters/SemesterListRow.svelte";

    // (76:6) {#if showEdit}
    function create_if_block$7(ctx) {
    	var updating_open, current;

    	var editsemester_spread_levels = [
    		ctx.semester
    	];

    	function editsemester_open_binding(value) {
    		ctx.editsemester_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let editsemester_props = {};
    	for (var i = 0; i < editsemester_spread_levels.length; i += 1) {
    		editsemester_props = assign(editsemester_props, editsemester_spread_levels[i]);
    	}
    	if (ctx.showEdit !== void 0) {
    		editsemester_props.open = ctx.showEdit;
    	}
    	var editsemester = new EditSemester({
    		props: editsemester_props,
    		$$inline: true
    	});

    	binding_callbacks.push(() => bind(editsemester, 'open', editsemester_open_binding));

    	return {
    		c: function create() {
    			editsemester.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(editsemester, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var editsemester_changes = (changed.semester) ? get_spread_update(editsemester_spread_levels, [
    									ctx.semester
    								]) : {};
    			if (!updating_open && changed.showEdit) {
    				editsemester_changes.open = ctx.showEdit;
    			}
    			editsemester.$set(editsemester_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(editsemester.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(editsemester.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(editsemester, detaching);
    		}
    	};
    }

    // (75:4) <Modal bind:open={showEdit}>
    function create_default_slot$1(ctx) {
    	var if_block_anchor, current;

    	var if_block = (ctx.showEdit) && create_if_block$7(ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.showEdit) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$7(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function create_fragment$e(ctx) {
    	var li, div2, div0, span0, t0_value = ctx.semester.name + "", t0, t1, span1, t2, t3, t4, t5, div1, t6, t7, div3, updating_open, t8, updating_open_1, current;

    	var iconbutton0 = new IconButton({ props: { name: "minus" }, $$inline: true });
    	iconbutton0.$on("click", ctx.showDeleteDialog);

    	var iconbutton1 = new IconButton({ props: { name: "edit" }, $$inline: true });
    	iconbutton1.$on("click", ctx.click_handler);

    	function deleteitem_open_binding(value) {
    		ctx.deleteitem_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let deleteitem_props = {
    		id: ctx.semester.id,
    		store: semesters,
    		type: "semester",
    		name: ctx.semester.name
    	};
    	if (ctx.confirmDelete !== void 0) {
    		deleteitem_props.open = ctx.confirmDelete;
    	}
    	var deleteitem = new DeleteItem({ props: deleteitem_props, $$inline: true });

    	binding_callbacks.push(() => bind(deleteitem, 'open', deleteitem_open_binding));

    	function modal_open_binding(value_1) {
    		ctx.modal_open_binding.call(null, value_1);
    		updating_open_1 = true;
    		add_flush_callback(() => updating_open_1 = false);
    	}

    	let modal_props = {
    		$$slots: { default: [create_default_slot$1] },
    		$$scope: { ctx }
    	};
    	if (ctx.showEdit !== void 0) {
    		modal_props.open = ctx.showEdit;
    	}
    	var modal = new Modal({ props: modal_props, $$inline: true });

    	binding_callbacks.push(() => bind(modal, 'open', modal_open_binding));

    	return {
    		c: function create() {
    			li = element("li");
    			div2 = element("div");
    			div0 = element("div");
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			span1 = element("span");
    			t2 = text(ctx.startDate);
    			t3 = text(" to ");
    			t4 = text(ctx.endDate);
    			t5 = space();
    			div1 = element("div");
    			iconbutton0.$$.fragment.c();
    			t6 = space();
    			iconbutton1.$$.fragment.c();
    			t7 = space();
    			div3 = element("div");
    			deleteitem.$$.fragment.c();
    			t8 = space();
    			modal.$$.fragment.c();
    			attr(span0, "class", "name svelte-1aag63x");
    			add_location(span0, file$b, 61, 6, 1187);
    			attr(span1, "class", "date svelte-1aag63x");
    			add_location(span1, file$b, 62, 6, 1235);
    			attr(div0, "class", "info");
    			add_location(div0, file$b, 60, 4, 1162);
    			attr(div1, "class", "buttons svelte-1aag63x");
    			add_location(div1, file$b, 64, 4, 1301);
    			attr(div2, "class", "firstrow svelte-1aag63x");
    			add_location(div2, file$b, 59, 2, 1135);
    			attr(div3, "class", "action");
    			add_location(div3, file$b, 70, 2, 1479);
    			attr(li, "class", "svelte-1aag63x");
    			add_location(li, file$b, 58, 0, 1128);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, li, anchor);
    			append(li, div2);
    			append(div2, div0);
    			append(div0, span0);
    			append(span0, t0);
    			append(div0, t1);
    			append(div0, span1);
    			append(span1, t2);
    			append(span1, t3);
    			append(span1, t4);
    			append(div2, t5);
    			append(div2, div1);
    			mount_component(iconbutton0, div1, null);
    			append(div1, t6);
    			mount_component(iconbutton1, div1, null);
    			append(li, t7);
    			append(li, div3);
    			mount_component(deleteitem, div3, null);
    			append(div3, t8);
    			mount_component(modal, div3, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if ((!current || changed.semester) && t0_value !== (t0_value = ctx.semester.name + "")) {
    				set_data(t0, t0_value);
    			}

    			if (!current || changed.startDate) {
    				set_data(t2, ctx.startDate);
    			}

    			if (!current || changed.endDate) {
    				set_data(t4, ctx.endDate);
    			}

    			var deleteitem_changes = {};
    			if (changed.semester) deleteitem_changes.id = ctx.semester.id;
    			if (changed.semesters) deleteitem_changes.store = semesters;
    			if (changed.semester) deleteitem_changes.name = ctx.semester.name;
    			if (!updating_open && changed.confirmDelete) {
    				deleteitem_changes.open = ctx.confirmDelete;
    			}
    			deleteitem.$set(deleteitem_changes);

    			var modal_changes = {};
    			if (changed.$$scope || changed.showEdit || changed.semester) modal_changes.$$scope = { changed, ctx };
    			if (!updating_open_1 && changed.showEdit) {
    				modal_changes.open = ctx.showEdit;
    			}
    			modal.$set(modal_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(iconbutton0.$$.fragment, local);

    			transition_in(iconbutton1.$$.fragment, local);

    			transition_in(deleteitem.$$.fragment, local);

    			transition_in(modal.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(iconbutton0.$$.fragment, local);
    			transition_out(iconbutton1.$$.fragment, local);
    			transition_out(deleteitem.$$.fragment, local);
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(li);
    			}

    			destroy_component(iconbutton0);

    			destroy_component(iconbutton1);

    			destroy_component(deleteitem);

    			destroy_component(modal);
    		}
    	};
    }

    function instance$d($$self, $$props, $$invalidate) {
    	

      let confirmDelete = false;
      let showEdit = false;
      let { semester = {} } = $$props;

      const showDeleteDialog = () => { $$invalidate('confirmDelete', confirmDelete = true); };

    	const writable_props = ['semester'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<SemesterListRow> was created with unknown prop '${key}'`);
    	});

    	function click_handler() { showEdit = true; $$invalidate('showEdit', showEdit); }

    	function deleteitem_open_binding(value) {
    		confirmDelete = value;
    		$$invalidate('confirmDelete', confirmDelete);
    	}

    	function editsemester_open_binding(value) {
    		showEdit = value;
    		$$invalidate('showEdit', showEdit);
    	}

    	function modal_open_binding(value_1) {
    		showEdit = value_1;
    		$$invalidate('showEdit', showEdit);
    	}

    	$$self.$set = $$props => {
    		if ('semester' in $$props) $$invalidate('semester', semester = $$props.semester);
    	};

    	let startDate, endDate;

    	$$self.$$.update = ($$dirty = { semester: 1 }) => {
    		if ($$dirty.semester) { $$invalidate('startDate', startDate = (new Date(semester.startDate)).toDateString()); }
    		if ($$dirty.semester) { $$invalidate('endDate', endDate = (new Date(semester.endDate)).toDateString()); }
    	};

    	return {
    		confirmDelete,
    		showEdit,
    		semester,
    		showDeleteDialog,
    		startDate,
    		endDate,
    		click_handler,
    		deleteitem_open_binding,
    		editsemester_open_binding,
    		modal_open_binding
    	};
    }

    class SemesterListRow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$e, safe_not_equal, ["semester"]);
    	}

    	get semester() {
    		throw new Error("<SemesterListRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set semester(value) {
    		throw new Error("<SemesterListRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/semesters/SemesterList.svelte generated by Svelte v3.9.2 */

    const file$c = "admin/src/components/semesters/SemesterList.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.semester = list[i];
    	return child_ctx;
    }

    // (16:0) {#if $semesters && $semesters.length}
    function create_if_block$8(ctx) {
    	var div, p, t0, t1_value = ctx.$semesters.length + "", t1, t2, t3, each_blocks = [], each_1_lookup = new Map(), current;

    	var each_value = ctx.$semesters;

    	const get_key = ctx => ctx.semester.id;

    	for (var i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$1(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			t0 = text("There are ");
    			t1 = text(t1_value);
    			t2 = text(" semesters in the system.");
    			t3 = space();

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();
    			attr(p, "class", "svelte-1ec7ahu");
    			add_location(p, file$c, 17, 1, 273);
    			attr(div, "class", "semester-list svelte-1ec7ahu");
    			add_location(div, file$c, 16, 0, 244);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, p);
    			append(p, t0);
    			append(p, t1);
    			append(p, t2);
    			append(div, t3);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(div, null);

    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if ((!current || changed.$semesters) && t1_value !== (t1_value = ctx.$semesters.length + "")) {
    				set_data(t1, t1_value);
    			}

    			const each_value = ctx.$semesters;

    			group_outros();
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$1, null, get_each_context$1);
    			check_outros();
    		},

    		i: function intro(local) {
    			if (current) return;
    			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

    			current = true;
    		},

    		o: function outro(local) {
    			for (i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d();
    		}
    	};
    }

    // (19:2) {#each $semesters as semester (semester.id)}
    function create_each_block$1(key_1, ctx) {
    	var first, current;

    	var semesterlistrow = new SemesterListRow({
    		props: { semester: ctx.semester },
    		$$inline: true
    	});

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			first = empty();
    			semesterlistrow.$$.fragment.c();
    			this.first = first;
    		},

    		m: function mount(target, anchor) {
    			insert(target, first, anchor);
    			mount_component(semesterlistrow, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var semesterlistrow_changes = {};
    			if (changed.$semesters) semesterlistrow_changes.semester = ctx.semester;
    			semesterlistrow.$set(semesterlistrow_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(semesterlistrow.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(semesterlistrow.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(first);
    			}

    			destroy_component(semesterlistrow, detaching);
    		}
    	};
    }

    function create_fragment$f(ctx) {
    	var if_block_anchor, current;

    	var if_block = (ctx.$semesters && ctx.$semesters.length) && create_if_block$8(ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.$semesters && ctx.$semesters.length) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$8(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let $semesters;

    	validate_store(semesters, 'semesters');
    	component_subscribe($$self, semesters, $$value => { $semesters = $$value; $$invalidate('$semesters', $semesters); });

    	return { $semesters };
    }

    class SemesterList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$f, safe_not_equal, []);
    	}
    }

    /* admin/src/components/semesters/AddSemester.svelte generated by Svelte v3.9.2 */

    const file$d = "admin/src/components/semesters/AddSemester.svelte";

    // (35:0) <Modal bind:open>
    function create_default_slot$2(ctx) {
    	var current;

    	var semesterform = new SemesterForm({
    		props: {
    		errors: ctx.errors,
    		loading: ctx.loading
    	},
    		$$inline: true
    	});
    	semesterform.$on("reset", ctx.reset);
    	semesterform.$on("submit", ctx.save);

    	return {
    		c: function create() {
    			semesterform.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(semesterform, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var semesterform_changes = {};
    			if (changed.errors) semesterform_changes.errors = ctx.errors;
    			if (changed.loading) semesterform_changes.loading = ctx.loading;
    			semesterform.$set(semesterform_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(semesterform.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(semesterform.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(semesterform, detaching);
    		}
    	};
    }

    function create_fragment$g(ctx) {
    	var button, t_1, updating_open, current, dispose;

    	function modal_open_binding(value) {
    		ctx.modal_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let modal_props = {
    		$$slots: { default: [create_default_slot$2] },
    		$$scope: { ctx }
    	};
    	if (ctx.open !== void 0) {
    		modal_props.open = ctx.open;
    	}
    	var modal = new Modal({ props: modal_props, $$inline: true });

    	binding_callbacks.push(() => bind(modal, 'open', modal_open_binding));

    	return {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Add semester";
    			t_1 = space();
    			modal.$$.fragment.c();
    			attr(button, "class", "button is-primary");
    			add_location(button, file$d, 33, 0, 724);
    			dispose = listen(button, "click", ctx.click_handler);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);
    			insert(target, t_1, anchor);
    			mount_component(modal, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var modal_changes = {};
    			if (changed.$$scope || changed.errors || changed.loading) modal_changes.$$scope = { changed, ctx };
    			if (!updating_open && changed.open) {
    				modal_changes.open = ctx.open;
    			}
    			modal.$set(modal_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(button);
    				detach(t_1);
    			}

    			destroy_component(modal, detaching);

    			dispose();
    		}
    	};
    }

    function instance$f($$self, $$props, $$invalidate) {
    	

      let loading = false;
      let errors = '';
      let open = false;

      const reset = () => {
        $$invalidate('errors', errors = '');
        $$invalidate('open', open = false);
      };

      const save = async ({ detail }) => {
        $$invalidate('loading', loading = true);
        try {
          await semesters.create(detail);
          notifications.add({ text: `Saved new semester '${detail.name}'`, type: 'success' });
          reset();
        } catch (error) {
          $$invalidate('errors', errors = error);
          notifications.add({
            text: 'Could not save new semester.',
            type: 'danger'
          });
        } finally {
          $$invalidate('loading', loading = false);
        }
      };

    	function click_handler() { open = true; $$invalidate('open', open); }

    	function modal_open_binding(value) {
    		open = value;
    		$$invalidate('open', open);
    	}

    	return {
    		loading,
    		errors,
    		open,
    		reset,
    		save,
    		click_handler,
    		modal_open_binding
    	};
    }

    class AddSemester extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$g, safe_not_equal, []);
    	}
    }

    /* admin/src/components/Loading.svelte generated by Svelte v3.9.2 */

    const file$e = "admin/src/components/Loading.svelte";

    function create_fragment$h(ctx) {
    	var div, svg, path, t0, p, t1, t2, t3;

    	return {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			t0 = space();
    			p = element("p");
    			t1 = text("Loading ");
    			t2 = text(ctx.what);
    			t3 = text(" ...");
    			attr(path, "fill", "currentColor");
    			attr(path, "d", "M288 39.056v16.659c0 10.804 7.281 20.159 17.686 23.066C383.204 100.434 440 171.518 440 256c0 101.689-82.295 184-184 184-101.689 0-184-82.295-184-184 0-84.47 56.786-155.564 134.312-177.219C216.719 75.874 224 66.517 224 55.712V39.064c0-15.709-14.834-27.153-30.046-23.234C86.603 43.482 7.394 141.206 8.003 257.332c.72 137.052 111.477 246.956 248.531 246.667C393.255 503.711 504 392.788 504 256c0-115.633-79.14-212.779-186.211-240.236C302.678 11.889 288 23.456 288 39.056z");
    			add_location(path, file$e, 22, 4, 452);
    			attr(svg, "aria-hidden", "true");
    			attr(svg, "focusable", "false");
    			attr(svg, "data-prefix", "fas");
    			attr(svg, "data-icon", "circle-notch");
    			attr(svg, "class", "svg-inline--fa fa-circle-notch fa-w-16 fa-spin spinner svelte-16ssi7j");
    			attr(svg, "role", "img");
    			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr(svg, "viewBox", "0 0 512 512");
    			add_location(svg, file$e, 19, 2, 223);
    			add_location(p, file$e, 26, 2, 981);
    			attr(div, "class", "svelte-16ssi7j");
    			add_location(div, file$e, 18, 0, 215);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, svg);
    			append(svg, path);
    			append(div, t0);
    			append(div, p);
    			append(p, t1);
    			append(p, t2);
    			append(p, t3);
    		},

    		p: function update(changed, ctx) {
    			if (changed.what) {
    				set_data(t2, ctx.what);
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}
    		}
    	};
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let { what = 'things' } = $$props;

    	const writable_props = ['what'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Loading> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('what' in $$props) $$invalidate('what', what = $$props.what);
    	};

    	return { what };
    }

    class Loading extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$h, safe_not_equal, ["what"]);
    	}

    	get what() {
    		throw new Error("<Loading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set what(value) {
    		throw new Error("<Loading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/semesters/Semesters.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$4 } = globals;

    const file$f = "admin/src/components/semesters/Semesters.svelte";

    // (32:18) 
    function create_if_block_1$1(ctx) {
    	var current;

    	var loading = new Loading({
    		props: { what: "semesters" },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			loading.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};
    }

    // (29:0) {#if $semesters}
    function create_if_block$9(ctx) {
    	var t, current;

    	var addsemester = new AddSemester({ $$inline: true });

    	var semesterlist = new SemesterList({ $$inline: true });

    	return {
    		c: function create() {
    			addsemester.$$.fragment.c();
    			t = space();
    			semesterlist.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(addsemester, target, anchor);
    			insert(target, t, anchor);
    			mount_component(semesterlist, target, anchor);
    			current = true;
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(addsemester.$$.fragment, local);

    			transition_in(semesterlist.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(addsemester.$$.fragment, local);
    			transition_out(semesterlist.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(addsemester, detaching);

    			if (detaching) {
    				detach(t);
    			}

    			destroy_component(semesterlist, detaching);
    		}
    	};
    }

    function create_fragment$i(ctx) {
    	var t0, h1, t2, t3, current_block_type_index, if_block, if_block_anchor, current;

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	var if_block_creators = [
    		create_if_block$9,
    		create_if_block_1$1
    	];

    	var if_blocks = [];

    	function select_block_type(changed, ctx) {
    		if (ctx.$semesters) return 0;
    		if (!ctx.errors) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(null, ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	return {
    		c: function create() {
    			t0 = space();
    			h1 = element("h1");
    			h1.textContent = "Semesters";
    			t2 = space();
    			error.$$.fragment.c();
    			t3 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			document.title = "Semesters";
    			attr(h1, "class", "title");
    			add_location(h1, file$f, 24, 0, 604);
    		},

    		l: function claim(nodes) {
    			throw new Error_1$4("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t0, anchor);
    			insert(target, h1, anchor);
    			insert(target, t2, anchor);
    			mount_component(error, target, anchor);
    			insert(target, t3, anchor);
    			if (~current_block_type_index) if_blocks[current_block_type_index].m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);

    			var previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(changed, ctx);
    			if (current_block_type_index !== previous_block_index) {
    				if (if_block) {
    					group_outros();
    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});
    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];
    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					}
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);

    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t0);
    				detach(h1);
    				detach(t2);
    			}

    			destroy_component(error, detaching);

    			if (detaching) {
    				detach(t3);
    			}

    			if (~current_block_type_index) if_blocks[current_block_type_index].d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let $semesters;

    	validate_store(semesters, 'semesters');
    	component_subscribe($$self, semesters, $$value => { $semesters = $$value; $$invalidate('$semesters', $semesters); });

    	

      let errors = '';
      onMount(async () => {
        try {
          await semesters.get();
        } catch (error) {
          $$invalidate('errors', errors = error);
          notifications.add({ text: "Couldn't get semesters from server.", type: 'danger' });
        }
      });

    	return { errors, $semesters };
    }

    class Semesters extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$i, safe_not_equal, []);
    	}
    }

    const GET_STUDENTS = /* GraphQL */`
  query getStudents ($orderBy: StudentOrderByInput, $searchString: String) {
    students (orderBy: $orderBy, searchString: $searchString){
      id
      chineseName
      pinyinName
      englishName
      gender
      birthdate
      pointsTally
      groups {
        id
        name
        semester {
          id
          name
        }
      }
    }
  }
`;

    const CREATE_STUDENT = /* GraphQL */` 
mutation createStudent($groupId: ID!, $input: StudentInput!) {
  createStudent(input: $input, groupId: $groupId) {
    id
    chineseName
    englishName
    pinyinName
    birthdate
    gender
    pointsTally
    groups {
      id
      name
      semester {
        id
        name
      }
    }
  }
}
`;

    const DELETE_STUDENT = /* GraphQL */` 
mutation deleteStudent($id: ID!) {
  deleteStudent(id:$id) {
    id
    chineseName
    englishName
  }
}
`;

    const UPDATE_STUDENT = /* GraphQL */`
mutation updateStudent($id: ID!, $input: StudentInput!) {
  updateStudent(input: $input, id: $id) {
    id
    chineseName
    englishName
    pinyinName
    birthdate
    gender
    pointsTally
    groups {
      id
      name
      semester {
        id
        name
      }
    }
  }
}`;

    const MOVE_TO_DIFFERENT_GROUP = /* GraphQL */`
mutation moveStudentToDifferentGroup($oldGroupId: ID!, $newGroupId: ID!, $studentId: ID! ) {
  moveStudentToDifferentGroup(studentId: $studentId, oldGroupId: $oldGroupId, newGroupId: $newGroupId) {
    id
    chineseName
    englishName
    pinyinName
    birthdate
    gender
    pointsTally
    groups {
      id
      name
      semester {
        id
        name
      }
    }
  }
}
`;

    const ADD_STUDENT_TO_GROUP = /* GraphQL */`
mutation addStudentToGroup($groupId: ID!, $studentId: ID! ) {
  addStudentToGroup(studentId: $studentId, groupId: $groupId) {
    id
    chineseName
    englishName
    pinyinName
    birthdate
    gender
    pointsTally
    groups {
      id
      name
      semester {
        id
        name
      }
    }
  }
}
`;

    const REMOVE_STUDENT_FROM_GROUP = /* GraphQL */`
mutation removeStudentFromGroup($groupId: ID!, $studentId: ID! ) {
  removeStudentFromGroup(studentId: $studentId, groupId: $groupId) {
    id
    chineseName
    englishName
    pinyinName
    birthdate
    gender
    pointsTally
    groups {
      id
      name
      semester {
        id
        name
      }
    }
  }
}
`;

    const createstudentstore = () => {
      const { subscribe, set, update } = writable();

      return {
        subscribe,
        get: async (orderBy, searchString) => {
          const getres = await request(GET_STUDENTS, { orderBy, searchString });
          set(getres.students);
        },
        sort: (orderBy, direction) => {
          update(previous => {
            return previous.slice().sort((a, b) => {
              if (!a[orderBy]) return 1
              return a[orderBy].localeCompare(b[orderBy] || '') * direction
            })
          });
        },
        create: async (input, groupId) => {
          const response = await request(CREATE_STUDENT, { input, groupId });
          update(previous => previous && [...previous, response.createStudent]);
        },
        remove: async id => {
          const response = await request(DELETE_STUDENT, { id });
          update(previous =>
            previous.filter(student => response.deleteStudent.id !== student.id)
          );
        },
        patch: async (id, input) => {
          const response = await request(UPDATE_STUDENT, { id, input });
          update(previous => previous.map((student) => {
            if (student.id !== id) return student
            return response.updateStudent
          }));
        },
        moveToDifferentGroup: async (studentId, oldGroupId, newGroupId) => {
          const response = await request(MOVE_TO_DIFFERENT_GROUP, { studentId, oldGroupId, newGroupId });
          update(previous => previous.map((student) => {
            if (student.id !== studentId) return student
            return response.moveStudentToDifferentGroup
          }));
        },
        addStudentToGroup: async (studentId, groupId) => {
          const response = await request(ADD_STUDENT_TO_GROUP, { studentId, groupId });
          update(previous => previous.map((student) => {
            if (student.id !== studentId) return student
            return response.addStudentToGroup
          }));
        },
        removeStudentFromGroup: async (studentId, groupId) => {
          const response = await request(REMOVE_STUDENT_FROM_GROUP, { studentId, groupId });
          update(previous => previous.map((student) => {
            if (student.id !== studentId) return student
            return response.removeStudentFromGroup
          }));
        }
      }
    };

    const students = createstudentstore();

    const ACTIVE_GROUPS = /* GraphQL */`
{
  activeGroups {
    id
    name
    semester {
      name
    }
  }
}
`;

    const CURRENT_NEXT_SEMESTER_GROUPS = /* GraphQL */`
{
  currentSemester {
    id
    name
    groups {
      id
      name
    }
  }
  nextSemester {
    id
    name
    groups {
      id
      name
    }
  }
}
`;

    /* admin/src/components/GroupSelect.svelte generated by Svelte v3.9.2 */

    const file$g = "admin/src/components/GroupSelect.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.group = list[i];
    	return child_ctx;
    }

    // (50:4) {:else}
    function create_else_block_1(ctx) {
    	var option;

    	return {
    		c: function create() {
    			option = element("option");
    			option.textContent = "Loading groups ...";
    			option.__value = "Loading groups ...";
    			option.value = option.__value;
    			add_location(option, file$g, 50, 6, 1243);
    		},

    		m: function mount(target, anchor) {
    			insert(target, option, anchor);
    		},

    		p: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(option);
    			}
    		}
    	};
    }

    // (41:6) {#if groups}
    function create_if_block_1$2(ctx) {
    	var if_block_anchor;

    	function select_block_type_1(changed, ctx) {
    		if (ctx.groups.length) return create_if_block_2$1;
    		return create_else_block$2;
    	}

    	var current_block_type = select_block_type_1(null, ctx);
    	var if_block = current_block_type(ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type_1(changed, ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);
    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},

    		d: function destroy(detaching) {
    			if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    // (47:6) {:else}
    function create_else_block$2(ctx) {
    	var option;

    	return {
    		c: function create() {
    			option = element("option");
    			option.textContent = "No active groups";
    			option.__value = "No active groups";
    			option.value = option.__value;
    			add_location(option, file$g, 47, 6, 1179);
    		},

    		m: function mount(target, anchor) {
    			insert(target, option, anchor);
    		},

    		p: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(option);
    			}
    		}
    	};
    }

    // (42:6) {#if groups.length}
    function create_if_block_2$1(ctx) {
    	var option, each_1_anchor;

    	var each_value = ctx.groups;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			option = element("option");
    			option.textContent = "Select group...";

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    			option.__value = "";
    			option.value = option.__value;
    			add_location(option, file$g, 42, 6, 964);
    		},

    		m: function mount(target, anchor) {
    			insert(target, option, anchor);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert(target, each_1_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (changed.groups) {
    				each_value = ctx.groups;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(option);
    			}

    			destroy_each(each_blocks, detaching);

    			if (detaching) {
    				detach(each_1_anchor);
    			}
    		}
    	};
    }

    // (44:6) {#each groups as group}
    function create_each_block$2(ctx) {
    	var option, t0_value = ctx.group.semester ? ctx.group.semester.name + ' ': "" + "", t0, t1_value = ctx.group.name + "", t1, t2, option_value_value;

    	return {
    		c: function create() {
    			option = element("option");
    			t0 = text(t0_value);
    			t1 = text(t1_value);
    			t2 = text(" class");
    			option.__value = option_value_value = ctx.group.id;
    			option.value = option.__value;
    			add_location(option, file$g, 44, 8, 1044);
    		},

    		m: function mount(target, anchor) {
    			insert(target, option, anchor);
    			append(option, t0);
    			append(option, t1);
    			append(option, t2);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.groups) && t0_value !== (t0_value = ctx.group.semester ? ctx.group.semester.name + ' ': "" + "")) {
    				set_data(t0, t0_value);
    			}

    			if ((changed.groups) && t1_value !== (t1_value = ctx.group.name + "")) {
    				set_data(t1, t1_value);
    			}

    			if ((changed.groups) && option_value_value !== (option_value_value = ctx.group.id)) {
    				option.__value = option_value_value;
    			}

    			option.value = option.__value;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(option);
    			}
    		}
    	};
    }

    // (55:0) {#if errors}
    function create_if_block$a(ctx) {
    	var p, t_value = JSON.stringify(ctx.errors) + "", t;

    	return {
    		c: function create() {
    			p = element("p");
    			t = text(t_value);
    			attr(p, "class", "help is-danger");
    			add_location(p, file$g, 55, 0, 1322);
    		},

    		m: function mount(target, anchor) {
    			insert(target, p, anchor);
    			append(p, t);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.errors) && t_value !== (t_value = JSON.stringify(ctx.errors) + "")) {
    				set_data(t, t_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(p);
    			}
    		}
    	};
    }

    function create_fragment$j(ctx) {
    	var div1, div0, select, t, dispose;

    	function select_block_type(changed, ctx) {
    		if (ctx.groups) return create_if_block_1$2;
    		return create_else_block_1;
    	}

    	var current_block_type = select_block_type(null, ctx);
    	var if_block0 = current_block_type(ctx);

    	var if_block1 = (ctx.errors) && create_if_block$a(ctx);

    	return {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			select = element("select");
    			if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if (ctx.groupId === void 0) add_render_callback(() => ctx.select_change_handler.call(select));
    			select.required = ctx.required;
    			toggle_class(select, "is-loading", !ctx.groups);
    			add_location(select, file$g, 38, 4, 771);
    			attr(div0, "class", "select");
    			add_location(div0, file$g, 37, 2, 746);
    			attr(div1, "class", "field svelte-16aen4b");
    			add_location(div1, file$g, 36, 0, 724);

    			dispose = [
    				listen(select, "change", ctx.select_change_handler),
    				listen(select, "invalid", prevent_default(ctx.checkValidity))
    			];
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, div0);
    			append(div0, select);
    			if_block0.m(select, null);

    			select_option(select, ctx.groupId);

    			ctx.select_binding(select);
    			append(div1, t);
    			if (if_block1) if_block1.m(div1, null);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(changed, ctx)) && if_block0) {
    				if_block0.p(changed, ctx);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);
    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(select, null);
    				}
    			}

    			if (changed.groupId) select_option(select, ctx.groupId);

    			if (changed.required) {
    				select.required = ctx.required;
    			}

    			if (changed.groups) {
    				toggle_class(select, "is-loading", !ctx.groups);
    			}

    			if (ctx.errors) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    				} else {
    					if_block1 = create_if_block$a(ctx);
    					if_block1.c();
    					if_block1.m(div1, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div1);
    			}

    			if_block0.d();
    			ctx.select_binding(null);
    			if (if_block1) if_block1.d();
    			run_all(dispose);
    		}
    	};
    }

    function instance$i($$self, $$props, $$invalidate) {
    	

      let { groups = null } = $$props;
      let selectElement;
      let errors = '';
      let { groupId = '', required = false } = $$props;

      onMount(async () => {
        if (!groups) {
          try {
            const result = await request(ACTIVE_GROUPS);
            $$invalidate('groups', groups = !result ? [] : result.activeGroups);
          } catch (error) {
            $$invalidate('errors', errors = error);
          }

       }
      });

      function checkValidity () {
        $$invalidate('errors', errors = !selectElement.validity.valid && selectElement.validationMessage
          ? selectElement.validationMessage
          : '');
      }

    	const writable_props = ['groups', 'groupId', 'required'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<GroupSelect> was created with unknown prop '${key}'`);
    	});

    	function select_change_handler() {
    		groupId = select_value(this);
    		$$invalidate('groupId', groupId);
    	}

    	function select_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('selectElement', selectElement = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ('groups' in $$props) $$invalidate('groups', groups = $$props.groups);
    		if ('groupId' in $$props) $$invalidate('groupId', groupId = $$props.groupId);
    		if ('required' in $$props) $$invalidate('required', required = $$props.required);
    	};

    	return {
    		groups,
    		selectElement,
    		errors,
    		groupId,
    		required,
    		checkValidity,
    		select_change_handler,
    		select_binding
    	};
    }

    class GroupSelect extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$j, safe_not_equal, ["groups", "groupId", "required"]);
    	}

    	get groups() {
    		throw new Error("<GroupSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set groups(value) {
    		throw new Error("<GroupSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get groupId() {
    		throw new Error("<GroupSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set groupId(value) {
    		throw new Error("<GroupSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get required() {
    		throw new Error("<GroupSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set required(value) {
    		throw new Error("<GroupSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/students/StudentForm.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$5 } = globals;

    const file$h = "admin/src/components/students/StudentForm.svelte";

    // (49:30) {:else}
    function create_else_block$3(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Add");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (49:18) {#if id}
    function create_if_block_2$2(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Edit");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (52:4) {#if errors}
    function create_if_block_1$3(ctx) {
    	var current;

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			error.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(error, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(error, detaching);
    		}
    	};
    }

    // (71:4) {#if !id}
    function create_if_block$b(ctx) {
    	var updating_groupId, current;

    	function groupselect_groupId_binding(value) {
    		ctx.groupselect_groupId_binding.call(null, value);
    		updating_groupId = true;
    		add_flush_callback(() => updating_groupId = false);
    	}

    	let groupselect_props = {};
    	if (ctx.groupId !== void 0) {
    		groupselect_props.groupId = ctx.groupId;
    	}
    	var groupselect = new GroupSelect({ props: groupselect_props, $$inline: true });

    	binding_callbacks.push(() => bind(groupselect, 'groupId', groupselect_groupId_binding));

    	return {
    		c: function create() {
    			groupselect.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(groupselect, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var groupselect_changes = {};
    			if (!updating_groupId && changed.groupId) {
    				groupselect_changes.groupId = ctx.groupId;
    			}
    			groupselect.$set(groupselect_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(groupselect.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(groupselect.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(groupselect, detaching);
    		}
    	};
    }

    function create_fragment$k(ctx) {
    	var h2, t0, t1, form_1, t2, updating_value, t3, updating_value_1, t4, updating_value_2, t5, updating_value_3, t6, div0, label0, input4, t7, t8, label1, input5, t9, t10, t11, div1, button, t13, input6, current, dispose;

    	function select_block_type(changed, ctx) {
    		if (ctx.id) return create_if_block_2$2;
    		return create_else_block$3;
    	}

    	var current_block_type = select_block_type(null, ctx);
    	var if_block0 = current_block_type(ctx);

    	var if_block1 = (ctx.errors) && create_if_block_1$3(ctx);

    	function input0_value_binding(value) {
    		ctx.input0_value_binding.call(null, value);
    		updating_value = true;
    		add_flush_callback(() => updating_value = false);
    	}

    	let input0_props = {
    		label: "Chinese name",
    		placeholder: "孙悟空"
    	};
    	if (ctx.chineseName !== void 0) {
    		input0_props.value = ctx.chineseName;
    	}
    	var input0 = new Input({ props: input0_props, $$inline: true });

    	binding_callbacks.push(() => bind(input0, 'value', input0_value_binding));

    	function input1_value_binding(value_1) {
    		ctx.input1_value_binding.call(null, value_1);
    		updating_value_1 = true;
    		add_flush_callback(() => updating_value_1 = false);
    	}

    	let input1_props = {
    		label: "Pinyin name",
    		placeholder: "Sūn Wùkōng"
    	};
    	if (ctx.pinyinName !== void 0) {
    		input1_props.value = ctx.pinyinName;
    	}
    	var input1 = new Input({ props: input1_props, $$inline: true });

    	binding_callbacks.push(() => bind(input1, 'value', input1_value_binding));

    	function input2_value_binding(value_2) {
    		ctx.input2_value_binding.call(null, value_2);
    		updating_value_2 = true;
    		add_flush_callback(() => updating_value_2 = false);
    	}

    	let input2_props = {
    		label: "English name",
    		placeholder: "Monkey King"
    	};
    	if (ctx.englishName !== void 0) {
    		input2_props.value = ctx.englishName;
    	}
    	var input2 = new Input({ props: input2_props, $$inline: true });

    	binding_callbacks.push(() => bind(input2, 'value', input2_value_binding));

    	function input3_value_binding(value_3) {
    		ctx.input3_value_binding.call(null, value_3);
    		updating_value_3 = true;
    		add_flush_callback(() => updating_value_3 = false);
    	}

    	let input3_props = {
    		type: "date",
    		label: "Birthdate",
    		max: ctx.todaysDate
    	};
    	if (ctx.birthdate !== void 0) {
    		input3_props.value = ctx.birthdate;
    	}
    	var input3 = new Input({ props: input3_props, $$inline: true });

    	binding_callbacks.push(() => bind(input3, 'value', input3_value_binding));

    	var if_block2 = (!ctx.id) && create_if_block$b(ctx);

    	return {
    		c: function create() {
    			h2 = element("h2");
    			if_block0.c();
    			t0 = text(" a student");
    			t1 = space();
    			form_1 = element("form");
    			if (if_block1) if_block1.c();
    			t2 = space();
    			input0.$$.fragment.c();
    			t3 = space();
    			input1.$$.fragment.c();
    			t4 = space();
    			input2.$$.fragment.c();
    			t5 = space();
    			input3.$$.fragment.c();
    			t6 = space();
    			div0 = element("div");
    			label0 = element("label");
    			input4 = element("input");
    			t7 = text("\n\t\t\t\tMale");
    			t8 = space();
    			label1 = element("label");
    			input5 = element("input");
    			t9 = text("\n\t\t\t\tFemale");
    			t10 = space();
    			if (if_block2) if_block2.c();
    			t11 = space();
    			div1 = element("div");
    			button = element("button");
    			button.textContent = "Save student";
    			t13 = space();
    			input6 = element("input");
    			attr(h2, "class", "title");
    			add_location(h2, file$h, 48, 0, 1125);
    			ctx.$$binding_groups[0].push(input4);
    			attr(input4, "type", "radio");
    			input4.__value = "M";
    			input4.value = input4.__value;
    			add_location(input4, file$h, 61, 4, 1722);
    			attr(label0, "class", "radio");
    			add_location(label0, file$h, 60, 3, 1696);
    			ctx.$$binding_groups[0].push(input5);
    			attr(input5, "type", "radio");
    			input5.__value = "F";
    			input5.value = input5.__value;
    			add_location(input5, file$h, 66, 4, 1824);
    			attr(label1, "class", "radio");
    			add_location(label1, file$h, 65, 3, 1798);
    			attr(div0, "class", "control genders svelte-dhu3f3");
    			add_location(div0, file$h, 59, 4, 1663);
    			attr(button, "type", "submit");
    			attr(button, "class", "button is-primary");
    			toggle_class(button, "is-loading", ctx.loading);
    			add_location(button, file$h, 74, 6, 2001);
    			attr(input6, "type", "reset");
    			attr(input6, "class", "button");
    			input6.value = "Cancel";
    			add_location(input6, file$h, 75, 6, 2127);
    			attr(div1, "class", "buttons svelte-dhu3f3");
    			add_location(div1, file$h, 73, 4, 1973);
    			form_1.noValidate = true;
    			add_location(form_1, file$h, 50, 2, 1189);

    			dispose = [
    				listen(input4, "change", ctx.input4_change_handler),
    				listen(input5, "change", ctx.input5_change_handler),
    				listen(form_1, "submit", prevent_default(ctx.handleSubmit)),
    				listen(form_1, "reset", ctx.reset_handler)
    			];
    		},

    		l: function claim(nodes) {
    			throw new Error_1$5("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, h2, anchor);
    			if_block0.m(h2, null);
    			append(h2, t0);
    			insert(target, t1, anchor);
    			insert(target, form_1, anchor);
    			if (if_block1) if_block1.m(form_1, null);
    			append(form_1, t2);
    			mount_component(input0, form_1, null);
    			append(form_1, t3);
    			mount_component(input1, form_1, null);
    			append(form_1, t4);
    			mount_component(input2, form_1, null);
    			append(form_1, t5);
    			mount_component(input3, form_1, null);
    			append(form_1, t6);
    			append(form_1, div0);
    			append(div0, label0);
    			append(label0, input4);

    			input4.checked = input4.__value === ctx.gender;

    			append(label0, t7);
    			append(div0, t8);
    			append(div0, label1);
    			append(label1, input5);

    			input5.checked = input5.__value === ctx.gender;

    			append(label1, t9);
    			append(form_1, t10);
    			if (if_block2) if_block2.m(form_1, null);
    			append(form_1, t11);
    			append(form_1, div1);
    			append(div1, button);
    			ctx.button_binding(button);
    			append(div1, t13);
    			append(div1, input6);
    			ctx.form_1_binding(form_1);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type !== (current_block_type = select_block_type(changed, ctx))) {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);
    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(h2, t0);
    				}
    			}

    			if (ctx.errors) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    					transition_in(if_block1, 1);
    				} else {
    					if_block1 = create_if_block_1$3(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(form_1, t2);
    				}
    			} else if (if_block1) {
    				group_outros();
    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});
    				check_outros();
    			}

    			var input0_changes = {};
    			if (!updating_value && changed.chineseName) {
    				input0_changes.value = ctx.chineseName;
    			}
    			input0.$set(input0_changes);

    			var input1_changes = {};
    			if (!updating_value_1 && changed.pinyinName) {
    				input1_changes.value = ctx.pinyinName;
    			}
    			input1.$set(input1_changes);

    			var input2_changes = {};
    			if (!updating_value_2 && changed.englishName) {
    				input2_changes.value = ctx.englishName;
    			}
    			input2.$set(input2_changes);

    			var input3_changes = {};
    			if (changed.todaysDate) input3_changes.max = ctx.todaysDate;
    			if (!updating_value_3 && changed.birthdate) {
    				input3_changes.value = ctx.birthdate;
    			}
    			input3.$set(input3_changes);

    			if (changed.gender) input4.checked = input4.__value === ctx.gender;
    			if (changed.gender) input5.checked = input5.__value === ctx.gender;

    			if (!ctx.id) {
    				if (if_block2) {
    					if_block2.p(changed, ctx);
    					transition_in(if_block2, 1);
    				} else {
    					if_block2 = create_if_block$b(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(form_1, t11);
    				}
    			} else if (if_block2) {
    				group_outros();
    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});
    				check_outros();
    			}

    			if (changed.loading) {
    				toggle_class(button, "is-loading", ctx.loading);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);

    			transition_in(input0.$$.fragment, local);

    			transition_in(input1.$$.fragment, local);

    			transition_in(input2.$$.fragment, local);

    			transition_in(input3.$$.fragment, local);

    			transition_in(if_block2);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block1);
    			transition_out(input0.$$.fragment, local);
    			transition_out(input1.$$.fragment, local);
    			transition_out(input2.$$.fragment, local);
    			transition_out(input3.$$.fragment, local);
    			transition_out(if_block2);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h2);
    			}

    			if_block0.d();

    			if (detaching) {
    				detach(t1);
    				detach(form_1);
    			}

    			if (if_block1) if_block1.d();

    			destroy_component(input0);

    			destroy_component(input1);

    			destroy_component(input2);

    			destroy_component(input3);

    			ctx.$$binding_groups[0].splice(ctx.$$binding_groups[0].indexOf(input4), 1);
    			ctx.$$binding_groups[0].splice(ctx.$$binding_groups[0].indexOf(input5), 1);
    			if (if_block2) if_block2.d();
    			ctx.button_binding(null);
    			ctx.form_1_binding(null);
    			run_all(dispose);
    		}
    	};
    }

    function instance$j($$self, $$props, $$invalidate) {
    	

      const dispatch = createEventDispatcher();

      let { chineseName = '', pinyinName = '', englishName = '', birthdate = null, groupId = null, id = null, loading = false, errors, groups = [], gender = null } = $$props;
      let form;
      let saveButton;

      const todaysDate = new Date().toISOString().slice(0, 10);

      const handleSubmit = () => {
        const isValid = form.checkValidity();
        if (!isValid) {
          notifications.add({
            text: 'Please fix form errors first.',
            type: 'danger'
          });
          return
        }
        dispatch('submit', { id, chineseName, birthdate, englishName, pinyinName, gender, groupId });
      };

    	const writable_props = ['chineseName', 'pinyinName', 'englishName', 'birthdate', 'groupId', 'id', 'loading', 'errors', 'groups', 'gender'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<StudentForm> was created with unknown prop '${key}'`);
    	});

    	const $$binding_groups = [[]];

    	function reset_handler(event) {
    		bubble($$self, event);
    	}

    	function input0_value_binding(value) {
    		chineseName = value;
    		$$invalidate('chineseName', chineseName);
    	}

    	function input1_value_binding(value_1) {
    		pinyinName = value_1;
    		$$invalidate('pinyinName', pinyinName);
    	}

    	function input2_value_binding(value_2) {
    		englishName = value_2;
    		$$invalidate('englishName', englishName);
    	}

    	function input3_value_binding(value_3) {
    		birthdate = value_3;
    		$$invalidate('birthdate', birthdate);
    	}

    	function input4_change_handler() {
    		gender = this.__value;
    		$$invalidate('gender', gender);
    	}

    	function input5_change_handler() {
    		gender = this.__value;
    		$$invalidate('gender', gender);
    	}

    	function groupselect_groupId_binding(value) {
    		groupId = value;
    		$$invalidate('groupId', groupId);
    	}

    	function button_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('saveButton', saveButton = $$value);
    		});
    	}

    	function form_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('form', form = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ('chineseName' in $$props) $$invalidate('chineseName', chineseName = $$props.chineseName);
    		if ('pinyinName' in $$props) $$invalidate('pinyinName', pinyinName = $$props.pinyinName);
    		if ('englishName' in $$props) $$invalidate('englishName', englishName = $$props.englishName);
    		if ('birthdate' in $$props) $$invalidate('birthdate', birthdate = $$props.birthdate);
    		if ('groupId' in $$props) $$invalidate('groupId', groupId = $$props.groupId);
    		if ('id' in $$props) $$invalidate('id', id = $$props.id);
    		if ('loading' in $$props) $$invalidate('loading', loading = $$props.loading);
    		if ('errors' in $$props) $$invalidate('errors', errors = $$props.errors);
    		if ('groups' in $$props) $$invalidate('groups', groups = $$props.groups);
    		if ('gender' in $$props) $$invalidate('gender', gender = $$props.gender);
    	};

    	$$self.$$.update = ($$dirty = { saveButton: 1, loading: 1 }) => {
    		if ($$dirty.saveButton || $$dirty.loading) { if (saveButton) { saveButton.disabled = loading; $$invalidate('saveButton', saveButton), $$invalidate('loading', loading); } }
    	};

    	return {
    		chineseName,
    		pinyinName,
    		englishName,
    		birthdate,
    		groupId,
    		id,
    		loading,
    		errors,
    		groups,
    		gender,
    		form,
    		saveButton,
    		todaysDate,
    		handleSubmit,
    		reset_handler,
    		input0_value_binding,
    		input1_value_binding,
    		input2_value_binding,
    		input3_value_binding,
    		input4_change_handler,
    		input5_change_handler,
    		groupselect_groupId_binding,
    		button_binding,
    		form_1_binding,
    		$$binding_groups
    	};
    }

    class StudentForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$k, safe_not_equal, ["chineseName", "pinyinName", "englishName", "birthdate", "groupId", "id", "loading", "errors", "groups", "gender"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.errors === undefined && !('errors' in props)) {
    			console.warn("<StudentForm> was created without expected prop 'errors'");
    		}
    	}

    	get chineseName() {
    		throw new Error_1$5("<StudentForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set chineseName(value) {
    		throw new Error_1$5("<StudentForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pinyinName() {
    		throw new Error_1$5("<StudentForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pinyinName(value) {
    		throw new Error_1$5("<StudentForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get englishName() {
    		throw new Error_1$5("<StudentForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set englishName(value) {
    		throw new Error_1$5("<StudentForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get birthdate() {
    		throw new Error_1$5("<StudentForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set birthdate(value) {
    		throw new Error_1$5("<StudentForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get groupId() {
    		throw new Error_1$5("<StudentForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set groupId(value) {
    		throw new Error_1$5("<StudentForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error_1$5("<StudentForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error_1$5("<StudentForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loading() {
    		throw new Error_1$5("<StudentForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loading(value) {
    		throw new Error_1$5("<StudentForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get errors() {
    		throw new Error_1$5("<StudentForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set errors(value) {
    		throw new Error_1$5("<StudentForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get groups() {
    		throw new Error_1$5("<StudentForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set groups(value) {
    		throw new Error_1$5("<StudentForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get gender() {
    		throw new Error_1$5("<StudentForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set gender(value) {
    		throw new Error_1$5("<StudentForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/students/EditStudent.svelte generated by Svelte v3.9.2 */

    function create_fragment$l(ctx) {
    	var current;

    	var studentform_spread_levels = [
    		{ errors: ctx.errors },
    		{ loading: ctx.loading },
    		ctx.student,
    		{ birthdate: ctx.student.birthdate &&
      ctx.student.birthdate.slice(0,10) }
    	];

    	let studentform_props = {};
    	for (var i = 0; i < studentform_spread_levels.length; i += 1) {
    		studentform_props = assign(studentform_props, studentform_spread_levels[i]);
    	}
    	var studentform = new StudentForm({ props: studentform_props, $$inline: true });
    	studentform.$on("reset", ctx.reset);
    	studentform.$on("submit", ctx.save);

    	return {
    		c: function create() {
    			studentform.$$.fragment.c();
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			mount_component(studentform, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var studentform_changes = (changed.errors || changed.loading || changed.student) ? get_spread_update(studentform_spread_levels, [
    									(changed.errors) && { errors: ctx.errors },
    			(changed.loading) && { loading: ctx.loading },
    			(changed.student) && ctx.student,
    			(changed.student) && { birthdate: ctx.student.birthdate &&
      ctx.student.birthdate.slice(0,10) }
    								]) : {};
    			studentform.$set(studentform_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(studentform.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(studentform.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(studentform, detaching);
    		}
    	};
    }

    function instance$k($$self, $$props, $$invalidate) {
    	

      let { open = false } = $$props;
      let errors = null;
      let loading = false;
      let { student } = $$props;

      const reset = () => {
        $$invalidate('errors', errors = null);
        $$invalidate('open', open = false);
      };

      const save = async ({ detail }) => {
        const { id, groupId, ...input } = detail;
        $$invalidate('loading', loading = true);
        try {
          await students.patch(id, input);
          notifications.add({ text: `Saved changes to student: '${detail.englishName}'`, type: 'success' });
          reset();
        } catch (error) {
          $$invalidate('errors', errors = error);
          notifications.add({ text: 'Could not save changes to student', type: 'danger' });
        } finally {
          $$invalidate('loading', loading = false);
        }
      };

    	const writable_props = ['open', 'student'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<EditStudent> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('open' in $$props) $$invalidate('open', open = $$props.open);
    		if ('student' in $$props) $$invalidate('student', student = $$props.student);
    	};

    	return {
    		open,
    		errors,
    		loading,
    		student,
    		reset,
    		save
    	};
    }

    class EditStudent extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$l, safe_not_equal, ["open", "student"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.student === undefined && !('student' in props)) {
    			console.warn("<EditStudent> was created without expected prop 'student'");
    		}
    	}

    	get open() {
    		throw new Error("<EditStudent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set open(value) {
    		throw new Error("<EditStudent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get student() {
    		throw new Error("<EditStudent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set student(value) {
    		throw new Error("<EditStudent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/students/EditStudentGroups.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$6 } = globals;

    const file$i = "admin/src/components/students/EditStudentGroups.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.group = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.group = list[i];
    	return child_ctx;
    }

    // (122:2) {:catch error}
    function create_catch_block(ctx) {
    	var t_value = ctx.error + "", t;

    	return {
    		c: function create() {
    			t = text(t_value);
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.semesters) && t_value !== (t_value = ctx.error + "")) {
    				set_data(t, t_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (93:0) {:then result}
    function create_then_block(ctx) {
    	var t, if_block1_anchor;

    	var if_block0 = (ctx.result && ctx.result.currentSemester) && create_if_block_1$4(ctx);

    	var if_block1 = (ctx.result && ctx.result.nextSemester) && create_if_block$c(ctx);

    	return {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert(target, if_block1_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.result && ctx.result.currentSemester) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    				} else {
    					if_block0 = create_if_block_1$4(ctx);
    					if_block0.c();
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (ctx.result && ctx.result.nextSemester) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    				} else {
    					if_block1 = create_if_block$c(ctx);
    					if_block1.c();
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},

    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);

    			if (detaching) {
    				detach(t);
    			}

    			if (if_block1) if_block1.d(detaching);

    			if (detaching) {
    				detach(if_block1_anchor);
    			}
    		}
    	};
    }

    // (95:2) {#if result && result.currentSemester}
    function create_if_block_1$4(ctx) {
    	var label, t_1, div1, div0, select, option, dispose;

    	var each_value_1 = ctx.result.currentSemester.groups;

    	var each_blocks = [];

    	for (var i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	function change_handler() {
    		return ctx.change_handler(ctx);
    	}

    	return {
    		c: function create() {
    			label = element("label");
    			label.textContent = "Current semester";
    			t_1 = space();
    			div1 = element("div");
    			div0 = element("div");
    			select = element("select");
    			option = element("option");
    			option.textContent = "none";

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			attr(label, "class", "label svelte-iubj27");
    			add_location(label, file$i, 95, 4, 2755);
    			option.__value = "";
    			option.value = option.__value;
    			add_location(option, file$i, 99, 14, 3052);
    			if (ctx.currentSemester === void 0) add_render_callback(() => ctx.select_change_handler.call(select));
    			add_location(select, file$i, 98, 10, 2901);
    			attr(div0, "class", "select");
    			toggle_class(div0, "is-loading", ctx.currentLoading);
    			add_location(div0, file$i, 97, 8, 2836);
    			attr(div1, "class", "control svelte-iubj27");
    			add_location(div1, file$i, 96, 4, 2806);

    			dispose = [
    				listen(select, "change", ctx.select_change_handler),
    				listen(select, "change", change_handler)
    			];
    		},

    		m: function mount(target, anchor) {
    			insert(target, label, anchor);
    			insert(target, t_1, anchor);
    			insert(target, div1, anchor);
    			append(div1, div0);
    			append(div0, select);
    			append(select, option);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			select_option(select, ctx.currentSemester);

    			ctx.select_binding(select);
    		},

    		p: function update(changed, new_ctx) {
    			ctx = new_ctx;
    			if (changed.semesters || changed.isInGroup) {
    				each_value_1 = ctx.result.currentSemester.groups;

    				for (var i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value_1.length;
    			}

    			if (changed.currentSemester) select_option(select, ctx.currentSemester);

    			if (changed.currentLoading) {
    				toggle_class(div0, "is-loading", ctx.currentLoading);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(label);
    				detach(t_1);
    				detach(div1);
    			}

    			destroy_each(each_blocks, detaching);

    			ctx.select_binding(null);
    			run_all(dispose);
    		}
    	};
    }

    // (101:14) {#each result.currentSemester.groups as group}
    function create_each_block_1(ctx) {
    	var option, t_value = ctx.group.name + "", t, option_value_value, option_selected_value;

    	return {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = ctx.group.id;
    			option.value = option.__value;
    			option.selected = option_selected_value = ctx.isInGroup(ctx.group.id);
    			add_location(option, file$i, 101, 16, 3160);
    		},

    		m: function mount(target, anchor) {
    			insert(target, option, anchor);
    			append(option, t);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.semesters) && t_value !== (t_value = ctx.group.name + "")) {
    				set_data(t, t_value);
    			}

    			if ((changed.semesters) && option_value_value !== (option_value_value = ctx.group.id)) {
    				option.__value = option_value_value;
    			}

    			option.value = option.__value;

    			if ((changed.semesters) && option_selected_value !== (option_selected_value = ctx.isInGroup(ctx.group.id))) {
    				option.selected = option_selected_value;
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(option);
    			}
    		}
    	};
    }

    // (109:2) {#if result && result.nextSemester}
    function create_if_block$c(ctx) {
    	var label, t0_value = ctx.result.nextSemester.name + "", t0, t1, div1, div0, select, option, dispose;

    	var each_value = ctx.result.nextSemester.groups;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	function change_handler_1() {
    		return ctx.change_handler_1(ctx);
    	}

    	return {
    		c: function create() {
    			label = element("label");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			div0 = element("div");
    			select = element("select");
    			option = element("option");
    			option.textContent = "none";

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			attr(label, "class", "label svelte-iubj27");
    			add_location(label, file$i, 109, 2, 3357);
    			option.__value = "";
    			option.value = option.__value;
    			add_location(option, file$i, 113, 8, 3632);
    			if (ctx.nextSemester === void 0) add_render_callback(() => ctx.select_change_handler_1.call(select));
    			add_location(select, file$i, 112, 6, 3499);
    			attr(div0, "class", "select");
    			toggle_class(div0, "is-loading", ctx.nextLoading);
    			add_location(div0, file$i, 111, 4, 3441);
    			attr(div1, "class", "control svelte-iubj27");
    			add_location(div1, file$i, 110, 2, 3415);

    			dispose = [
    				listen(select, "change", ctx.select_change_handler_1),
    				listen(select, "change", change_handler_1)
    			];
    		},

    		m: function mount(target, anchor) {
    			insert(target, label, anchor);
    			append(label, t0);
    			insert(target, t1, anchor);
    			insert(target, div1, anchor);
    			append(div1, div0);
    			append(div0, select);
    			append(select, option);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			select_option(select, ctx.nextSemester);

    			ctx.select_binding_1(select);
    		},

    		p: function update(changed, new_ctx) {
    			ctx = new_ctx;
    			if ((changed.semesters) && t0_value !== (t0_value = ctx.result.nextSemester.name + "")) {
    				set_data(t0, t0_value);
    			}

    			if (changed.semesters || changed.isInGroup) {
    				each_value = ctx.result.nextSemester.groups;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}

    			if (changed.nextSemester) select_option(select, ctx.nextSemester);

    			if (changed.nextLoading) {
    				toggle_class(div0, "is-loading", ctx.nextLoading);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(label);
    				detach(t1);
    				detach(div1);
    			}

    			destroy_each(each_blocks, detaching);

    			ctx.select_binding_1(null);
    			run_all(dispose);
    		}
    	};
    }

    // (115:8) {#each result.nextSemester.groups as group}
    function create_each_block$3(ctx) {
    	var option, t_value = ctx.group.name + "", t, option_value_value, option_selected_value;

    	return {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = ctx.group.id;
    			option.value = option.__value;
    			option.selected = option_selected_value = ctx.isInGroup(ctx.group.id);
    			add_location(option, file$i, 115, 10, 3725);
    		},

    		m: function mount(target, anchor) {
    			insert(target, option, anchor);
    			append(option, t);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.semesters) && t_value !== (t_value = ctx.group.name + "")) {
    				set_data(t, t_value);
    			}

    			if ((changed.semesters) && option_value_value !== (option_value_value = ctx.group.id)) {
    				option.__value = option_value_value;
    			}

    			option.value = option.__value;

    			if ((changed.semesters) && option_selected_value !== (option_selected_value = ctx.isInGroup(ctx.group.id))) {
    				option.selected = option_selected_value;
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(option);
    			}
    		}
    	};
    }

    // (91:20)    Loading groups ... {:then result}
    function create_pending_block(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Loading groups ...");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		p: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    function create_fragment$m(ctx) {
    	var h2, t0, t1_value = ctx.student.englishName + "", t1, t2, t3, t4, div0, promise, t5, div1, button, current, dispose;

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		pending: create_pending_block,
    		then: create_then_block,
    		catch: create_catch_block,
    		value: 'result',
    		error: 'error'
    	};

    	handle_promise(promise = ctx.semesters, info);

    	return {
    		c: function create() {
    			h2 = element("h2");
    			t0 = text("Change ");
    			t1 = text(t1_value);
    			t2 = text("'s classes");
    			t3 = space();
    			error.$$.fragment.c();
    			t4 = space();
    			div0 = element("div");

    			info.block.c();

    			t5 = space();
    			div1 = element("div");
    			button = element("button");
    			button.textContent = "Done";
    			attr(h2, "class", "title");
    			add_location(h2, file$i, 87, 0, 2542);
    			attr(div0, "class", "grid-container svelte-iubj27");
    			add_location(div0, file$i, 89, 0, 2623);
    			attr(button, "class", "button is-primary");
    			toggle_class(button, "is-loading", ctx.loading);
    			add_location(button, file$i, 127, 4, 3939);
    			attr(div1, "class", "buttons svelte-iubj27");
    			add_location(div1, file$i, 126, 2, 3913);
    			dispose = listen(button, "click", ctx.click_handler);
    		},

    		l: function claim(nodes) {
    			throw new Error_1$6("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, h2, anchor);
    			append(h2, t0);
    			append(h2, t1);
    			append(h2, t2);
    			insert(target, t3, anchor);
    			mount_component(error, target, anchor);
    			insert(target, t4, anchor);
    			insert(target, div0, anchor);

    			info.block.m(div0, info.anchor = null);
    			info.mount = () => div0;
    			info.anchor = null;

    			insert(target, t5, anchor);
    			insert(target, div1, anchor);
    			append(div1, button);
    			ctx.button_binding(button);
    			current = true;
    		},

    		p: function update(changed, new_ctx) {
    			ctx = new_ctx;
    			if ((!current || changed.student) && t1_value !== (t1_value = ctx.student.englishName + "")) {
    				set_data(t1, t1_value);
    			}

    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);

    			info.ctx = ctx;

    			if (('semesters' in changed) && promise !== (promise = ctx.semesters) && handle_promise(promise, info)) ; else {
    				info.block.p(changed, assign(assign({}, ctx), info.resolved));
    			}

    			if (changed.loading) {
    				toggle_class(button, "is-loading", ctx.loading);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h2);
    				detach(t3);
    			}

    			destroy_component(error, detaching);

    			if (detaching) {
    				detach(t4);
    				detach(div0);
    			}

    			info.block.d();
    			info.token = null;
    			info = null;

    			if (detaching) {
    				detach(t5);
    				detach(div1);
    			}

    			ctx.button_binding(null);
    			dispose();
    		}
    	};
    }

    function instance$l($$self, $$props, $$invalidate) {
    	

      let semesters;
      let selectCurrent;
      let currentSemester;
      let nextSemester;
      let selectNext;
      let errors = '';
      let currentLoading = false;
      let nextLoading = false;
      let closeButton;
      let { open, student = {} } = $$props;

      onMount(() => {
        $$invalidate('semesters', semesters = request(CURRENT_NEXT_SEMESTER_GROUPS));
      });

      const isInGroup = (id) => {
        return !!student.groups.find(g => g.id === id)
      };

      async function joinOrChangeGroup (select, semester) {
        select === selectCurrent ? currentLoading = true : nextLoading = true; $$invalidate('currentLoading', currentLoading); $$invalidate('nextLoading', nextLoading);
        select.disabled = true;
        closeButton.disabled = true; $$invalidate('closeButton', closeButton);
        // find out if student is alrady in a group of the same semester
        const selected = select.value;
        const groupName = select.selectedOptions[0].text;
        const sameSemester = semester.groups.find(group => isInGroup(group.id));
        let text = '';
        try {
          if (selected === '' && sameSemester) {
            await students.removeStudentFromGroup(student.id, sameSemester.id);
            text = `Removed ${student.englishName} from ${sameSemester.name} class`;
          } else if (sameSemester) {
            await students.moveToDifferentGroup(student.id, sameSemester.id, selected);
            text = `Switched ${student.englishName} from ${sameSemester.name} class to ${groupName} class`;
          } else {
            await students.addStudentToGroup(student.id, selected);
            text = `Added ${student.englishName} to ${groupName} class`;
          }
          notifications.add({ text, type: 'success' });
        } catch (error) {
          $$invalidate('errors', errors = error);
          notifications.add({ text: `Unable to change ${student.englishName}'s classes`, type: 'danger' });
        } finally {
          select.disabled = false;
          closeButton.disabled = false; $$invalidate('closeButton', closeButton);
          select === selectCurrent ? currentLoading = false : nextLoading = false; $$invalidate('currentLoading', currentLoading); $$invalidate('nextLoading', nextLoading);
        }
      }

    	const writable_props = ['open', 'student'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<EditStudentGroups> was created with unknown prop '${key}'`);
    	});

    	function select_change_handler() {
    		currentSemester = select_value(this);
    		$$invalidate('currentSemester', currentSemester);
    	}

    	function select_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('selectCurrent', selectCurrent = $$value);
    		});
    	}

    	function change_handler({ result }) {
    		return joinOrChangeGroup(selectCurrent, result.currentSemester);
    	}

    	function select_change_handler_1() {
    		nextSemester = select_value(this);
    		$$invalidate('nextSemester', nextSemester);
    	}

    	function select_binding_1($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('selectNext', selectNext = $$value);
    		});
    	}

    	function change_handler_1({ result }) {
    		return joinOrChangeGroup(selectNext, result.nextSemester);
    	}

    	function button_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('closeButton', closeButton = $$value);
    		});
    	}

    	function click_handler() {
    		const $$result = open = false;
    		$$invalidate('open', open);
    		return $$result;
    	}

    	$$self.$set = $$props => {
    		if ('open' in $$props) $$invalidate('open', open = $$props.open);
    		if ('student' in $$props) $$invalidate('student', student = $$props.student);
    	};

    	let loading;

    	$$self.$$.update = ($$dirty = { currentLoading: 1, nextLoading: 1 }) => {
    		if ($$dirty.currentLoading || $$dirty.nextLoading) { $$invalidate('loading', loading = currentLoading || nextLoading); }
    	};

    	return {
    		semesters,
    		selectCurrent,
    		currentSemester,
    		nextSemester,
    		selectNext,
    		errors,
    		currentLoading,
    		nextLoading,
    		closeButton,
    		open,
    		student,
    		isInGroup,
    		joinOrChangeGroup,
    		loading,
    		select_change_handler,
    		select_binding,
    		change_handler,
    		select_change_handler_1,
    		select_binding_1,
    		change_handler_1,
    		button_binding,
    		click_handler
    	};
    }

    class EditStudentGroups extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$m, safe_not_equal, ["open", "student"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.open === undefined && !('open' in props)) {
    			console.warn("<EditStudentGroups> was created without expected prop 'open'");
    		}
    	}

    	get open() {
    		throw new Error_1$6("<EditStudentGroups>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set open(value) {
    		throw new Error_1$6("<EditStudentGroups>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get student() {
    		throw new Error_1$6("<EditStudentGroups>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set student(value) {
    		throw new Error_1$6("<EditStudentGroups>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/DL.svelte generated by Svelte v3.9.2 */

    const file$j = "admin/src/components/DL.svelte";

    function create_fragment$n(ctx) {
    	var dl, current;

    	const default_slot_template = ctx.$$slots.default;
    	const default_slot = create_slot(default_slot_template, ctx, null);

    	return {
    		c: function create() {
    			dl = element("dl");

    			if (default_slot) default_slot.c();

    			attr(dl, "class", "svelte-1usf7k9");
    			add_location(dl, file$j, 21, 0, 352);
    		},

    		l: function claim(nodes) {
    			if (default_slot) default_slot.l(dl_nodes);
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, dl, anchor);

    			if (default_slot) {
    				default_slot.m(dl, null);
    			}

    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (default_slot && default_slot.p && changed.$$scope) {
    				default_slot.p(
    					get_slot_changes(default_slot_template, ctx, changed, null),
    					get_slot_context(default_slot_template, ctx, null)
    				);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(dl);
    			}

    			if (default_slot) default_slot.d(detaching);
    		}
    	};
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let { $$slots = {}, $$scope } = $$props;

    	$$self.$set = $$props => {
    		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
    	};

    	return { $$slots, $$scope };
    }

    class DL extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$n, safe_not_equal, []);
    	}
    }

    /* admin/src/components/students/StudentListItem.svelte generated by Svelte v3.9.2 */

    const file$k = "admin/src/components/students/StudentListItem.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.group = list[i];
    	return child_ctx;
    }

    // (166:8) {#if student.birthdate}
    function create_if_block_3$1(ctx) {
    	var p, t0_value = ctx.getAge(ctx.birthdate) + "", t0, t1;

    	return {
    		c: function create() {
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = text(" yrs old");
    			add_location(p, file$k, 166, 8, 3740);
    		},

    		m: function mount(target, anchor) {
    			insert(target, p, anchor);
    			append(p, t0);
    			append(p, t1);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.birthdate) && t0_value !== (t0_value = ctx.getAge(ctx.birthdate) + "")) {
    				set_data(t0, t0_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(p);
    			}
    		}
    	};
    }

    // (172:4) {#if expanded}
    function create_if_block_2$3(ctx) {
    	var div, div_transition, current;

    	var dl = new DL({
    		props: {
    		$$slots: { default: [create_default_slot_2] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			div = element("div");
    			dl.$$.fragment.c();
    			add_location(div, file$k, 172, 4, 3912);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			mount_component(dl, div, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var dl_changes = {};
    			if (changed.$$scope || changed.student || changed.birthdate) dl_changes.$$scope = { changed, ctx };
    			dl.$set(dl_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(dl.$$.fragment, local);

    			if (local) {
    				add_render_callback(() => {
    					if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 200 }, true);
    					div_transition.run(1);
    				});
    			}

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(dl.$$.fragment, local);

    			if (local) {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 200 }, false);
    				div_transition.run(0);
    			}

    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			destroy_component(dl);

    			if (detaching) {
    				if (div_transition) div_transition.end();
    			}
    		}
    	};
    }

    // (180:12) {:else}
    function create_else_block$4(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("none");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (178:14) {#each student.groups as group}
    function create_each_block$4(ctx) {
    	var li, t0_value = ctx.group.name + "", t0, t1, t2_value = ctx.group.semester.name + "", t2;

    	return {
    		c: function create() {
    			li = element("li");
    			t0 = text(t0_value);
    			t1 = text(" - ");
    			t2 = text(t2_value);
    			attr(li, "class", "svelte-1i7iszh");
    			add_location(li, file$k, 178, 4, 4097);
    		},

    		m: function mount(target, anchor) {
    			insert(target, li, anchor);
    			append(li, t0);
    			append(li, t1);
    			append(li, t2);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.student) && t0_value !== (t0_value = ctx.group.name + "")) {
    				set_data(t0, t0_value);
    			}

    			if ((changed.student) && t2_value !== (t2_value = ctx.group.semester.name + "")) {
    				set_data(t2, t2_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(li);
    			}
    		}
    	};
    }

    // (174:6) <DL>
    function create_default_slot_2(ctx) {
    	var dt0, t1, dd0, ul, t2, dt1, dd1, t4_value = ctx.student.pinyinName + "", t4, t5, dt2, dd2, t7, t8, dt3, dd3, t10_value = ctx.student.pointsTally + "", t10;

    	var each_value = ctx.student.groups;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	var each_1_else = null;

    	if (!each_value.length) {
    		each_1_else = create_else_block$4();
    		each_1_else.c();
    	}

    	return {
    		c: function create() {
    			dt0 = element("dt");
    			dt0.textContent = "Groups:";
    			t1 = space();
    			dd0 = element("dd");
    			ul = element("ul");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			dt1 = element("dt");
    			dt1.textContent = "Pinyin:";
    			dd1 = element("dd");
    			t4 = text(t4_value);
    			t5 = space();
    			dt2 = element("dt");
    			dt2.textContent = "Birthdate:";
    			dd2 = element("dd");
    			t7 = text(ctx.birthdate);
    			t8 = space();
    			dt3 = element("dt");
    			dt3.textContent = "Total points:";
    			dd3 = element("dd");
    			t10 = text(t10_value);
    			add_location(dt0, file$k, 174, 8, 3982);
    			attr(ul, "class", "groups-list svelte-1i7iszh");
    			add_location(ul, file$k, 176, 10, 4022);
    			add_location(dd0, file$k, 175, 8, 4007);
    			add_location(dt1, file$k, 185, 8, 4239);
    			add_location(dd1, file$k, 185, 24, 4255);
    			add_location(dt2, file$k, 186, 8, 4293);
    			add_location(dd2, file$k, 186, 27, 4312);
    			add_location(dt3, file$k, 187, 10, 4343);
    			add_location(dd3, file$k, 187, 32, 4365);
    		},

    		m: function mount(target, anchor) {
    			insert(target, dt0, anchor);
    			insert(target, t1, anchor);
    			insert(target, dd0, anchor);
    			append(dd0, ul);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			if (each_1_else) {
    				each_1_else.m(ul, null);
    			}

    			insert(target, t2, anchor);
    			insert(target, dt1, anchor);
    			insert(target, dd1, anchor);
    			append(dd1, t4);
    			insert(target, t5, anchor);
    			insert(target, dt2, anchor);
    			insert(target, dd2, anchor);
    			append(dd2, t7);
    			insert(target, t8, anchor);
    			insert(target, dt3, anchor);
    			insert(target, dd3, anchor);
    			append(dd3, t10);
    		},

    		p: function update(changed, ctx) {
    			if (changed.student) {
    				each_value = ctx.student.groups;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}

    			if (each_value.length) {
    				if (each_1_else) {
    					each_1_else.d(1);
    					each_1_else = null;
    				}
    			} else if (!each_1_else) {
    				each_1_else = create_else_block$4();
    				each_1_else.c();
    				each_1_else.m(ul, null);
    			}

    			if ((changed.student) && t4_value !== (t4_value = ctx.student.pinyinName + "")) {
    				set_data(t4, t4_value);
    			}

    			if (changed.birthdate) {
    				set_data(t7, ctx.birthdate);
    			}

    			if ((changed.student) && t10_value !== (t10_value = ctx.student.pointsTally + "")) {
    				set_data(t10, t10_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(dt0);
    				detach(t1);
    				detach(dd0);
    			}

    			destroy_each(each_blocks, detaching);

    			if (each_1_else) each_1_else.d();

    			if (detaching) {
    				detach(t2);
    				detach(dt1);
    				detach(dd1);
    				detach(t5);
    				detach(dt2);
    				detach(dd2);
    				detach(t8);
    				detach(dt3);
    				detach(dd3);
    			}
    		}
    	};
    }

    // (210:2) {#if editShowing}
    function create_if_block_1$5(ctx) {
    	var updating_open, current;

    	function editstudent_open_binding(value) {
    		ctx.editstudent_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let editstudent_props = { student: ctx.student };
    	if (ctx.editShowing !== void 0) {
    		editstudent_props.open = ctx.editShowing;
    	}
    	var editstudent = new EditStudent({ props: editstudent_props, $$inline: true });

    	binding_callbacks.push(() => bind(editstudent, 'open', editstudent_open_binding));

    	return {
    		c: function create() {
    			editstudent.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(editstudent, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var editstudent_changes = {};
    			if (changed.student) editstudent_changes.student = ctx.student;
    			if (!updating_open && changed.editShowing) {
    				editstudent_changes.open = ctx.editShowing;
    			}
    			editstudent.$set(editstudent_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(editstudent.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(editstudent.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(editstudent, detaching);
    		}
    	};
    }

    // (209:0) <Modal bind:open={editShowing}>
    function create_default_slot_1$1(ctx) {
    	var if_block_anchor, current;

    	var if_block = (ctx.editShowing) && create_if_block_1$5(ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.editShowing) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block_1$5(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    // (216:2) {#if groupsShowing}
    function create_if_block$d(ctx) {
    	var updating_open, current;

    	function editstudentgroups_open_binding(value) {
    		ctx.editstudentgroups_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let editstudentgroups_props = { student: ctx.student };
    	if (ctx.groupsShowing !== void 0) {
    		editstudentgroups_props.open = ctx.groupsShowing;
    	}
    	var editstudentgroups = new EditStudentGroups({
    		props: editstudentgroups_props,
    		$$inline: true
    	});

    	binding_callbacks.push(() => bind(editstudentgroups, 'open', editstudentgroups_open_binding));

    	return {
    		c: function create() {
    			editstudentgroups.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(editstudentgroups, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var editstudentgroups_changes = {};
    			if (changed.student) editstudentgroups_changes.student = ctx.student;
    			if (!updating_open && changed.groupsShowing) {
    				editstudentgroups_changes.open = ctx.groupsShowing;
    			}
    			editstudentgroups.$set(editstudentgroups_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(editstudentgroups.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(editstudentgroups.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(editstudentgroups, detaching);
    		}
    	};
    }

    // (215:0) <Modal bind:open={groupsShowing}>
    function create_default_slot$3(ctx) {
    	var if_block_anchor, current;

    	var if_block = (ctx.groupsShowing) && create_if_block$d(ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.groupsShowing) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$d(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function create_fragment$o(ctx) {
    	var div4, div3, div2, div0, figure, img, img_src_value, img_class_value, t0, div1, p0, strong, t1_value = ctx.student.englishName + "", t1, t2, span, t3_value = ctx.student.chineseName + "", t3, t4, p1, t5, t6, t7, i, i_class_value, t8, t9, footer, button0, t11, button1, t13, button2, t15, updating_open, t16, updating_open_1, t17, updating_open_2, current, dispose;

    	var if_block0 = (ctx.student.birthdate) && create_if_block_3$1(ctx);

    	var if_block1 = (ctx.expanded) && create_if_block_2$3(ctx);

    	function deleteitem_open_binding(value) {
    		ctx.deleteitem_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let deleteitem_props = {
    		id: ctx.student.id,
    		store: students,
    		type: "student",
    		name: "" + ctx.student.englishName + " (" + ctx.student.chineseName + ")"
    	};
    	if (ctx.showDelete !== void 0) {
    		deleteitem_props.open = ctx.showDelete;
    	}
    	var deleteitem = new DeleteItem({ props: deleteitem_props, $$inline: true });

    	binding_callbacks.push(() => bind(deleteitem, 'open', deleteitem_open_binding));

    	function modal0_open_binding(value_1) {
    		ctx.modal0_open_binding.call(null, value_1);
    		updating_open_1 = true;
    		add_flush_callback(() => updating_open_1 = false);
    	}

    	let modal0_props = {
    		$$slots: { default: [create_default_slot_1$1] },
    		$$scope: { ctx }
    	};
    	if (ctx.editShowing !== void 0) {
    		modal0_props.open = ctx.editShowing;
    	}
    	var modal0 = new Modal({ props: modal0_props, $$inline: true });

    	binding_callbacks.push(() => bind(modal0, 'open', modal0_open_binding));

    	function modal1_open_binding(value_2) {
    		ctx.modal1_open_binding.call(null, value_2);
    		updating_open_2 = true;
    		add_flush_callback(() => updating_open_2 = false);
    	}

    	let modal1_props = {
    		$$slots: { default: [create_default_slot$3] },
    		$$scope: { ctx }
    	};
    	if (ctx.groupsShowing !== void 0) {
    		modal1_props.open = ctx.groupsShowing;
    	}
    	var modal1 = new Modal({ props: modal1_props, $$inline: true });

    	binding_callbacks.push(() => bind(modal1, 'open', modal1_open_binding));

    	return {
    		c: function create() {
    			div4 = element("div");
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			figure = element("figure");
    			img = element("img");
    			t0 = space();
    			div1 = element("div");
    			p0 = element("p");
    			strong = element("strong");
    			t1 = text(t1_value);
    			t2 = space();
    			span = element("span");
    			t3 = text(t3_value);
    			t4 = space();
    			p1 = element("p");
    			t5 = text(ctx.currentOrNextClass);
    			t6 = space();
    			if (if_block0) if_block0.c();
    			t7 = space();
    			i = element("i");
    			t8 = space();
    			if (if_block1) if_block1.c();
    			t9 = space();
    			footer = element("footer");
    			button0 = element("button");
    			button0.textContent = "Groups";
    			t11 = space();
    			button1 = element("button");
    			button1.textContent = "Edit";
    			t13 = space();
    			button2 = element("button");
    			button2.textContent = "Delete";
    			t15 = space();
    			deleteitem.$$.fragment.c();
    			t16 = space();
    			modal0.$$.fragment.c();
    			t17 = space();
    			modal1.$$.fragment.c();
    			attr(img, "src", img_src_value = "images/" + ctx.gender + ".jpg");
    			attr(img, "alt", "portrait");
    			attr(img, "class", img_class_value = "is-rounded portrait " + ctx.student.gender + " svelte-1i7iszh");
    			add_location(img, file$k, 159, 10, 3402);
    			attr(figure, "class", "image svelte-1i7iszh");
    			add_location(figure, file$k, 158, 8, 3369);
    			attr(div0, "class", "media-left svelte-1i7iszh");
    			add_location(div0, file$k, 157, 6, 3336);
    			add_location(strong, file$k, 163, 11, 3570);
    			attr(span, "class", "chinese svelte-1i7iszh");
    			add_location(span, file$k, 163, 50, 3609);
    			add_location(p0, file$k, 163, 8, 3567);
    			add_location(p1, file$k, 164, 8, 3672);
    			attr(div1, "class", "media-content svelte-1i7iszh");
    			add_location(div1, file$k, 162, 6, 3531);
    			attr(i, "class", i_class_value = "expand-button fas fa-angle-" + (ctx.expanded ? 'up' : 'down') + " svelte-1i7iszh");
    			add_location(i, file$k, 169, 6, 3808);
    			attr(div2, "class", "media svelte-1i7iszh");
    			add_location(div2, file$k, 156, 4, 3268);
    			attr(div3, "class", "card-content svelte-1i7iszh");
    			add_location(div3, file$k, 155, 2, 3237);
    			attr(button0, "class", "card-footer-item svelte-1i7iszh");
    			add_location(button0, file$k, 194, 4, 4480);
    			attr(button1, "class", "card-footer-item svelte-1i7iszh");
    			add_location(button1, file$k, 195, 4, 4555);
    			attr(button2, "class", "card-footer-item svelte-1i7iszh");
    			add_location(button2, file$k, 196, 4, 4626);
    			attr(footer, "class", "card-footer svelte-1i7iszh");
    			add_location(footer, file$k, 193, 2, 4447);
    			attr(div4, "class", "card svelte-1i7iszh");
    			add_location(div4, file$k, 154, 0, 3216);

    			dispose = [
    				listen(div2, "click", ctx.click_handler),
    				listen(button0, "click", ctx.showGroups),
    				listen(button1, "click", ctx.showEdit),
    				listen(button2, "click", ctx.click_handler_1)
    			];
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div4, anchor);
    			append(div4, div3);
    			append(div3, div2);
    			append(div2, div0);
    			append(div0, figure);
    			append(figure, img);
    			append(div2, t0);
    			append(div2, div1);
    			append(div1, p0);
    			append(p0, strong);
    			append(strong, t1);
    			append(p0, t2);
    			append(p0, span);
    			append(span, t3);
    			append(div1, t4);
    			append(div1, p1);
    			append(p1, t5);
    			append(div1, t6);
    			if (if_block0) if_block0.m(div1, null);
    			append(div2, t7);
    			append(div2, i);
    			append(div3, t8);
    			if (if_block1) if_block1.m(div3, null);
    			append(div4, t9);
    			append(div4, footer);
    			append(footer, button0);
    			append(footer, t11);
    			append(footer, button1);
    			append(footer, t13);
    			append(footer, button2);
    			insert(target, t15, anchor);
    			mount_component(deleteitem, target, anchor);
    			insert(target, t16, anchor);
    			mount_component(modal0, target, anchor);
    			insert(target, t17, anchor);
    			mount_component(modal1, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if ((!current || changed.gender) && img_src_value !== (img_src_value = "images/" + ctx.gender + ".jpg")) {
    				attr(img, "src", img_src_value);
    			}

    			if ((!current || changed.student) && img_class_value !== (img_class_value = "is-rounded portrait " + ctx.student.gender + " svelte-1i7iszh")) {
    				attr(img, "class", img_class_value);
    			}

    			if ((!current || changed.student) && t1_value !== (t1_value = ctx.student.englishName + "")) {
    				set_data(t1, t1_value);
    			}

    			if ((!current || changed.student) && t3_value !== (t3_value = ctx.student.chineseName + "")) {
    				set_data(t3, t3_value);
    			}

    			if (!current || changed.currentOrNextClass) {
    				set_data(t5, ctx.currentOrNextClass);
    			}

    			if (ctx.student.birthdate) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    				} else {
    					if_block0 = create_if_block_3$1(ctx);
    					if_block0.c();
    					if_block0.m(div1, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if ((!current || changed.expanded) && i_class_value !== (i_class_value = "expand-button fas fa-angle-" + (ctx.expanded ? 'up' : 'down') + " svelte-1i7iszh")) {
    				attr(i, "class", i_class_value);
    			}

    			if (ctx.expanded) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    					transition_in(if_block1, 1);
    				} else {
    					if_block1 = create_if_block_2$3(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div3, null);
    				}
    			} else if (if_block1) {
    				group_outros();
    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});
    				check_outros();
    			}

    			var deleteitem_changes = {};
    			if (changed.student) deleteitem_changes.id = ctx.student.id;
    			if (changed.students) deleteitem_changes.store = students;
    			if (changed.student) deleteitem_changes.name = "" + ctx.student.englishName + " (" + ctx.student.chineseName + ")";
    			if (!updating_open && changed.showDelete) {
    				deleteitem_changes.open = ctx.showDelete;
    			}
    			deleteitem.$set(deleteitem_changes);

    			var modal0_changes = {};
    			if (changed.$$scope || changed.editShowing || changed.student) modal0_changes.$$scope = { changed, ctx };
    			if (!updating_open_1 && changed.editShowing) {
    				modal0_changes.open = ctx.editShowing;
    			}
    			modal0.$set(modal0_changes);

    			var modal1_changes = {};
    			if (changed.$$scope || changed.groupsShowing || changed.student) modal1_changes.$$scope = { changed, ctx };
    			if (!updating_open_2 && changed.groupsShowing) {
    				modal1_changes.open = ctx.groupsShowing;
    			}
    			modal1.$set(modal1_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);

    			transition_in(deleteitem.$$.fragment, local);

    			transition_in(modal0.$$.fragment, local);

    			transition_in(modal1.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block1);
    			transition_out(deleteitem.$$.fragment, local);
    			transition_out(modal0.$$.fragment, local);
    			transition_out(modal1.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div4);
    			}

    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();

    			if (detaching) {
    				detach(t15);
    			}

    			destroy_component(deleteitem, detaching);

    			if (detaching) {
    				detach(t16);
    			}

    			destroy_component(modal0, detaching);

    			if (detaching) {
    				detach(t17);
    			}

    			destroy_component(modal1, detaching);

    			run_all(dispose);
    		}
    	};
    }

    function instance$n($$self, $$props, $$invalidate) {
    	

      let { student = {}, semesters = {} } = $$props;
      let expanded = false;
      let showDelete = false;
      let editShowing = false;
      let groupsShowing = false;

      const showEdit = () => { $$invalidate('editShowing', editShowing = true); };
      const showGroups = () => { $$invalidate('groupsShowing', groupsShowing = true); };

      const getAge = (dateString) => {
        if (dateString === 'none') return
        const today = new Date();
        const birthDate = new Date(dateString);
        let age = today.getFullYear() - birthDate.getFullYear();
        const m = today.getMonth() - birthDate.getMonth();
        if (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) {
          age--;
        }
        return age
      };

      const getCurrentOrNextClass = (groups) => {
        if (!groups) return
        if (semesters.currentSemester) {
          const currentGroup = groups.find(group => {
            return group.semester.id === semesters.currentSemester.id
          });
          if (currentGroup) return `Current ${currentGroup.name} class`
        }
        if (semesters.nextSemester) {
          const nextGroup = groups.find(group => {
            return group.semester.id === semesters.nextSemester.id
          });
          if (nextGroup) return `Next ${nextGroup.name} class`
        }
        return 'Not enrolled'
      };

    	const writable_props = ['student', 'semesters'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<StudentListItem> was created with unknown prop '${key}'`);
    	});

    	function click_handler() { expanded = !expanded; $$invalidate('expanded', expanded); }

    	function click_handler_1() { showDelete = true; $$invalidate('showDelete', showDelete); }

    	function deleteitem_open_binding(value) {
    		showDelete = value;
    		$$invalidate('showDelete', showDelete);
    	}

    	function editstudent_open_binding(value) {
    		editShowing = value;
    		$$invalidate('editShowing', editShowing);
    	}

    	function modal0_open_binding(value_1) {
    		editShowing = value_1;
    		$$invalidate('editShowing', editShowing);
    	}

    	function editstudentgroups_open_binding(value) {
    		groupsShowing = value;
    		$$invalidate('groupsShowing', groupsShowing);
    	}

    	function modal1_open_binding(value_2) {
    		groupsShowing = value_2;
    		$$invalidate('groupsShowing', groupsShowing);
    	}

    	$$self.$set = $$props => {
    		if ('student' in $$props) $$invalidate('student', student = $$props.student);
    		if ('semesters' in $$props) $$invalidate('semesters', semesters = $$props.semesters);
    	};

    	let gender, birthdate, groups, currentOrNextClass;

    	$$self.$$.update = ($$dirty = { student: 1 }) => {
    		if ($$dirty.student) { $$invalidate('gender', gender = student.gender === 'M' ? 'boy' : 'girl'); }
    		if ($$dirty.student) { $$invalidate('birthdate', birthdate = !student.birthdate ? 'none' : student.birthdate.slice(0, 10)); }
    		if ($$dirty.student) { groups = !student.groups ? 'none' : student.groups.map(g => {
            if (!g.name) return
            return `${g.name} (${g.semester.name})`
          }).join(', '); }
    		if ($$dirty.student) { $$invalidate('currentOrNextClass', currentOrNextClass = getCurrentOrNextClass(student.groups)); }
    	};

    	return {
    		student,
    		semesters,
    		expanded,
    		showDelete,
    		editShowing,
    		groupsShowing,
    		showEdit,
    		showGroups,
    		getAge,
    		gender,
    		birthdate,
    		currentOrNextClass,
    		click_handler,
    		click_handler_1,
    		deleteitem_open_binding,
    		editstudent_open_binding,
    		modal0_open_binding,
    		editstudentgroups_open_binding,
    		modal1_open_binding
    	};
    }

    class StudentListItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$o, safe_not_equal, ["student", "semesters"]);
    	}

    	get student() {
    		throw new Error("<StudentListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set student(value) {
    		throw new Error("<StudentListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get semesters() {
    		throw new Error("<StudentListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set semesters(value) {
    		throw new Error("<StudentListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/students/FilterStudents.svelte generated by Svelte v3.9.2 */

    const file$l = "admin/src/components/students/FilterStudents.svelte";

    function create_fragment$p(ctx) {
    	var div0, input, t0, span, i0, t1, div2, div1, select, option0, option1, option2, option3, option4, t7, button, i1, i1_class_value, dispose;

    	return {
    		c: function create() {
    			div0 = element("div");
    			input = element("input");
    			t0 = space();
    			span = element("span");
    			i0 = element("i");
    			t1 = space();
    			div2 = element("div");
    			div1 = element("div");
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "Sort by: ID";
    			option1 = element("option");
    			option1.textContent = "Chinese name";
    			option2 = element("option");
    			option2.textContent = "English name";
    			option3 = element("option");
    			option3.textContent = "Age";
    			option4 = element("option");
    			option4.textContent = "Gender";
    			t7 = space();
    			button = element("button");
    			i1 = element("i");
    			attr(input, "class", "input");
    			attr(input, "type", "text");
    			attr(input, "placeholder", "Search");
    			add_location(input, file$l, 28, 2, 546);
    			attr(i0, "class", "fas fa-search");
    			add_location(i0, file$l, 30, 4, 688);
    			attr(span, "class", "icon is-small is-left");
    			add_location(span, file$l, 29, 2, 647);
    			attr(div0, "class", "control search has-icons-left svelte-49z4zm");
    			add_location(div0, file$l, 27, 0, 500);
    			option0.__value = "id";
    			option0.value = option0.__value;
    			add_location(option0, file$l, 37, 6, 840);
    			option1.__value = "pinyinName";
    			option1.value = option1.__value;
    			add_location(option1, file$l, 38, 6, 886);
    			option2.__value = "englishName";
    			option2.value = option2.__value;
    			add_location(option2, file$l, 39, 6, 941);
    			option3.__value = "birthdate";
    			option3.value = option3.__value;
    			add_location(option3, file$l, 40, 6, 997);
    			option4.__value = "gender";
    			option4.value = option4.__value;
    			add_location(option4, file$l, 41, 6, 1042);
    			if (ctx.sortParam === void 0) add_render_callback(() => ctx.select_change_handler.call(select));
    			add_location(select, file$l, 36, 4, 785);
    			attr(div1, "class", "select");
    			add_location(div1, file$l, 35, 2, 760);
    			attr(i1, "class", i1_class_value = "fas fa-sort-" + (ctx.direction === -1 ? 'up' : 'down') + " svelte-49z4zm");
    			add_location(i1, file$l, 45, 52, 1157);
    			attr(button, "class", "button is-link");
    			add_location(button, file$l, 45, 2, 1107);
    			attr(div2, "class", "control svelte-49z4zm");
    			add_location(div2, file$l, 34, 0, 736);

    			dispose = [
    				listen(input, "input", ctx.input_input_handler),
    				listen(input, "input", ctx.reload),
    				listen(select, "change", ctx.select_change_handler),
    				listen(select, "change", ctx.sort),
    				listen(button, "click", ctx.reverse)
    			];
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div0, anchor);
    			append(div0, input);

    			set_input_value(input, ctx.searchString);

    			append(div0, t0);
    			append(div0, span);
    			append(span, i0);
    			insert(target, t1, anchor);
    			insert(target, div2, anchor);
    			append(div2, div1);
    			append(div1, select);
    			append(select, option0);
    			append(select, option1);
    			append(select, option2);
    			append(select, option3);
    			append(select, option4);

    			select_option(select, ctx.sortParam);

    			append(div2, t7);
    			append(div2, button);
    			append(button, i1);
    		},

    		p: function update(changed, ctx) {
    			if (changed.searchString && (input.value !== ctx.searchString)) set_input_value(input, ctx.searchString);
    			if (changed.sortParam) select_option(select, ctx.sortParam);

    			if ((changed.direction) && i1_class_value !== (i1_class_value = "fas fa-sort-" + (ctx.direction === -1 ? 'up' : 'down') + " svelte-49z4zm")) {
    				attr(i1, "class", i1_class_value);
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div0);
    				detach(t1);
    				detach(div2);
    			}

    			run_all(dispose);
    		}
    	};
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let sortParam = 'id';
      let direction = 1;
      let searchString = '';

      const reload = () => {
        const directionString = direction === 1 ? 'ASC' : 'DESC';
        students.get(`${sortParam}_${directionString}`, searchString);
      };
      const sort = () => {
        if (!sortParam) return
        students.sort(sortParam, direction);
      };
      const reverse = () => {
        $$invalidate('direction', direction = -(direction));
        sort();
      };

    	function input_input_handler() {
    		searchString = this.value;
    		$$invalidate('searchString', searchString);
    	}

    	function select_change_handler() {
    		sortParam = select_value(this);
    		$$invalidate('sortParam', sortParam);
    	}

    	return {
    		sortParam,
    		direction,
    		searchString,
    		reload,
    		sort,
    		reverse,
    		input_input_handler,
    		select_change_handler
    	};
    }

    class FilterStudents extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$p, safe_not_equal, []);
    	}
    }

    /* admin/src/components/students/AddStudent.svelte generated by Svelte v3.9.2 */

    const file$m = "admin/src/components/students/AddStudent.svelte";

    // (42:0) <Modal bind:open>
    function create_default_slot$4(ctx) {
    	var current;

    	var studentform = new StudentForm({
    		props: {
    		errors: ctx.errors,
    		loading: ctx.loading
    	},
    		$$inline: true
    	});
    	studentform.$on("reset", ctx.reset);
    	studentform.$on("submit", ctx.save);

    	return {
    		c: function create() {
    			studentform.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(studentform, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var studentform_changes = {};
    			if (changed.errors) studentform_changes.errors = ctx.errors;
    			if (changed.loading) studentform_changes.loading = ctx.loading;
    			studentform.$set(studentform_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(studentform.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(studentform.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(studentform, detaching);
    		}
    	};
    }

    function create_fragment$q(ctx) {
    	var button, i, t0, t1, updating_open, current, dispose;

    	function modal_open_binding(value) {
    		ctx.modal_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let modal_props = {
    		$$slots: { default: [create_default_slot$4] },
    		$$scope: { ctx }
    	};
    	if (ctx.open !== void 0) {
    		modal_props.open = ctx.open;
    	}
    	var modal = new Modal({ props: modal_props, $$inline: true });

    	binding_callbacks.push(() => bind(modal, 'open', modal_open_binding));

    	return {
    		c: function create() {
    			button = element("button");
    			i = element("i");
    			t0 = text(" Add Student");
    			t1 = space();
    			modal.$$.fragment.c();
    			attr(i, "class", "fas fa-plus");
    			add_location(i, file$m, 38, 2, 882);
    			attr(button, "class", "button is-primary svelte-10d3jcz");
    			add_location(button, file$m, 37, 0, 817);
    			dispose = listen(button, "click", ctx.click_handler);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);
    			append(button, i);
    			append(button, t0);
    			insert(target, t1, anchor);
    			mount_component(modal, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var modal_changes = {};
    			if (changed.$$scope || changed.errors || changed.loading) modal_changes.$$scope = { changed, ctx };
    			if (!updating_open && changed.open) {
    				modal_changes.open = ctx.open;
    			}
    			modal.$set(modal_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(button);
    				detach(t1);
    			}

    			destroy_component(modal, detaching);

    			dispose();
    		}
    	};
    }

    function instance$p($$self, $$props, $$invalidate) {
    	

      let open = false;
      let errors = null;
      let loading = false;

      const reset = () => {
        $$invalidate('errors', errors = null);
        $$invalidate('open', open = false);
      };

      const save = async ({ detail }) => {
        const { groupId, id, ...input } = detail;
        $$invalidate('loading', loading = true);
        try {
          await students.create(input, groupId);
          notifications.add({ text: `Created new student: '${detail.englishName}'`, type: 'success' });
          reset();
        } catch (error) {
          $$invalidate('errors', errors = error);
          notifications.add({ text: 'Could not save new student', 'type': 'danger' });
        } finally {
          $$invalidate('loading', loading = false);
        }
      };

    	function click_handler() {
    		const $$result = open = true;
    		$$invalidate('open', open);
    		return $$result;
    	}

    	function modal_open_binding(value) {
    		open = value;
    		$$invalidate('open', open);
    	}

    	return {
    		open,
    		errors,
    		loading,
    		reset,
    		save,
    		click_handler,
    		modal_open_binding
    	};
    }

    class AddStudent extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$q, safe_not_equal, []);
    	}
    }

    /* admin/src/components/students/StudentList.svelte generated by Svelte v3.9.2 */

    const file$n = "admin/src/components/students/StudentList.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.student = list[i];
    	return child_ctx;
    }

    // (44:2) {#if $students && $students.length && semesters}
    function create_if_block$e(ctx) {
    	var div, each_blocks = [], each_1_lookup = new Map(), current;

    	var each_value = ctx.$students;

    	const get_key = ctx => ctx.student.id;

    	for (var i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$5(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$5(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			div = element("div");

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();
    			attr(div, "class", "student-list svelte-5i8m0");
    			add_location(div, file$n, 45, 4, 940);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(div, null);

    			current = true;
    		},

    		p: function update(changed, ctx) {
    			const each_value = ctx.$students;

    			group_outros();
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$5, null, get_each_context$5);
    			check_outros();
    		},

    		i: function intro(local) {
    			if (current) return;
    			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

    			current = true;
    		},

    		o: function outro(local) {
    			for (i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d();
    		}
    	};
    }

    // (47:6) {#each $students as student (student.id)}
    function create_each_block$5(key_1, ctx) {
    	var first, current;

    	var studentlistitem = new StudentListItem({
    		props: {
    		student: ctx.student,
    		semesters: ctx.semesters
    	},
    		$$inline: true
    	});

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			first = empty();
    			studentlistitem.$$.fragment.c();
    			this.first = first;
    		},

    		m: function mount(target, anchor) {
    			insert(target, first, anchor);
    			mount_component(studentlistitem, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var studentlistitem_changes = {};
    			if (changed.$students) studentlistitem_changes.student = ctx.student;
    			if (changed.semesters) studentlistitem_changes.semesters = ctx.semesters;
    			studentlistitem.$set(studentlistitem_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(studentlistitem.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(studentlistitem.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(first);
    			}

    			destroy_component(studentlistitem, detaching);
    		}
    	};
    }

    function create_fragment$r(ctx) {
    	var p, t0, t1_value = ctx.$students && ctx.$students.length + "", t1, t2, t3, div1, div0, t4, t5, current;

    	var addstudent = new AddStudent({ $$inline: true });

    	var filterstudents = new FilterStudents({ $$inline: true });

    	var if_block = (ctx.$students && ctx.$students.length && ctx.semesters) && create_if_block$e(ctx);

    	return {
    		c: function create() {
    			p = element("p");
    			t0 = text("Showing ");
    			t1 = text(t1_value);
    			t2 = text(" students.");
    			t3 = space();
    			div1 = element("div");
    			div0 = element("div");
    			addstudent.$$.fragment.c();
    			t4 = space();
    			filterstudents.$$.fragment.c();
    			t5 = space();
    			if (if_block) if_block.c();
    			attr(p, "class", "student-number");
    			add_location(p, file$n, 35, 0, 721);
    			attr(div0, "class", "details svelte-5i8m0");
    			add_location(div0, file$n, 38, 2, 810);
    			attr(div1, "class", "svelte-5i8m0");
    			add_location(div1, file$n, 37, 0, 802);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, p, anchor);
    			append(p, t0);
    			append(p, t1);
    			append(p, t2);
    			insert(target, t3, anchor);
    			insert(target, div1, anchor);
    			append(div1, div0);
    			mount_component(addstudent, div0, null);
    			append(div0, t4);
    			mount_component(filterstudents, div0, null);
    			append(div1, t5);
    			if (if_block) if_block.m(div1, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if ((!current || changed.$students) && t1_value !== (t1_value = ctx.$students && ctx.$students.length + "")) {
    				set_data(t1, t1_value);
    			}

    			if (ctx.$students && ctx.$students.length && ctx.semesters) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$e(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(addstudent.$$.fragment, local);

    			transition_in(filterstudents.$$.fragment, local);

    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(addstudent.$$.fragment, local);
    			transition_out(filterstudents.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(p);
    				detach(t3);
    				detach(div1);
    			}

    			destroy_component(addstudent);

    			destroy_component(filterstudents);

    			if (if_block) if_block.d();
    		}
    	};
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let $students;

    	validate_store(students, 'students');
    	component_subscribe($$self, students, $$value => { $students = $$value; $$invalidate('$students', $students); });

    	

      let semesters;

      onMount(async () => {
        $$invalidate('semesters', semesters = await request(CURRENT_NEXT_SEMESTER_GROUPS));
      });

    	return { semesters, $students };
    }

    class StudentList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$r, safe_not_equal, []);
    	}
    }

    /* admin/src/components/students/Students.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$7 } = globals;

    const file$o = "admin/src/components/students/Students.svelte";

    // (31:0) {:else}
    function create_else_block$5(ctx) {
    	var current;

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			error.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(error, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(error, detaching);
    		}
    	};
    }

    // (29:18) 
    function create_if_block_1$6(ctx) {
    	var current;

    	var loading = new Loading({
    		props: { what: "students" },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			loading.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},

    		p: noop,

    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};
    }

    // (27:0) {#if $students}
    function create_if_block$f(ctx) {
    	var current;

    	var studentlist = new StudentList({ $$inline: true });

    	return {
    		c: function create() {
    			studentlist.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(studentlist, target, anchor);
    			current = true;
    		},

    		p: noop,

    		i: function intro(local) {
    			if (current) return;
    			transition_in(studentlist.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(studentlist.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(studentlist, detaching);
    		}
    	};
    }

    function create_fragment$s(ctx) {
    	var t0, h1, t2, current_block_type_index, if_block, if_block_anchor, current;

    	var if_block_creators = [
    		create_if_block$f,
    		create_if_block_1$6,
    		create_else_block$5
    	];

    	var if_blocks = [];

    	function select_block_type(changed, ctx) {
    		if (ctx.$students) return 0;
    		if (!ctx.errors) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(null, ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	return {
    		c: function create() {
    			t0 = space();
    			h1 = element("h1");
    			h1.textContent = "Students";
    			t2 = space();
    			if_block.c();
    			if_block_anchor = empty();
    			document.title = "Students";
    			attr(h1, "class", "title");
    			add_location(h1, file$o, 24, 0, 545);
    		},

    		l: function claim(nodes) {
    			throw new Error_1$7("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t0, anchor);
    			insert(target, h1, anchor);
    			insert(target, t2, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(changed, ctx);
    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(changed, ctx);
    			} else {
    				group_outros();
    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});
    				check_outros();

    				if_block = if_blocks[current_block_type_index];
    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}
    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t0);
    				detach(h1);
    				detach(t2);
    			}

    			if_blocks[current_block_type_index].d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let $students;

    	validate_store(students, 'students');
    	component_subscribe($$self, students, $$value => { $students = $$value; $$invalidate('$students', $students); });

    	

      let errors;

      onMount(async () => {
        try {
          await students.get();
        } catch (error) {
          $$invalidate('errors', errors = error);
          notifications.add({ text: "Couldn't get students from server.", type: 'danger' });
        }
      });

    	return { errors, $students };
    }

    class Students extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$r, create_fragment$s, safe_not_equal, []);
    	}
    }

    const GET_GROUPS = /* GraphQL */`
  {
    groups {
      id
      name
      semester {
        id
        name
        startDate
      }
      students {
        chineseName
        englishName
        pinyinName
        id
      }
    }
  }
`;

    const UPDATE_GROUP = /* GraphQL */`
  mutation updateGroup($id: ID!, $semesterId: ID, $name: String) {
    updateGroup(id: $id, semesterId: $semesterId, name: $name){
      id
      name
      semester {
        id
        name
        startDate
      }
      students {
        chineseName
        englishName
        pinyinName
        id
      }
    }
  }
`;

    const CREATE_GROUP = /* GraphQL */`
  mutation createGroup($semesterId: ID!, $name: String!) {
    createGroup(semesterId: $semesterId, name: $name){
      id
      name
      semester {
        id
        name
        startDate
      }
      students {
        chineseName
        englishName
        pinyinName
        id
      }
    }
  }
`;

    const DELETE_GROUP = /* GraphQL */`
mutation deleteGroup($id: ID!) {
  deleteGroup(id: $id) {
    id
    name
  }
}
`;

    const createGroupStore = () => {
      const { subscribe, set, update } = writable();

      return {
        subscribe,
        get: async () => {
          const getres = await request(GET_GROUPS);
          set(getres.groups);
        },
        create: async (name, semesterId) => {
          const response = await request(CREATE_GROUP, { name, semesterId });
          update(previous => [...previous, response.createGroup]);
        },
        patch: async (id, name, semesterId) => {
          const response = await request(UPDATE_GROUP, { id, name, semesterId });
          update(previous => previous.map((group) => {
            if (group.id !== id) return group
            return response.updateGroup
          }));
        },
        remove: async id => {
          const response = await request(DELETE_GROUP, { id });
          update(previous =>
            previous.filter(group => response.deleteGroup.id !== group.id)
          );
        }
      }
    };

    const groups = createGroupStore();

    /* admin/src/components/groups/SemesterSelect.svelte generated by Svelte v3.9.2 */

    const file$p = "admin/src/components/groups/SemesterSelect.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.semester = list[i];
    	return child_ctx;
    }

    // (30:0) {#if edit}
    function create_if_block_2$4(ctx) {
    	var p;

    	return {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Be careful! Only change if there aren't any class sessions.";
    			attr(p, "class", "help is-warning");
    			add_location(p, file$p, 30, 0, 564);
    		},

    		m: function mount(target, anchor) {
    			insert(target, p, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(p);
    			}
    		}
    	};
    }

    // (44:6) {:catch}
    function create_catch_block$1(ctx) {
    	var option;

    	return {
    		c: function create() {
    			option = element("option");
    			option.textContent = "Loading semesters ...";
    			option.__value = "Loading semesters ...";
    			option.value = option.__value;
    			add_location(option, file$p, 44, 8, 1140);
    		},

    		m: function mount(target, anchor) {
    			insert(target, option, anchor);
    		},

    		p: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(option);
    			}
    		}
    	};
    }

    // (37:6) {:then result}
    function create_then_block$1(ctx) {
    	var if_block_anchor;

    	var if_block = (ctx.result && ctx.result.length) && create_if_block_1$7(ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.result && ctx.result.length) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_1$7(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    // (38:8) {#if result && result.length}
    function create_if_block_1$7(ctx) {
    	var option, each_1_anchor;

    	var each_value = ctx.result;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			option = element("option");
    			option.textContent = "--";

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    			option.__value = "";
    			option.value = option.__value;
    			add_location(option, file$p, 38, 10, 921);
    		},

    		m: function mount(target, anchor) {
    			insert(target, option, anchor);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert(target, each_1_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (changed.$semesters || changed.value) {
    				each_value = ctx.result;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(option);
    			}

    			destroy_each(each_blocks, detaching);

    			if (detaching) {
    				detach(each_1_anchor);
    			}
    		}
    	};
    }

    // (40:10) {#each result as semester}
    function create_each_block$6(ctx) {
    	var option, t_value = ctx.semester.name + "", t, option_value_value, option_selected_value;

    	return {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = ctx.semester.id;
    			option.value = option.__value;
    			option.selected = option_selected_value = ctx.semester.id === ctx.value;
    			add_location(option, file$p, 40, 12, 999);
    		},

    		m: function mount(target, anchor) {
    			insert(target, option, anchor);
    			append(option, t);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.$semesters) && t_value !== (t_value = ctx.semester.name + "")) {
    				set_data(t, t_value);
    			}

    			if ((changed.$semesters) && option_value_value !== (option_value_value = ctx.semester.id)) {
    				option.__value = option_value_value;
    			}

    			option.value = option.__value;

    			if ((changed.$semesters || changed.value) && option_selected_value !== (option_selected_value = ctx.semester.id === ctx.value)) {
    				option.selected = option_selected_value;
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(option);
    			}
    		}
    	};
    }

    // (35:23)          <option>Loading semesters ...</option>       {:then result}
    function create_pending_block$1(ctx) {
    	var option;

    	return {
    		c: function create() {
    			option = element("option");
    			option.textContent = "Loading semesters ...";
    			option.__value = "Loading semesters ...";
    			option.value = option.__value;
    			add_location(option, file$p, 35, 8, 813);
    		},

    		m: function mount(target, anchor) {
    			insert(target, option, anchor);
    		},

    		p: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(option);
    			}
    		}
    	};
    }

    // (48:4) {#if error}
    function create_if_block$g(ctx) {
    	var p, t;

    	return {
    		c: function create() {
    			p = element("p");
    			t = text(ctx.error);
    			attr(p, "class", "help is-danger");
    			add_location(p, file$p, 48, 4, 1228);
    		},

    		m: function mount(target, anchor) {
    			insert(target, p, anchor);
    			append(p, t);
    		},

    		p: function update(changed, ctx) {
    			if (changed.error) {
    				set_data(t, ctx.error);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(p);
    			}
    		}
    	};
    }

    function create_fragment$t(ctx) {
    	var label, t1, t2, div, select, promise, t3, dispose;

    	var if_block0 = (ctx.edit) && create_if_block_2$4();

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		pending: create_pending_block$1,
    		then: create_then_block$1,
    		catch: create_catch_block$1,
    		value: 'result',
    		error: 'null'
    	};

    	handle_promise(promise = ctx.$semesters, info);

    	var if_block1 = (ctx.error) && create_if_block$g(ctx);

    	return {
    		c: function create() {
    			label = element("label");
    			label.textContent = "Semester";
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			div = element("div");
    			select = element("select");

    			info.block.c();

    			t3 = space();
    			if (if_block1) if_block1.c();
    			attr(label, "class", "label");
    			add_location(label, file$p, 28, 0, 515);
    			if (ctx.value === void 0) add_render_callback(() => ctx.select_change_handler.call(select));
    			select.required = true;
    			add_location(select, file$p, 33, 2, 684);
    			attr(div, "class", "select svelte-t5dn19");
    			add_location(div, file$p, 32, 0, 661);

    			dispose = [
    				listen(select, "change", ctx.select_change_handler),
    				listen(select, "invalid", prevent_default(ctx.checkValidity))
    			];
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, label, anchor);
    			insert(target, t1, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert(target, t2, anchor);
    			insert(target, div, anchor);
    			append(div, select);

    			info.block.m(select, info.anchor = null);
    			info.mount = () => select;
    			info.anchor = null;

    			select_option(select, ctx.value);

    			ctx.select_binding(select);
    			append(div, t3);
    			if (if_block1) if_block1.m(div, null);
    		},

    		p: function update(changed, new_ctx) {
    			ctx = new_ctx;
    			if (ctx.edit) {
    				if (!if_block0) {
    					if_block0 = create_if_block_2$4();
    					if_block0.c();
    					if_block0.m(t2.parentNode, t2);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			info.ctx = ctx;

    			if (('$semesters' in changed) && promise !== (promise = ctx.$semesters) && handle_promise(promise, info)) ; else {
    				info.block.p(changed, assign(assign({}, ctx), info.resolved));
    			}

    			if (changed.value) select_option(select, ctx.value);

    			if (ctx.error) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    				} else {
    					if_block1 = create_if_block$g(ctx);
    					if_block1.c();
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(label);
    				detach(t1);
    			}

    			if (if_block0) if_block0.d(detaching);

    			if (detaching) {
    				detach(t2);
    				detach(div);
    			}

    			info.block.d();
    			info.token = null;
    			info = null;

    			ctx.select_binding(null);
    			if (if_block1) if_block1.d();
    			run_all(dispose);
    		}
    	};
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let $semesters;

    	validate_store(semesters, 'semesters');
    	component_subscribe($$self, semesters, $$value => { $semesters = $$value; $$invalidate('$semesters', $semesters); });

    	

      let selectElement;
      let error = '';
      let { edit = false, value = '' } = $$props;

      onMount(() => {
        if (!$semesters || $semesters.length === 0) {
          semesters.get();
        }
      });

      function checkValidity () {
        $$invalidate('error', error = !selectElement.validity.valid && selectElement.validationMessage
          ? selectElement.validationMessage
          : '');
      }

    	const writable_props = ['edit', 'value'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<SemesterSelect> was created with unknown prop '${key}'`);
    	});

    	function select_change_handler() {
    		value = select_value(this);
    		$$invalidate('value', value);
    	}

    	function select_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('selectElement', selectElement = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ('edit' in $$props) $$invalidate('edit', edit = $$props.edit);
    		if ('value' in $$props) $$invalidate('value', value = $$props.value);
    	};

    	return {
    		selectElement,
    		error,
    		edit,
    		value,
    		checkValidity,
    		$semesters,
    		select_change_handler,
    		select_binding
    	};
    }

    class SemesterSelect extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$t, safe_not_equal, ["edit", "value"]);
    	}

    	get edit() {
    		throw new Error("<SemesterSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set edit(value) {
    		throw new Error("<SemesterSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<SemesterSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<SemesterSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/groups/GroupForm.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$8 } = globals;

    const file$q = "admin/src/components/groups/GroupForm.svelte";

    // (38:30) {:else}
    function create_else_block$6(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Add");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (38:18) {#if id}
    function create_if_block_1$8(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Edit");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (41:4) {#if errors}
    function create_if_block$h(ctx) {
    	var current;

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			error.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(error, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(error, detaching);
    		}
    	};
    }

    function create_fragment$u(ctx) {
    	var h2, t0, t1, form_1, t2, updating_value, t3, updating_value_1, t4, div, button, t6, input1, current, dispose;

    	function select_block_type(changed, ctx) {
    		if (ctx.id) return create_if_block_1$8;
    		return create_else_block$6;
    	}

    	var current_block_type = select_block_type(null, ctx);
    	var if_block0 = current_block_type(ctx);

    	var if_block1 = (ctx.errors) && create_if_block$h(ctx);

    	function input0_value_binding(value) {
    		ctx.input0_value_binding.call(null, value);
    		updating_value = true;
    		add_flush_callback(() => updating_value = false);
    	}

    	let input0_props = { label: "Name" };
    	if (ctx.name !== void 0) {
    		input0_props.value = ctx.name;
    	}
    	var input0 = new Input({ props: input0_props, $$inline: true });

    	binding_callbacks.push(() => bind(input0, 'value', input0_value_binding));

    	function semesterselect_value_binding(value_1) {
    		ctx.semesterselect_value_binding.call(null, value_1);
    		updating_value_1 = true;
    		add_flush_callback(() => updating_value_1 = false);
    	}

    	let semesterselect_props = { edit: !!ctx.id };
    	if (ctx.semesterId !== void 0) {
    		semesterselect_props.value = ctx.semesterId;
    	}
    	var semesterselect = new SemesterSelect({
    		props: semesterselect_props,
    		$$inline: true
    	});

    	binding_callbacks.push(() => bind(semesterselect, 'value', semesterselect_value_binding));

    	return {
    		c: function create() {
    			h2 = element("h2");
    			if_block0.c();
    			t0 = text(" a group");
    			t1 = space();
    			form_1 = element("form");
    			if (if_block1) if_block1.c();
    			t2 = space();
    			input0.$$.fragment.c();
    			t3 = space();
    			semesterselect.$$.fragment.c();
    			t4 = space();
    			div = element("div");
    			button = element("button");
    			button.textContent = "Save group";
    			t6 = space();
    			input1 = element("input");
    			attr(h2, "class", "title");
    			add_location(h2, file$q, 37, 0, 783);
    			attr(button, "type", "submit");
    			attr(button, "class", "button is-primary");
    			toggle_class(button, "is-loading", ctx.loading);
    			add_location(button, file$q, 49, 6, 1115);
    			attr(input1, "type", "reset");
    			attr(input1, "class", "button");
    			input1.value = "Cancel";
    			add_location(input1, file$q, 50, 6, 1239);
    			attr(div, "class", "buttons svelte-i7r75e");
    			add_location(div, file$q, 48, 4, 1087);
    			form_1.noValidate = true;
    			add_location(form_1, file$q, 39, 0, 843);

    			dispose = [
    				listen(form_1, "submit", prevent_default(ctx.handleSubmit)),
    				listen(form_1, "reset", ctx.reset_handler)
    			];
    		},

    		l: function claim(nodes) {
    			throw new Error_1$8("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, h2, anchor);
    			if_block0.m(h2, null);
    			append(h2, t0);
    			insert(target, t1, anchor);
    			insert(target, form_1, anchor);
    			if (if_block1) if_block1.m(form_1, null);
    			append(form_1, t2);
    			mount_component(input0, form_1, null);
    			append(form_1, t3);
    			mount_component(semesterselect, form_1, null);
    			append(form_1, t4);
    			append(form_1, div);
    			append(div, button);
    			ctx.button_binding(button);
    			append(div, t6);
    			append(div, input1);
    			ctx.form_1_binding(form_1);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type !== (current_block_type = select_block_type(changed, ctx))) {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);
    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(h2, t0);
    				}
    			}

    			if (ctx.errors) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    					transition_in(if_block1, 1);
    				} else {
    					if_block1 = create_if_block$h(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(form_1, t2);
    				}
    			} else if (if_block1) {
    				group_outros();
    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});
    				check_outros();
    			}

    			var input0_changes = {};
    			if (!updating_value && changed.name) {
    				input0_changes.value = ctx.name;
    			}
    			input0.$set(input0_changes);

    			var semesterselect_changes = {};
    			if (changed.id) semesterselect_changes.edit = !!ctx.id;
    			if (!updating_value_1 && changed.semesterId) {
    				semesterselect_changes.value = ctx.semesterId;
    			}
    			semesterselect.$set(semesterselect_changes);

    			if (changed.loading) {
    				toggle_class(button, "is-loading", ctx.loading);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);

    			transition_in(input0.$$.fragment, local);

    			transition_in(semesterselect.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block1);
    			transition_out(input0.$$.fragment, local);
    			transition_out(semesterselect.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h2);
    			}

    			if_block0.d();

    			if (detaching) {
    				detach(t1);
    				detach(form_1);
    			}

    			if (if_block1) if_block1.d();

    			destroy_component(input0);

    			destroy_component(semesterselect);

    			ctx.button_binding(null);
    			ctx.form_1_binding(null);
    			run_all(dispose);
    		}
    	};
    }

    function instance$t($$self, $$props, $$invalidate) {
    	

      const dispatch = createEventDispatcher();

      let form;
      let saveButton;
      let { errors = '', loading = false, name = '', semesterId = null, id = null } = $$props;

      const handleSubmit = () => {
        const isValid = form.checkValidity();
        if (!isValid) {
          notifications.add({
            text: 'Please fix form errors first.',
            type: 'danger'
          });
          return
        }
        dispatch('submit', { id, name, semesterId });
      };

    	const writable_props = ['errors', 'loading', 'name', 'semesterId', 'id'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<GroupForm> was created with unknown prop '${key}'`);
    	});

    	function reset_handler(event) {
    		bubble($$self, event);
    	}

    	function input0_value_binding(value) {
    		name = value;
    		$$invalidate('name', name);
    	}

    	function semesterselect_value_binding(value_1) {
    		semesterId = value_1;
    		$$invalidate('semesterId', semesterId);
    	}

    	function button_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('saveButton', saveButton = $$value);
    		});
    	}

    	function form_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('form', form = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ('errors' in $$props) $$invalidate('errors', errors = $$props.errors);
    		if ('loading' in $$props) $$invalidate('loading', loading = $$props.loading);
    		if ('name' in $$props) $$invalidate('name', name = $$props.name);
    		if ('semesterId' in $$props) $$invalidate('semesterId', semesterId = $$props.semesterId);
    		if ('id' in $$props) $$invalidate('id', id = $$props.id);
    	};

    	return {
    		form,
    		saveButton,
    		errors,
    		loading,
    		name,
    		semesterId,
    		id,
    		handleSubmit,
    		reset_handler,
    		input0_value_binding,
    		semesterselect_value_binding,
    		button_binding,
    		form_1_binding
    	};
    }

    class GroupForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$t, create_fragment$u, safe_not_equal, ["errors", "loading", "name", "semesterId", "id"]);
    	}

    	get errors() {
    		throw new Error_1$8("<GroupForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set errors(value) {
    		throw new Error_1$8("<GroupForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loading() {
    		throw new Error_1$8("<GroupForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loading(value) {
    		throw new Error_1$8("<GroupForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error_1$8("<GroupForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error_1$8("<GroupForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get semesterId() {
    		throw new Error_1$8("<GroupForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set semesterId(value) {
    		throw new Error_1$8("<GroupForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error_1$8("<GroupForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error_1$8("<GroupForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/groups/EditGroup.svelte generated by Svelte v3.9.2 */

    function create_fragment$v(ctx) {
    	var current;

    	var groupform = new GroupForm({
    		props: {
    		id: ctx.group.id,
    		loading: ctx.loading,
    		errors: ctx.errors,
    		name: ctx.group.name,
    		semesterId: ctx.group.semester.id
    	},
    		$$inline: true
    	});
    	groupform.$on("reset", ctx.reset);
    	groupform.$on("submit", ctx.save);

    	return {
    		c: function create() {
    			groupform.$$.fragment.c();
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			mount_component(groupform, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var groupform_changes = {};
    			if (changed.group) groupform_changes.id = ctx.group.id;
    			if (changed.loading) groupform_changes.loading = ctx.loading;
    			if (changed.errors) groupform_changes.errors = ctx.errors;
    			if (changed.group) groupform_changes.name = ctx.group.name;
    			if (changed.group) groupform_changes.semesterId = ctx.group.semester.id;
    			groupform.$set(groupform_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(groupform.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(groupform.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(groupform, detaching);
    		}
    	};
    }

    function instance$u($$self, $$props, $$invalidate) {
    	

      let { open = false, group } = $$props;
      let errors = '';
      let loading = false;

      const reset = () => {
        $$invalidate('errors', errors = '');
        $$invalidate('open', open = false);
      };

      const save = async ({ detail }) => {
        const { id, semesterId, name } = detail;
        $$invalidate('loading', loading = true);
        try {
          await groups.patch(id, name, semesterId);
          notifications.add({ text: `Saved changes to '${name}' class`, type: 'success' });
          reset();
        } catch (error) {
          $$invalidate('errors', errors = error);
          notifications.add({ text: 'Could not save changes to group', type: 'danger' });
        } finally {
          $$invalidate('loading', loading = false);
        }
      };

    	const writable_props = ['open', 'group'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<EditGroup> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('open' in $$props) $$invalidate('open', open = $$props.open);
    		if ('group' in $$props) $$invalidate('group', group = $$props.group);
    	};

    	return {
    		open,
    		group,
    		errors,
    		loading,
    		reset,
    		save
    	};
    }

    class EditGroup extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$u, create_fragment$v, safe_not_equal, ["open", "group"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.group === undefined && !('group' in props)) {
    			console.warn("<EditGroup> was created without expected prop 'group'");
    		}
    	}

    	get open() {
    		throw new Error("<EditGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set open(value) {
    		throw new Error("<EditGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get group() {
    		throw new Error("<EditGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set group(value) {
    		throw new Error("<EditGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/groups/GroupsListItem.svelte generated by Svelte v3.9.2 */

    const file$r = "admin/src/components/groups/GroupsListItem.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.student = list[i];
    	return child_ctx;
    }

    // (53:4) {#if group.students && group.students.length}
    function create_if_block_1$9(ctx) {
    	var p, strong, t0_value = ctx.group.students.length + "", t0, t1, t2, ul;

    	var each_value = ctx.group.students;

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	return {
    		c: function create() {
    			p = element("p");
    			strong = element("strong");
    			t0 = text(t0_value);
    			t1 = text(" students");
    			t2 = space();
    			ul = element("ul");

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}
    			add_location(strong, file$r, 53, 7, 1155);
    			add_location(p, file$r, 53, 4, 1152);
    			attr(ul, "class", "student-list");
    			add_location(ul, file$r, 54, 8, 1217);
    		},

    		m: function mount(target, anchor) {
    			insert(target, p, anchor);
    			append(p, strong);
    			append(strong, t0);
    			append(strong, t1);
    			insert(target, t2, anchor);
    			insert(target, ul, anchor);

    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}
    		},

    		p: function update(changed, ctx) {
    			if ((changed.group) && t0_value !== (t0_value = ctx.group.students.length + "")) {
    				set_data(t0, t0_value);
    			}

    			if (changed.group) {
    				each_value = ctx.group.students;

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}
    				each_blocks.length = each_value.length;
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(p);
    				detach(t2);
    				detach(ul);
    			}

    			destroy_each(each_blocks, detaching);
    		}
    	};
    }

    // (56:8) {#each group.students as student}
    function create_each_block$7(ctx) {
    	var li, t0_value = ctx.student.chineseName + "", t0, t1, t2_value = ctx.student.englishName + "", t2;

    	return {
    		c: function create() {
    			li = element("li");
    			t0 = text(t0_value);
    			t1 = space();
    			t2 = text(t2_value);
    			add_location(li, file$r, 56, 10, 1295);
    		},

    		m: function mount(target, anchor) {
    			insert(target, li, anchor);
    			append(li, t0);
    			append(li, t1);
    			append(li, t2);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.group) && t0_value !== (t0_value = ctx.student.chineseName + "")) {
    				set_data(t0, t0_value);
    			}

    			if ((changed.group) && t2_value !== (t2_value = ctx.student.englishName + "")) {
    				set_data(t2, t2_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(li);
    			}
    		}
    	};
    }

    // (70:2) {#if editShowing}
    function create_if_block$i(ctx) {
    	var updating_open, current;

    	function editgroup_open_binding(value) {
    		ctx.editgroup_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let editgroup_props = { group: ctx.group };
    	if (ctx.editShowing !== void 0) {
    		editgroup_props.open = ctx.editShowing;
    	}
    	var editgroup = new EditGroup({ props: editgroup_props, $$inline: true });

    	binding_callbacks.push(() => bind(editgroup, 'open', editgroup_open_binding));

    	return {
    		c: function create() {
    			editgroup.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(editgroup, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var editgroup_changes = {};
    			if (changed.group) editgroup_changes.group = ctx.group;
    			if (!updating_open && changed.editShowing) {
    				editgroup_changes.open = ctx.editShowing;
    			}
    			editgroup.$set(editgroup_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(editgroup.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(editgroup.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(editgroup, detaching);
    		}
    	};
    }

    // (69:0) <Modal bind:open={editShowing}>
    function create_default_slot$5(ctx) {
    	var if_block_anchor, current;

    	var if_block = (ctx.editShowing) && create_if_block$i(ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.editShowing) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$i(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function create_fragment$w(ctx) {
    	var li, div, h3, t0_value = ctx.group.name + "", t0, t1, t2, h4, t3_value = ctx.group.semester.name + "", t3, t4, t5, footer, button0, t7, button1, li_intro, li_outro, t9, updating_open, t10, updating_open_1, current, dispose;

    	var if_block = (ctx.group.students && ctx.group.students.length) && create_if_block_1$9(ctx);

    	function modal_open_binding(value) {
    		ctx.modal_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let modal_props = {
    		$$slots: { default: [create_default_slot$5] },
    		$$scope: { ctx }
    	};
    	if (ctx.editShowing !== void 0) {
    		modal_props.open = ctx.editShowing;
    	}
    	var modal = new Modal({ props: modal_props, $$inline: true });

    	binding_callbacks.push(() => bind(modal, 'open', modal_open_binding));

    	function deleteitem_open_binding(value_1) {
    		ctx.deleteitem_open_binding.call(null, value_1);
    		updating_open_1 = true;
    		add_flush_callback(() => updating_open_1 = false);
    	}

    	let deleteitem_props = {
    		id: ctx.group.id,
    		store: groups,
    		type: "group",
    		name: "" + ctx.group.name + " class"
    	};
    	if (ctx.showDelete !== void 0) {
    		deleteitem_props.open = ctx.showDelete;
    	}
    	var deleteitem = new DeleteItem({ props: deleteitem_props, $$inline: true });

    	binding_callbacks.push(() => bind(deleteitem, 'open', deleteitem_open_binding));

    	return {
    		c: function create() {
    			li = element("li");
    			div = element("div");
    			h3 = element("h3");
    			t0 = text(t0_value);
    			t1 = text(" class");
    			t2 = space();
    			h4 = element("h4");
    			t3 = text(t3_value);
    			t4 = space();
    			if (if_block) if_block.c();
    			t5 = space();
    			footer = element("footer");
    			button0 = element("button");
    			button0.textContent = "Edit";
    			t7 = space();
    			button1 = element("button");
    			button1.textContent = "Delete";
    			t9 = space();
    			modal.$$.fragment.c();
    			t10 = space();
    			deleteitem.$$.fragment.c();
    			attr(h3, "class", "title is-4");
    			add_location(h3, file$r, 50, 4, 994);
    			attr(h4, "class", "subtitle is-6");
    			add_location(h4, file$r, 51, 4, 1045);
    			attr(div, "class", "card-content svelte-3tpm8l");
    			add_location(div, file$r, 49, 2, 963);
    			attr(button0, "class", "card-footer-item svelte-3tpm8l");
    			add_location(button0, file$r, 63, 4, 1437);
    			attr(button1, "class", "card-footer-item svelte-3tpm8l");
    			add_location(button1, file$r, 64, 4, 1528);
    			attr(footer, "class", "card-footer svelte-3tpm8l");
    			add_location(footer, file$r, 62, 2, 1404);
    			attr(li, "class", "card svelte-3tpm8l");
    			add_location(li, file$r, 48, 0, 897);

    			dispose = [
    				listen(button0, "click", ctx.click_handler),
    				listen(button1, "click", ctx.click_handler_1)
    			];
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, li, anchor);
    			append(li, div);
    			append(div, h3);
    			append(h3, t0);
    			append(h3, t1);
    			append(div, t2);
    			append(div, h4);
    			append(h4, t3);
    			append(div, t4);
    			if (if_block) if_block.m(div, null);
    			append(li, t5);
    			append(li, footer);
    			append(footer, button0);
    			append(footer, t7);
    			append(footer, button1);
    			insert(target, t9, anchor);
    			mount_component(modal, target, anchor);
    			insert(target, t10, anchor);
    			mount_component(deleteitem, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if ((!current || changed.group) && t0_value !== (t0_value = ctx.group.name + "")) {
    				set_data(t0, t0_value);
    			}

    			if ((!current || changed.group) && t3_value !== (t3_value = ctx.group.semester.name + "")) {
    				set_data(t3, t3_value);
    			}

    			if (ctx.group.students && ctx.group.students.length) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_1$9(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			var modal_changes = {};
    			if (changed.$$scope || changed.editShowing || changed.group) modal_changes.$$scope = { changed, ctx };
    			if (!updating_open && changed.editShowing) {
    				modal_changes.open = ctx.editShowing;
    			}
    			modal.$set(modal_changes);

    			var deleteitem_changes = {};
    			if (changed.group) deleteitem_changes.id = ctx.group.id;
    			if (changed.groups) deleteitem_changes.store = groups;
    			if (changed.group) deleteitem_changes.name = "" + ctx.group.name + " class";
    			if (!updating_open_1 && changed.showDelete) {
    				deleteitem_changes.open = ctx.showDelete;
    			}
    			deleteitem.$set(deleteitem_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			add_render_callback(() => {
    				if (li_outro) li_outro.end(1);
    				if (!li_intro) li_intro = create_in_transition(li, fly, { x: 400 });
    				li_intro.start();
    			});

    			transition_in(modal.$$.fragment, local);

    			transition_in(deleteitem.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			if (li_intro) li_intro.invalidate();

    			li_outro = create_out_transition(li, fly, { x: -400 });

    			transition_out(modal.$$.fragment, local);
    			transition_out(deleteitem.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(li);
    			}

    			if (if_block) if_block.d();

    			if (detaching) {
    				if (li_outro) li_outro.end();
    				detach(t9);
    			}

    			destroy_component(modal, detaching);

    			if (detaching) {
    				detach(t10);
    			}

    			destroy_component(deleteitem, detaching);

    			run_all(dispose);
    		}
    	};
    }

    function instance$v($$self, $$props, $$invalidate) {
    	

      let { group } = $$props;
      let editShowing = false;
      let showDelete = false;

    	const writable_props = ['group'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<GroupsListItem> was created with unknown prop '${key}'`);
    	});

    	function click_handler() { editShowing = true; $$invalidate('editShowing', editShowing); }

    	function click_handler_1() { showDelete = true; $$invalidate('showDelete', showDelete); }

    	function editgroup_open_binding(value) {
    		editShowing = value;
    		$$invalidate('editShowing', editShowing);
    	}

    	function modal_open_binding(value) {
    		editShowing = value;
    		$$invalidate('editShowing', editShowing);
    	}

    	function deleteitem_open_binding(value_1) {
    		showDelete = value_1;
    		$$invalidate('showDelete', showDelete);
    	}

    	$$self.$set = $$props => {
    		if ('group' in $$props) $$invalidate('group', group = $$props.group);
    	};

    	return {
    		group,
    		editShowing,
    		showDelete,
    		click_handler,
    		click_handler_1,
    		editgroup_open_binding,
    		modal_open_binding,
    		deleteitem_open_binding
    	};
    }

    class GroupsListItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$v, create_fragment$w, safe_not_equal, ["group"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.group === undefined && !('group' in props)) {
    			console.warn("<GroupsListItem> was created without expected prop 'group'");
    		}
    	}

    	get group() {
    		throw new Error("<GroupsListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set group(value) {
    		throw new Error("<GroupsListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/groups/AddGroup.svelte generated by Svelte v3.9.2 */

    const file$s = "admin/src/components/groups/AddGroup.svelte";

    // (36:0) <Modal bind:open>
    function create_default_slot$6(ctx) {
    	var current;

    	var groupform = new GroupForm({
    		props: {
    		errors: ctx.errors,
    		loading: ctx.loading
    	},
    		$$inline: true
    	});
    	groupform.$on("reset", ctx.reset);
    	groupform.$on("submit", ctx.save);

    	return {
    		c: function create() {
    			groupform.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(groupform, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var groupform_changes = {};
    			if (changed.errors) groupform_changes.errors = ctx.errors;
    			if (changed.loading) groupform_changes.loading = ctx.loading;
    			groupform.$set(groupform_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(groupform.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(groupform.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(groupform, detaching);
    		}
    	};
    }

    function create_fragment$x(ctx) {
    	var button, i, t0, t1, updating_open, current, dispose;

    	function modal_open_binding(value) {
    		ctx.modal_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let modal_props = {
    		$$slots: { default: [create_default_slot$6] },
    		$$scope: { ctx }
    	};
    	if (ctx.open !== void 0) {
    		modal_props.open = ctx.open;
    	}
    	var modal = new Modal({ props: modal_props, $$inline: true });

    	binding_callbacks.push(() => bind(modal, 'open', modal_open_binding));

    	return {
    		c: function create() {
    			button = element("button");
    			i = element("i");
    			t0 = text(" Add a group");
    			t1 = space();
    			modal.$$.fragment.c();
    			attr(i, "class", "fas fa-plus");
    			add_location(i, file$s, 32, 2, 805);
    			attr(button, "class", "button is-primary");
    			add_location(button, file$s, 31, 0, 739);
    			dispose = listen(button, "click", ctx.click_handler);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);
    			append(button, i);
    			append(button, t0);
    			insert(target, t1, anchor);
    			mount_component(modal, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var modal_changes = {};
    			if (changed.$$scope || changed.errors || changed.loading) modal_changes.$$scope = { changed, ctx };
    			if (!updating_open && changed.open) {
    				modal_changes.open = ctx.open;
    			}
    			modal.$set(modal_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(button);
    				detach(t1);
    			}

    			destroy_component(modal, detaching);

    			dispose();
    		}
    	};
    }

    function instance$w($$self, $$props, $$invalidate) {
    	

      let errors = '';
      let loading = false;
      let open = false;

      const reset = () => {
        $$invalidate('errors', errors = '');
        $$invalidate('open', open = false);
      };

      const save = async ({ detail }) => {
        const { semesterId, name } = detail;
        $$invalidate('loading', loading = true);
        try {
          await groups.create(name, semesterId);
          notifications.add({ text: `Added new class '${name} class'`, type: 'success' });
          reset();
        } catch (error) {
          $$invalidate('errors', errors = error);
          notifications.add({ text: 'Could not save changes to group', type: 'danger' });
        } finally {
          $$invalidate('loading', loading = false);
        }
      };

    	function click_handler() {
    		const $$result = open = true;
    		$$invalidate('open', open);
    		return $$result;
    	}

    	function modal_open_binding(value) {
    		open = value;
    		$$invalidate('open', open);
    	}

    	return {
    		errors,
    		loading,
    		open,
    		reset,
    		save,
    		click_handler,
    		modal_open_binding
    	};
    }

    class AddGroup extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$w, create_fragment$x, safe_not_equal, []);
    	}
    }

    /* admin/src/components/groups/GroupsList.svelte generated by Svelte v3.9.2 */

    const file$t = "admin/src/components/groups/GroupsList.svelte";

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.group = list[i];
    	return child_ctx;
    }

    // (39:0) {#if $groups && $groups.length}
    function create_if_block$j(ctx) {
    	var ul, each_blocks = [], each_1_lookup = new Map(), current;

    	var each_value = ctx.sortedGroups;

    	const get_key = ctx => ctx.group.id;

    	for (var i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$8(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$8(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			ul = element("ul");

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();
    			attr(ul, "class", "group-list svelte-v4hmp");
    			add_location(ul, file$t, 39, 0, 972);
    		},

    		m: function mount(target, anchor) {
    			insert(target, ul, anchor);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(ul, null);

    			current = true;
    		},

    		p: function update(changed, ctx) {
    			const each_value = ctx.sortedGroups;

    			group_outros();
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$8, null, get_each_context$8);
    			check_outros();
    		},

    		i: function intro(local) {
    			if (current) return;
    			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

    			current = true;
    		},

    		o: function outro(local) {
    			for (i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(ul);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d();
    		}
    	};
    }

    // (41:2) {#each sortedGroups as group (group.id)}
    function create_each_block$8(key_1, ctx) {
    	var first, current;

    	var groupslistitem = new GroupsListItem({
    		props: { group: ctx.group },
    		$$inline: true
    	});

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			first = empty();
    			groupslistitem.$$.fragment.c();
    			this.first = first;
    		},

    		m: function mount(target, anchor) {
    			insert(target, first, anchor);
    			mount_component(groupslistitem, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var groupslistitem_changes = {};
    			if (changed.sortedGroups) groupslistitem_changes.group = ctx.group;
    			groupslistitem.$set(groupslistitem_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(groupslistitem.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(groupslistitem.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(first);
    			}

    			destroy_component(groupslistitem, detaching);
    		}
    	};
    }

    function create_fragment$y(ctx) {
    	var updating_value, t0, p, t1, t2_value = ctx.$groups && ctx.$groups.length + "", t2, t3, t4, div, t5, if_block_anchor, current;

    	function semesterselect_value_binding(value) {
    		ctx.semesterselect_value_binding.call(null, value);
    		updating_value = true;
    		add_flush_callback(() => updating_value = false);
    	}

    	let semesterselect_props = {};
    	if (ctx.semesterId !== void 0) {
    		semesterselect_props.value = ctx.semesterId;
    	}
    	var semesterselect = new SemesterSelect({
    		props: semesterselect_props,
    		$$inline: true
    	});

    	binding_callbacks.push(() => bind(semesterselect, 'value', semesterselect_value_binding));

    	var addgroup = new AddGroup({ $$inline: true });

    	var if_block = (ctx.$groups && ctx.$groups.length) && create_if_block$j(ctx);

    	return {
    		c: function create() {
    			semesterselect.$$.fragment.c();
    			t0 = space();
    			p = element("p");
    			t1 = text("Showing ");
    			t2 = text(t2_value);
    			t3 = text(" groups sorted by semester.");
    			t4 = space();
    			div = element("div");
    			addgroup.$$.fragment.c();
    			t5 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr(p, "class", "groups-count svelte-v4hmp");
    			add_location(p, file$t, 32, 0, 803);
    			attr(div, "class", "details");
    			add_location(div, file$t, 34, 0, 895);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			mount_component(semesterselect, target, anchor);
    			insert(target, t0, anchor);
    			insert(target, p, anchor);
    			append(p, t1);
    			append(p, t2);
    			append(p, t3);
    			insert(target, t4, anchor);
    			insert(target, div, anchor);
    			mount_component(addgroup, div, null);
    			insert(target, t5, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var semesterselect_changes = {};
    			if (!updating_value && changed.semesterId) {
    				semesterselect_changes.value = ctx.semesterId;
    			}
    			semesterselect.$set(semesterselect_changes);

    			if ((!current || changed.$groups) && t2_value !== (t2_value = ctx.$groups && ctx.$groups.length + "")) {
    				set_data(t2, t2_value);
    			}

    			if (ctx.$groups && ctx.$groups.length) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$j(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(semesterselect.$$.fragment, local);

    			transition_in(addgroup.$$.fragment, local);

    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(semesterselect.$$.fragment, local);
    			transition_out(addgroup.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(semesterselect, detaching);

    			if (detaching) {
    				detach(t0);
    				detach(p);
    				detach(t4);
    				detach(div);
    			}

    			destroy_component(addgroup);

    			if (detaching) {
    				detach(t5);
    			}

    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let $groups;

    	validate_store(groups, 'groups');
    	component_subscribe($$self, groups, $$value => { $groups = $$value; $$invalidate('$groups', $groups); });

    	

      let semesterId = '';

    	function semesterselect_value_binding(value) {
    		semesterId = value;
    		$$invalidate('semesterId', semesterId);
    	}

    	let filteredGroups, sortedGroups;

    	$$self.$$.update = ($$dirty = { semesterId: 1, $groups: 1, filteredGroups: 1 }) => {
    		if ($$dirty.semesterId || $$dirty.$groups) { $$invalidate('filteredGroups', filteredGroups = !semesterId ? $groups : $groups.filter(group => group.semester.id === semesterId)); }
    		if ($$dirty.filteredGroups) { $$invalidate('sortedGroups', sortedGroups = filteredGroups.slice().sort((a, b) => {
            if (a.semester.startDate > b.semester.startDate) return -1
            if (a.semester.startDate < b.semester.startDate) return 1
            if (a.name < b.name) return -1
            if (a.name > b.name) return 1
          })); }
    	};

    	return {
    		semesterId,
    		$groups,
    		sortedGroups,
    		semesterselect_value_binding
    	};
    }

    class GroupsList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$x, create_fragment$y, safe_not_equal, []);
    	}
    }

    /* admin/src/components/groups/Groups.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$9 } = globals;

    const file$u = "admin/src/components/groups/Groups.svelte";

    // (25:0) {:else}
    function create_else_block$7(ctx) {
    	var current;

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			error.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(error, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(error, detaching);
    		}
    	};
    }

    // (23:18) 
    function create_if_block_1$a(ctx) {
    	var current;

    	var loading = new Loading({
    		props: { what: "groups" },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			loading.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},

    		p: noop,

    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};
    }

    // (21:0) {#if $groups}
    function create_if_block$k(ctx) {
    	var current;

    	var groupslist = new GroupsList({ $$inline: true });

    	return {
    		c: function create() {
    			groupslist.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(groupslist, target, anchor);
    			current = true;
    		},

    		p: noop,

    		i: function intro(local) {
    			if (current) return;
    			transition_in(groupslist.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(groupslist.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(groupslist, detaching);
    		}
    	};
    }

    function create_fragment$z(ctx) {
    	var t0, h1, t2, current_block_type_index, if_block, if_block_anchor, current;

    	var if_block_creators = [
    		create_if_block$k,
    		create_if_block_1$a,
    		create_else_block$7
    	];

    	var if_blocks = [];

    	function select_block_type(changed, ctx) {
    		if (ctx.$groups) return 0;
    		if (!ctx.errors) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(null, ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	return {
    		c: function create() {
    			t0 = space();
    			h1 = element("h1");
    			h1.textContent = "Groups";
    			t2 = space();
    			if_block.c();
    			if_block_anchor = empty();
    			document.title = "Groups";
    			attr(h1, "class", "title");
    			add_location(h1, file$u, 18, 0, 325);
    		},

    		l: function claim(nodes) {
    			throw new Error_1$9("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t0, anchor);
    			insert(target, h1, anchor);
    			insert(target, t2, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(changed, ctx);
    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(changed, ctx);
    			} else {
    				group_outros();
    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});
    				check_outros();

    				if_block = if_blocks[current_block_type_index];
    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}
    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t0);
    				detach(h1);
    				detach(t2);
    			}

    			if_blocks[current_block_type_index].d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function instance$y($$self, $$props, $$invalidate) {
    	let $groups;

    	validate_store(groups, 'groups');
    	component_subscribe($$self, groups, $$value => { $groups = $$value; $$invalidate('$groups', $groups); });

    	

      let errors;

      onMount(() => {
        groups.get();
      });

    	return { errors, $groups };
    }

    class Groups extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$y, create_fragment$z, safe_not_equal, []);
    	}
    }

    const GET_SESSIONS = /* GraphQL */`
 query getSessions($where: ClassSessionWhereInput){
  classSessions (where: $where) {
    id
    startsAt
    endsAt
    stage
    number
    group {
      id
      name
    }
    lesson {
      id
    }
  }
}`;

    const GET_TODAYS_SESSIONS = /* GraphQL */`
query todaysSessions($now: DateTime, $latest: DateTime){
  classSessions(where: {
    startsAt_lt: $latest,
    endsAt_gt: $now
  }) {
    id
    startsAt
    endsAt
    stage
    number
    group {
      id
      name
    }
  }
}`;

    const SESSIONS_SUB = /* GraphQL */`
subscription {
  classSessions {
    mutation
    updatedFields
    previousValues{
      id
      stage
      startsAt
      endsAt
    }
      node {
        id
        stage
        startsAt
        endsAt
        number
        group {
          id
          name
        }
      }
  }
}`;

    const CREATE_SESSION = /* GraphQL */`
mutation newClassSession($input: ClassSessionCreateInput!) {
  createClassSession(input: $input) {
    id
    stage
    startsAt
    endsAt
    group {
      name
      id
    }
  }
}
`;

    const DELETE_SESSION = /* GraphQL */`
mutation deleteClassSession($id: ID!) {
  deleteClassSession(id: $id) {
    id
    stage
    startsAt
    endsAt
  }
}
`;

    const UPDATE_SESSION = /* GraphQL */`
mutation updateClassSession($id: ID!, $lessonId: ID, $groupId: ID, $input: ClassSessionUpdateInput) {
  updateClassSession(id: $id, input: $input, groupId: $groupId, lessonId: $lessonId) {
    id
    stage
    startsAt
    endsAt
    group {
      name
      id
    }
  }
}`;

    /**
     * Expose `Backoff`.
     */

    var backo2 = Backoff;

    /**
     * Initialize backoff timer with `opts`.
     *
     * - `min` initial timeout in milliseconds [100]
     * - `max` max timeout [10000]
     * - `jitter` [0]
     * - `factor` [2]
     *
     * @param {Object} opts
     * @api public
     */

    function Backoff(opts) {
      opts = opts || {};
      this.ms = opts.min || 100;
      this.max = opts.max || 10000;
      this.factor = opts.factor || 2;
      this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
      this.attempts = 0;
    }

    /**
     * Return the backoff duration.
     *
     * @return {Number}
     * @api public
     */

    Backoff.prototype.duration = function(){
      var ms = this.ms * Math.pow(this.factor, this.attempts++);
      if (this.jitter) {
        var rand =  Math.random();
        var deviation = Math.floor(rand * this.jitter * ms);
        ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
      }
      return Math.min(ms, this.max) | 0;
    };

    /**
     * Reset the number of attempts.
     *
     * @api public
     */

    Backoff.prototype.reset = function(){
      this.attempts = 0;
    };

    /**
     * Set the minimum duration
     *
     * @api public
     */

    Backoff.prototype.setMin = function(min){
      this.ms = min;
    };

    /**
     * Set the maximum duration
     *
     * @api public
     */

    Backoff.prototype.setMax = function(max){
      this.max = max;
    };

    /**
     * Set the jitter
     *
     * @api public
     */

    Backoff.prototype.setJitter = function(jitter){
      this.jitter = jitter;
    };

    var eventemitter3 = createCommonjsModule(function (module) {

    var has = Object.prototype.hasOwnProperty
      , prefix = '~';

    /**
     * Constructor to create a storage for our `EE` objects.
     * An `Events` instance is a plain object whose properties are event names.
     *
     * @constructor
     * @private
     */
    function Events() {}

    //
    // We try to not inherit from `Object.prototype`. In some engines creating an
    // instance in this way is faster than calling `Object.create(null)` directly.
    // If `Object.create(null)` is not supported we prefix the event names with a
    // character to make sure that the built-in object properties are not
    // overridden or used as an attack vector.
    //
    if (Object.create) {
      Events.prototype = Object.create(null);

      //
      // This hack is needed because the `__proto__` property is still inherited in
      // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
      //
      if (!new Events().__proto__) prefix = false;
    }

    /**
     * Representation of a single event listener.
     *
     * @param {Function} fn The listener function.
     * @param {*} context The context to invoke the listener with.
     * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
     * @constructor
     * @private
     */
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }

    /**
     * Add a listener for a given event.
     *
     * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn The listener function.
     * @param {*} context The context to invoke the listener with.
     * @param {Boolean} once Specify if the listener is a one-time listener.
     * @returns {EventEmitter}
     * @private
     */
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== 'function') {
        throw new TypeError('The listener must be a function');
      }

      var listener = new EE(fn, context || emitter, once)
        , evt = prefix ? prefix + event : event;

      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];

      return emitter;
    }

    /**
     * Clear event by name.
     *
     * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
     * @param {(String|Symbol)} evt The Event name.
     * @private
     */
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }

    /**
     * Minimal `EventEmitter` interface that is molded against the Node.js
     * `EventEmitter` interface.
     *
     * @constructor
     * @public
     */
    function EventEmitter() {
      this._events = new Events();
      this._eventsCount = 0;
    }

    /**
     * Return an array listing the events for which the emitter has registered
     * listeners.
     *
     * @returns {Array}
     * @public
     */
    EventEmitter.prototype.eventNames = function eventNames() {
      var names = []
        , events
        , name;

      if (this._eventsCount === 0) return names;

      for (name in (events = this._events)) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }

      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }

      return names;
    };

    /**
     * Return the listeners registered for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @returns {Array} The registered listeners.
     * @public
     */
    EventEmitter.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event
        , handlers = this._events[evt];

      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];

      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }

      return ee;
    };

    /**
     * Return the number of listeners listening to a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @returns {Number} The number of listeners.
     * @public
     */
    EventEmitter.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event
        , listeners = this._events[evt];

      if (!listeners) return 0;
      if (listeners.fn) return 1;
      return listeners.length;
    };

    /**
     * Calls each of the listeners registered for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @returns {Boolean} `true` if the event had listeners, else `false`.
     * @public
     */
    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;

      if (!this._events[evt]) return false;

      var listeners = this._events[evt]
        , len = arguments.length
        , args
        , i;

      if (listeners.fn) {
        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);

        switch (len) {
          case 1: return listeners.fn.call(listeners.context), true;
          case 2: return listeners.fn.call(listeners.context, a1), true;
          case 3: return listeners.fn.call(listeners.context, a1, a2), true;
          case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }

        for (i = 1, args = new Array(len -1); i < len; i++) {
          args[i - 1] = arguments[i];
        }

        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length
          , j;

        for (i = 0; i < length; i++) {
          if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);

          switch (len) {
            case 1: listeners[i].fn.call(listeners[i].context); break;
            case 2: listeners[i].fn.call(listeners[i].context, a1); break;
            case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
            case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;
            default:
              if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
                args[j - 1] = arguments[j];
              }

              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }

      return true;
    };

    /**
     * Add a listener for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn The listener function.
     * @param {*} [context=this] The context to invoke the listener with.
     * @returns {EventEmitter} `this`.
     * @public
     */
    EventEmitter.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };

    /**
     * Add a one-time listener for a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn The listener function.
     * @param {*} [context=this] The context to invoke the listener with.
     * @returns {EventEmitter} `this`.
     * @public
     */
    EventEmitter.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };

    /**
     * Remove the listeners of a given event.
     *
     * @param {(String|Symbol)} event The event name.
     * @param {Function} fn Only remove the listeners that match this function.
     * @param {*} context Only remove the listeners that have this context.
     * @param {Boolean} once Only remove one-time listeners.
     * @returns {EventEmitter} `this`.
     * @public
     */
    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;

      if (!this._events[evt]) return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }

      var listeners = this._events[evt];

      if (listeners.fn) {
        if (
          listeners.fn === fn &&
          (!once || listeners.once) &&
          (!context || listeners.context === context)
        ) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (
            listeners[i].fn !== fn ||
            (once && !listeners[i].once) ||
            (context && listeners[i].context !== context)
          ) {
            events.push(listeners[i]);
          }
        }

        //
        // Reset the array, or remove it completely if we have no more listeners.
        //
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }

      return this;
    };

    /**
     * Remove all listeners, or those of the specified event.
     *
     * @param {(String|Symbol)} [event] The event name.
     * @returns {EventEmitter} `this`.
     * @public
     */
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;

      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }

      return this;
    };

    //
    // Alias methods names because people roll like that.
    //
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.addListener = EventEmitter.prototype.on;

    //
    // Expose the prefix.
    //
    EventEmitter.prefixed = prefix;

    //
    // Allow `EventEmitter` to be imported as module namespace.
    //
    EventEmitter.EventEmitter = EventEmitter;

    //
    // Expose the module.
    //
    {
      module.exports = EventEmitter;
    }
    });

    function symbolObservablePonyfill(root) {
    	var result;
    	var Symbol = root.Symbol;

    	if (typeof Symbol === 'function') {
    		if (Symbol.observable) {
    			result = Symbol.observable;
    		} else {
    			result = Symbol('observable');
    			Symbol.observable = result;
    		}
    	} else {
    		result = '@@observable';
    	}

    	return result;
    }

    /* global window */

    var root;

    if (typeof self !== 'undefined') {
      root = self;
    } else if (typeof window !== 'undefined') {
      root = window;
    } else if (typeof global !== 'undefined') {
      root = global;
    } else if (typeof module !== 'undefined') {
      root = module;
    } else {
      root = Function('return this')();
    }

    var result = symbolObservablePonyfill(root);

    const WS_TIMEOUT = 30000;

    function isString(value) {
      return typeof value === 'string'
    }
    function isObject(value) {
      return value !== null && typeof value === 'object'
    }

    class SubscriptionClient {
      constructor(url, options) {
        const {
          connectionCallback = undefined,
          connectionParams = {},
          timeout = WS_TIMEOUT,
          reconnect = false,
          reconnectionAttempts = Infinity,
          lazy = false,
          inactivityTimeout = 0
        } = options || {};

        this.wsImpl = WebSocket;
        this.connectionCallback = connectionCallback;
        this.url = url;
        this.operations = {};
        this.nextOperationId = 0;
        this.wsTimeout = timeout;
        this.unsentMessagesQueue = [];
        this.reconnect = reconnect;
        this.reconnecting = false;
        this.reconnectionAttempts = reconnectionAttempts;
        this.lazy = !!lazy;
        this.inactivityTimeout = inactivityTimeout;
        this.closedByUser = false;
        this.backoff = new backo2({ jitter: 0.5 });
        this.eventEmitter = new eventemitter3();
        this.client = null;
        this.maxConnectTimeGenerator = this.createMaxConnectTimeGenerator();
        this.connectionParams = this.getConnectionParams(connectionParams);

        if (!this.lazy) {
          this.connect();
        }
      }

      get status() {
        if (this.client === null) {
          return this.wsImpl.CLOSED
        }

        return this.client.readyState
      }

      close(isForced = true, closedByUser = true) {
        this.clearInactivityTimeout();
        if (this.client !== null) {
          this.closedByUser = closedByUser;

          if (isForced) {
            this.clearCheckConnectionInterval();
            this.clearMaxConnectTimeout();
            this.clearTryReconnectTimeout();
            this.unsubscribeAll();
            this.sendMessage(undefined, 'connection_terminate', null);
          }

          this.client.close();
          this.client = null;
          this.eventEmitter.emit('disconnected');

          if (!isForced) {
            this.tryReconnect();
          }
        }
      }

      request(request) {
        const getObserver = this.getObserver.bind(this);
        const executeOperation = this.executeOperation.bind(this);
        const unsubscribe = this.unsubscribe.bind(this);

        let opId;

        this.clearInactivityTimeout();

        return {
          [result]() {
            return this
          },
          subscribe(observerOrNext, onError, onComplete) {
            const observer = getObserver(observerOrNext, onError, onComplete);
            opId = executeOperation(request, (error, result) => {
              if (error === null && result === null) {
                if (observer.complete) {
                  observer.complete();
                }
              } else if (error) {
                if (observer.error) {
                  observer.error(error[0]);
                }
              } else {
                if (observer.next) {
                  observer.next(result);
                }
              }
            });

            return {
              unsubscribe: () => {
                if (opId) {
                  unsubscribe(opId);
                  opId = null;
                }
              }
            }
          }
        }
      }

      on(eventName, callback, context) {
        const handler = this.eventEmitter.on(eventName, callback, context);
        return () => {
          handler.off(eventName, callback, context);
        }
      }

      onConnected(callback, context) {
        return this.on('connected', callback, context)
      }

      onConnecting(callback, context) {
        return this.on('connecting', callback, context)
      }

      onDisconnected(callback, context) {
        return this.on('disconnected', callback, context)
      }

      onReconnected(callback, context) {
        return this.on('reconnected', callback, context)
      }

      onReconnecting(callback, context) {
        return this.on('reconnecting', callback, context)
      }

      onError(callback, context) {
        return this.on('error', callback, context)
      }

      unsubscribeAll() {
        Object.keys(this.operations).forEach(subId => {
          this.unsubscribe(subId);
        });
      }

      getConnectionParams(connectionParams) {
        return () =>
          new Promise((resolve, reject) => {
            if (typeof connectionParams === 'function') {
              try {
                return resolve(connectionParams(null))
              } catch (error) {
                return reject(error)
              }
            }

            resolve(connectionParams);
          })
      }

      executeOperation(options, handler) {
        if (this.client === null) {
          this.connect();
        }

        const opId = this.generateOperationId();
        this.operations[opId] = { options: options, handler };

        try {
          this.checkOperationOptions(options, handler);
          if (this.operations[opId]) {
            this.operations[opId] = { options, handler };
            this.sendMessage(opId, 'start', options);
          }
        } catch (error) {
          this.unsubscribe(opId);
          handler(this.formatErrors(error));
        }

        return opId
      }

      getObserver(observerOrNext, error, complete) {
        if (typeof observerOrNext === 'function') {
          return {
            next: v => observerOrNext(v),
            error: e => error && error(e),
            complete: () => complete && complete()
          }
        }
        return observerOrNext
      }

      createMaxConnectTimeGenerator() {
        const minValue = 1000;
        const maxValue = this.wsTimeout;
        return new backo2({
          min: minValue,
          max: maxValue,
          factor: 1.2
        })
      }

      clearCheckConnectionInterval() {
        if (this.checkConnectionIntervalId) {
          clearInterval(this.checkConnectionIntervalId);
          this.checkConnectionIntervalId = null;
        }
      }

      clearMaxConnectTimeout() {
        if (this.maxConnectTimeoutId) {
          clearTimeout(this.maxConnectTimeoutId);
          this.maxConnectTimeoutId = null;
        }
      }

      clearTryReconnectTimeout() {
        if (this.tryReconnectTimeoutId) {
          clearTimeout(this.tryReconnectTimeoutId);
          this.tryReconnectTimeoutId = null;
        }
      }

      clearInactivityTimeout() {
        if (this.inactivityTimeoutId) {
          clearTimeout(this.inactivityTimeoutId);
          this.inactivityTimeoutId = null;
        }
      }

      setInactivityTimeout() {
        if (
          this.inactivityTimeout > 0 &&
          Object.keys(this.operations).length === 0
        ) {
          this.inactivityTimeoutId = setTimeout(() => {
            if (Object.keys(this.operations).length === 0) {
              this.close();
            }
          }, this.inactivityTimeout);
        }
      }

      checkOperationOptions(options, handler) {
        const { query, variables, operationName } = options;
        if (!query) {
          throw new Error('Must provide a query.')
        }
        if (!handler) {
          throw new Error('Must provide an handler.')
        }
        if (
          !isString(query) ||
          (operationName && !isString(operationName)) ||
          (variables && !isObject(variables))
        ) {
          throw new Error(
            'Incorrect option types. query must be a string,' +
            '`operationName` must be a string, and `variables` must be an object.'
          )
        }
      }

      buildMessage(id, type, payload) {
        const payloadToReturn =
          payload && payload.query
            ? Object.assign({}, payload, {
              query: payload.query
            })
            : payload;
        return {
          id,
          type,
          payload: payloadToReturn
        }
      }

      formatErrors(errors) {
        if (Array.isArray(errors)) {
          return errors
        }
        if (errors && errors.errors) {
          return this.formatErrors(errors.errors)
        }
        if (errors && errors.message) {
          return [errors]
        }
        return [
          {
            name: 'FormatedError',
            message: 'Unknown error',
            originalError: errors
          }
        ]
      }

      sendMessage(id, type, payload) {
        this.sendMessageRaw(this.buildMessage(id, type, payload));
      }

      // send message, or queue it if connection is not open
      sendMessageRaw(message) {
        switch (this.status) {
          case this.wsImpl.OPEN:
            const serializedMessage = JSON.stringify(message);
            try {
              JSON.parse(serializedMessage);
            } catch (error) {
              this.eventEmitter.emit(
                'error',
                new Error(`Message must be JSON-serializable. Got: ${message}`)
              );
            }
            this.client.send(serializedMessage);
            break
          case this.wsImpl.CONNECTING:
            this.unsentMessagesQueue.push(message);
            break
          default:
            if (!this.reconnecting) {
              this.eventEmitter.emit(
                'error',
                new Error(
                  'A message was not sent because socket is not connected, is closing or ' +
                  'is already closed. Message was: ' +
                  JSON.stringify(message)
                )
              );
            }
        }
      }

      generateOperationId() {
        return String(++this.nextOperationId)
      }

      tryReconnect() {
        if (!this.reconnect || this.backoff.attempts >= this.reconnectionAttempts) {
          return
        }

        if (!this.reconnecting) {
          Object.keys(this.operations).forEach(key => {
            this.unsentMessagesQueue.push(
              this.buildMessage(key, 'start', this.operations[key].options)
            );
          });
          this.reconnecting = true;
        }

        this.clearTryReconnectTimeout();

        const delay = this.backoff.duration();
        this.tryReconnectTimeoutId = setTimeout(() => {
          this.connect();
        }, delay);
      }

      flushUnsentMessagesQueue() {
        this.unsentMessagesQueue.forEach(message => {
          this.sendMessageRaw(message);
        });
        this.unsentMessagesQueue = [];
      }

      checkConnection() {
        if (this.wasKeepAliveReceived) {
          this.wasKeepAliveReceived = false;
          return
        }

        if (!this.reconnecting) {
          this.close(false, true);
        }
      }

      checkMaxConnectTimeout() {
        this.clearMaxConnectTimeout();

        // Max timeout trying to connect
        this.maxConnectTimeoutId = setTimeout(() => {
          if (this.status !== this.wsImpl.OPEN) {
            this.reconnecting = true;
            this.close(false, true);
          }
        }, this.maxConnectTimeGenerator.duration());
      }

      connect() {
        this.client = new WebSocket(this.url, 'graphql-ws');

        this.checkMaxConnectTimeout();

        this.client.addEventListener('open', async () => {
          if (this.status === this.wsImpl.OPEN) {
            this.clearMaxConnectTimeout();
            this.closedByUser = false;
            this.eventEmitter.emit(
              this.reconnecting ? 'reconnecting' : 'connecting'
            );

            try {
              const connectionParams = await this.connectionParams();

              // Send connection_init message, no need to wait for connection to success (reduce roundtrips)
              this.sendMessage(undefined, 'connection_init', connectionParams);
              this.flushUnsentMessagesQueue();
            } catch (error) {
              this.sendMessage(undefined, 'connection_error', error);
              this.flushUnsentMessagesQueue();
            }
          }
        });

        this.client.onclose = () => {
          if (!this.closedByUser) {
            this.close(false, false);
          }
        };

        this.client.addEventListener('error', error => {
          // Capture and ignore errors to prevent unhandled exceptions, wait for
          // onclose to fire before attempting a reconnect.
          this.eventEmitter.emit('error', error);
        });

        this.client.addEventListener('message', ({ data }) => {
          this.processReceivedData(data);
        });
      }

      processReceivedData(receivedData) {
        let parsedMessage;
        let opId;

        try {
          parsedMessage = JSON.parse(receivedData);
          opId = parsedMessage.id;
        } catch (error) {
          throw new Error(`Message must be JSON-parseable. Got: ${receivedData}`)
        }

        if (
          ['data', 'complete', 'error'].includes(parsedMessage.type) &&
          !this.operations[opId]
        ) {
          this.unsubscribe(opId);

          return
        }

        switch (parsedMessage.type) {
          case 'connection_error':
            if (this.connectionCallback) {
              this.connectionCallback(parsedMessage.payload);
            }
            break

          case 'connection_ack':
            this.eventEmitter.emit(this.reconnecting ? 'reconnected' : 'connected');
            this.reconnecting = false;
            this.backoff.reset();
            this.maxConnectTimeGenerator.reset();

            if (this.connectionCallback) {
              this.connectionCallback();
            }
            break

          case 'complete':
            this.operations[opId].handler(null, null);
            delete this.operations[opId];
            break

          case 'error':
            this.operations[opId].handler(
              this.formatErrors(parsedMessage.payload),
              null
            );
            delete this.operations[opId];
            break

          case 'data':
            const parsedPayload = !parsedMessage.payload.errors
              ? parsedMessage.payload
              : {
                ...parsedMessage.payload,
                errors: this.formatErrors(parsedMessage.payload.errors)
              };
            this.operations[opId].handler(null, parsedPayload);
            break

          case 'ka':
            const firstKA = typeof this.wasKeepAliveReceived === 'undefined';
            this.wasKeepAliveReceived = true;

            if (firstKA) {
              this.checkConnection();
            }

            if (this.checkConnectionIntervalId) {
              clearInterval(this.checkConnectionIntervalId);
              this.checkConnection();
            }
            this.checkConnectionIntervalId = setInterval(
              this.checkConnection.bind(this),
              this.wsTimeout
            );
            break

          default:
            throw new Error('Invalid message type!')
        }
      }

      unsubscribe(opId) {
        if (this.operations[opId]) {
          delete this.operations[opId];
          this.setInactivityTimeout();
          this.sendMessage(opId, 'stop', undefined);
        }
      }
    }

    // const host = "development" === 'production'
    //   ? process.env.PROD_SUBSCRIPTION_ENDPOINT
    //   : process.env.DEV_SUBSCRIPTION_ENDPOINT

    const ws = new SubscriptionClient("ws://192.168.1.9:4000/subscriptions", {
      reconnect: true,
      lazy: true,
      connectionCallback: error => {
        error && console.error(error);
      }
    });

    const semester = writable();

    const createSessionsStore = () => {
      const { subscribe, set, update } = writable();
      return {
        subscribe,
        update,
        get: async () => {
          const where = (get_store_value(sessionsFilter));
          const response = await request(GET_SESSIONS, { where });
          set(response.classSessions);
        },
        create: async (startsAt, endsAt, groupId, lessonId) => {
          const input = { startsAt, endsAt };
          if (groupId) input.group = { connect: { id: groupId } };
          if (lessonId) input.lesson = { connect: { id: lessonId } };
          const response = await request(CREATE_SESSION, { input });
          sessions.get();
          return response.createClassSession
        },
        remove: async (id) => {
          const response = await request(DELETE_SESSION, { id });
          sessions.get();
          return response.deleteClassSession
        },
        patch: async (id, input, groupId, lessonId) => {
          const response = await request(UPDATE_SESSION, { id, input, groupId, lessonId });
          sessions.get();
          return response.updateClassSession
        }
      }
    };

    const sessionsFilter = writable();

    const sessions = createSessionsStore();

    const sortSessions = (sessions) => {
      if (!sessions) return
      const time = new Date();
      const in30Min = new Date(time.getTime() + 30 * 6e+4).toISOString();
      const in24hrs = new Date(time.getTime() + 24 * 3.6e+6).toISOString();
      const now = sessions.find(session => {
        return session.startsAt < time.toISOString() && session.endsAt > time.toISOString()
      });
      const soon = sessions.filter(session => {
        return session.startsAt > time.toISOString() && session.startsAt < in30Min
      });
      const later = sessions.filter(session => {
        return session.startsAt > in30Min && session.startsAt < in24hrs
      });
      return { now, soon, later }
    };

    const fetchTodaysSessions = async () => {
      const now = new Date();
      const latest = new Date(now.getTime() + 24 * 3.6e+6);
      const response = await request(GET_TODAYS_SESSIONS, { now, latest });
      return response.classSessions
    };

    // get the initial sessions list from today
    // then resort that list every 15 seconds
    // listen to a subscription on all sessions
    // the new or the old value was within 24 hours, refetch.
    // also automatically refetch if data is stale

    const todaysSessions = readable(null, set => {
      // get the initial data
      const updatedAt = new Date();
      let sessions = [];
      fetchTodaysSessions().then(result => {
        sessions = result;
        set({ ...sortSessions(result), updatedAt });
      });
      const subscription = ws.request({ query: SESSIONS_SUB }).subscribe({
        next (message) {
          if (message.data && message.data.classSessions) {
            fetchTodaysSessions().then(result => {
              sessions = result;
              set({ ...sortSessions(result), updatedAt: new Date() });
            });
          }
        }
      });
      const interval = setInterval(() => {
        // refetch data periodically
        const now = new Date();
        const expiry = new Date(now - 3.6e+6);
        if (updatedAt < expiry) {
          fetchTodaysSessions().then(result => {
            sessions = result;
            const updatedAt = new Date();
            set({ ...sortSessions(sessions), updatedAt });
          });
        } else {
          set({ ...sortSessions(sessions), updatedAt });
        }
      }, 15000);

      return () => {
        subscription && subscription.unsubscribe();
        clearInterval(interval);
      }
    });

    const time = readable(new Date(), set => {
      const interval = setInterval(() => {
        set(new Date());
      }, 1000);

      return () => clearInterval(interval)
    });

    /**
     * @name toDate
     * @category Common Helpers
     * @summary Convert the given argument to an instance of Date.
     *
     * @description
     * Convert the given argument to an instance of Date.
     *
     * If the argument is an instance of Date, the function returns its clone.
     *
     * If the argument is a number, it is treated as a timestamp.
     *
     * If the argument is none of the above, the function returns Invalid Date.
     *
     * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
     *
     * @param {Date|Number} argument - the value to convert
     * @returns {Date} the parsed date in the local time zone
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // Clone the date:
     * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
     * //=> Tue Feb 11 2014 11:30:30
     *
     * @example
     * // Convert the timestamp to date:
     * const result = toDate(1392098430000)
     * //=> Tue Feb 11 2014 11:30:30
     */
    function toDate(argument) {
      if (arguments.length < 1) {
        throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
      }

      var argStr = Object.prototype.toString.call(argument); // Clone the date

      if (argument instanceof Date || typeof argument === 'object' && argStr === '[object Date]') {
        // Prevent the date to lose the milliseconds when passed to new Date() in IE10
        return new Date(argument.getTime());
      } else if (typeof argument === 'number' || argStr === '[object Number]') {
        return new Date(argument);
      } else {
        if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
          // eslint-disable-next-line no-console
          console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as arguments. Please use `parseISO` to parse strings. See: https://git.io/fjule"); // eslint-disable-next-line no-console

          console.warn(new Error().stack);
        }

        return new Date(NaN);
      }
    }

    function toInteger(dirtyNumber) {
      if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
        return NaN;
      }

      var number = Number(dirtyNumber);

      if (isNaN(number)) {
        return number;
      }

      return number < 0 ? Math.ceil(number) : Math.floor(number);
    }

    /**
     * @name addMilliseconds
     * @category Millisecond Helpers
     * @summary Add the specified number of milliseconds to the given date.
     *
     * @description
     * Add the specified number of milliseconds to the given date.
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of milliseconds to be added
     * @returns {Date} the new date with the milliseconds added
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
     * var result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
     * //=> Thu Jul 10 2014 12:45:30.750
     */

    function addMilliseconds(dirtyDate, dirtyAmount) {
      if (arguments.length < 2) {
        throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
      }

      var timestamp = toDate(dirtyDate).getTime();
      var amount = toInteger(dirtyAmount);
      return new Date(timestamp + amount);
    }

    var MILLISECONDS_IN_MINUTE = 60000;
    /**
     * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
     * They usually appear for dates that denote time before the timezones were introduced
     * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
     * and GMT+01:00:00 after that date)
     *
     * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
     * which would lead to incorrect calculations.
     *
     * This function returns the timezone offset in milliseconds that takes seconds in account.
     */

    function getTimezoneOffsetInMilliseconds(dirtyDate) {
      var date = new Date(dirtyDate.getTime());
      var baseTimezoneOffset = date.getTimezoneOffset();
      date.setSeconds(0, 0);
      var millisecondsPartOfTimezoneOffset = date.getTime() % MILLISECONDS_IN_MINUTE;
      return baseTimezoneOffset * MILLISECONDS_IN_MINUTE + millisecondsPartOfTimezoneOffset;
    }

    /**
     * @name startOfDay
     * @category Day Helpers
     * @summary Return the start of a day for the given date.
     *
     * @description
     * Return the start of a day for the given date.
     * The result will be in the local timezone.
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * @param {Date|Number} date - the original date
     * @returns {Date} the start of a day
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // The start of a day for 2 September 2014 11:55:00:
     * var result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
     * //=> Tue Sep 02 2014 00:00:00
     */

    function startOfDay(dirtyDate) {
      if (arguments.length < 1) {
        throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
      }

      var date = toDate(dirtyDate);
      date.setHours(0, 0, 0, 0);
      return date;
    }

    var MILLISECONDS_IN_DAY = 86400000;
    /**
     * @name differenceInCalendarDays
     * @category Day Helpers
     * @summary Get the number of calendar days between the given dates.
     *
     * @description
     * Get the number of calendar days between the given dates. This means that the times are removed
     * from the dates and then the difference in days is calculated.
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * @param {Date|Number} dateLeft - the later date
     * @param {Date|Number} dateRight - the earlier date
     * @returns {Number} the number of calendar days
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // How many calendar days are between
     * // 2 July 2011 23:00:00 and 2 July 2012 00:00:00?
     * var result = differenceInCalendarDays(
     *   new Date(2012, 6, 2, 0, 0),
     *   new Date(2011, 6, 2, 23, 0)
     * )
     * //=> 366
     * // How many calendar days are between
     * // 2 July 2011 23:59:00 and 3 July 2011 00:01:00?
     * var result = differenceInCalendarDays(
     *   new Date(2011, 6, 3, 0, 1),
     *   new Date(2011, 6, 2, 23, 59)
     * )
     * //=> 1
     */

    function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
      if (arguments.length < 2) {
        throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
      }

      var startOfDayLeft = startOfDay(dirtyDateLeft);
      var startOfDayRight = startOfDay(dirtyDateRight);
      var timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft);
      var timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds(startOfDayRight); // Round the number of days to the nearest integer
      // because the number of milliseconds in a day is not constant
      // (e.g. it's different in the day of the daylight saving time clock shift)

      return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY);
    }

    /**
     * @name compareAsc
     * @category Common Helpers
     * @summary Compare the two dates and return -1, 0 or 1.
     *
     * @description
     * Compare the two dates and return 1 if the first date is after the second,
     * -1 if the first date is before the second or 0 if dates are equal.
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * @param {Date|Number} dateLeft - the first date to compare
     * @param {Date|Number} dateRight - the second date to compare
     * @returns {Number} the result of the comparison
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Compare 11 February 1987 and 10 July 1989:
     * var result = compareAsc(new Date(1987, 1, 11), new Date(1989, 6, 10))
     * //=> -1
     *
     * @example
     * // Sort the array of dates:
     * var result = [
     *   new Date(1995, 6, 2),
     *   new Date(1987, 1, 11),
     *   new Date(1989, 6, 10)
     * ].sort(compareAsc)
     * //=> [
     * //   Wed Feb 11 1987 00:00:00,
     * //   Mon Jul 10 1989 00:00:00,
     * //   Sun Jul 02 1995 00:00:00
     * // ]
     */

    function compareAsc(dirtyDateLeft, dirtyDateRight) {
      if (arguments.length < 2) {
        throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
      }

      var dateLeft = toDate(dirtyDateLeft);
      var dateRight = toDate(dirtyDateRight);
      var diff = dateLeft.getTime() - dateRight.getTime();

      if (diff < 0) {
        return -1;
      } else if (diff > 0) {
        return 1; // Return 0 if diff is 0; return NaN if diff is NaN
      } else {
        return diff;
      }
    }

    /**
     * @name isValid
     * @category Common Helpers
     * @summary Is the given date valid?
     *
     * @description
     * Returns false if argument is Invalid Date and true otherwise.
     * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
     * Invalid Date is a Date, whose time value is NaN.
     *
     * Time value of Date: http://es5.github.io/#x15.9.1.1
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * - Now `isValid` doesn't throw an exception
     *   if the first argument is not an instance of Date.
     *   Instead, argument is converted beforehand using `toDate`.
     *
     *   Examples:
     *
     *   | `isValid` argument        | Before v2.0.0 | v2.0.0 onward |
     *   |---------------------------|---------------|---------------|
     *   | `new Date()`              | `true`        | `true`        |
     *   | `new Date('2016-01-01')`  | `true`        | `true`        |
     *   | `new Date('')`            | `false`       | `false`       |
     *   | `new Date(1488370835081)` | `true`        | `true`        |
     *   | `new Date(NaN)`           | `false`       | `false`       |
     *   | `'2016-01-01'`            | `TypeError`   | `true`        |
     *   | `''`                      | `TypeError`   | `false`       |
     *   | `1488370835081`           | `TypeError`   | `true`        |
     *   | `NaN`                     | `TypeError`   | `false`       |
     *
     *   We introduce this change to make *date-fns* consistent with ECMAScript behavior
     *   that try to coerce arguments to the expected type
     *   (which is also the case with other *date-fns* functions).
     *
     * @param {*} date - the date to check
     * @returns {Boolean} the date is valid
     * @throws {TypeError} 1 argument required
     *
     * @example
     * // For the valid date:
     * var result = isValid(new Date(2014, 1, 31))
     * //=> true
     *
     * @example
     * // For the value, convertable into a date:
     * var result = isValid(1393804800000)
     * //=> true
     *
     * @example
     * // For the invalid date:
     * var result = isValid(new Date(''))
     * //=> false
     */

    function isValid(dirtyDate) {
      if (arguments.length < 1) {
        throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
      }

      var date = toDate(dirtyDate);
      return !isNaN(date);
    }

    /**
     * @name differenceInCalendarMonths
     * @category Month Helpers
     * @summary Get the number of calendar months between the given dates.
     *
     * @description
     * Get the number of calendar months between the given dates.
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * @param {Date|Number} dateLeft - the later date
     * @param {Date|Number} dateRight - the earlier date
     * @returns {Number} the number of calendar months
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // How many calendar months are between 31 January 2014 and 1 September 2014?
     * var result = differenceInCalendarMonths(
     *   new Date(2014, 8, 1),
     *   new Date(2014, 0, 31)
     * )
     * //=> 8
     */

    function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
      if (arguments.length < 2) {
        throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
      }

      var dateLeft = toDate(dirtyDateLeft);
      var dateRight = toDate(dirtyDateRight);
      var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
      var monthDiff = dateLeft.getMonth() - dateRight.getMonth();
      return yearDiff * 12 + monthDiff;
    }

    /**
     * @name differenceInMilliseconds
     * @category Millisecond Helpers
     * @summary Get the number of milliseconds between the given dates.
     *
     * @description
     * Get the number of milliseconds between the given dates.
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * @param {Date|Number} dateLeft - the later date
     * @param {Date|Number} dateRight - the earlier date
     * @returns {Number} the number of milliseconds
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // How many milliseconds are between
     * // 2 July 2014 12:30:20.600 and 2 July 2014 12:30:21.700?
     * var result = differenceInMilliseconds(
     *   new Date(2014, 6, 2, 12, 30, 21, 700),
     *   new Date(2014, 6, 2, 12, 30, 20, 600)
     * )
     * //=> 1100
     */

    function differenceInMilliseconds(dirtyDateLeft, dirtyDateRight) {
      if (arguments.length < 2) {
        throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
      }

      var dateLeft = toDate(dirtyDateLeft);
      var dateRight = toDate(dirtyDateRight);
      return dateLeft.getTime() - dateRight.getTime();
    }

    /**
     * @name differenceInMonths
     * @category Month Helpers
     * @summary Get the number of full months between the given dates.
     *
     * @description
     * Get the number of full months between the given dates.
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * @param {Date|Number} dateLeft - the later date
     * @param {Date|Number} dateRight - the earlier date
     * @returns {Number} the number of full months
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // How many full months are between 31 January 2014 and 1 September 2014?
     * var result = differenceInMonths(new Date(2014, 8, 1), new Date(2014, 0, 31))
     * //=> 7
     */

    function differenceInMonths(dirtyDateLeft, dirtyDateRight) {
      if (arguments.length < 2) {
        throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
      }

      var dateLeft = toDate(dirtyDateLeft);
      var dateRight = toDate(dirtyDateRight);
      var sign = compareAsc(dateLeft, dateRight);
      var difference = Math.abs(differenceInCalendarMonths(dateLeft, dateRight));
      dateLeft.setMonth(dateLeft.getMonth() - sign * difference); // Math.abs(diff in full months - diff in calendar months) === 1 if last calendar month is not full
      // If so, result must be decreased by 1 in absolute value

      var isLastMonthNotFull = compareAsc(dateLeft, dateRight) === -sign;
      var result = sign * (difference - isLastMonthNotFull); // Prevent negative zero

      return result === 0 ? 0 : result;
    }

    /**
     * @name differenceInSeconds
     * @category Second Helpers
     * @summary Get the number of seconds between the given dates.
     *
     * @description
     * Get the number of seconds between the given dates.
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * @param {Date|Number} dateLeft - the later date
     * @param {Date|Number} dateRight - the earlier date
     * @returns {Number} the number of seconds
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // How many seconds are between
     * // 2 July 2014 12:30:07.999 and 2 July 2014 12:30:20.000?
     * var result = differenceInSeconds(
     *   new Date(2014, 6, 2, 12, 30, 20, 0),
     *   new Date(2014, 6, 2, 12, 30, 7, 999)
     * )
     * //=> 12
     */

    function differenceInSeconds(dirtyDateLeft, dirtyDateRight) {
      if (arguments.length < 2) {
        throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
      }

      var diff = differenceInMilliseconds(dirtyDateLeft, dirtyDateRight) / 1000;
      return diff > 0 ? Math.floor(diff) : Math.ceil(diff);
    }

    var formatDistanceLocale = {
      lessThanXSeconds: {
        one: 'less than a second',
        other: 'less than {{count}} seconds'
      },
      xSeconds: {
        one: '1 second',
        other: '{{count}} seconds'
      },
      halfAMinute: 'half a minute',
      lessThanXMinutes: {
        one: 'less than a minute',
        other: 'less than {{count}} minutes'
      },
      xMinutes: {
        one: '1 minute',
        other: '{{count}} minutes'
      },
      aboutXHours: {
        one: 'about 1 hour',
        other: 'about {{count}} hours'
      },
      xHours: {
        one: '1 hour',
        other: '{{count}} hours'
      },
      xDays: {
        one: '1 day',
        other: '{{count}} days'
      },
      aboutXMonths: {
        one: 'about 1 month',
        other: 'about {{count}} months'
      },
      xMonths: {
        one: '1 month',
        other: '{{count}} months'
      },
      aboutXYears: {
        one: 'about 1 year',
        other: 'about {{count}} years'
      },
      xYears: {
        one: '1 year',
        other: '{{count}} years'
      },
      overXYears: {
        one: 'over 1 year',
        other: 'over {{count}} years'
      },
      almostXYears: {
        one: 'almost 1 year',
        other: 'almost {{count}} years'
      }
    };
    function formatDistance(token, count, options) {
      options = options || {};
      var result;

      if (typeof formatDistanceLocale[token] === 'string') {
        result = formatDistanceLocale[token];
      } else if (count === 1) {
        result = formatDistanceLocale[token].one;
      } else {
        result = formatDistanceLocale[token].other.replace('{{count}}', count);
      }

      if (options.addSuffix) {
        if (options.comparison > 0) {
          return 'in ' + result;
        } else {
          return result + ' ago';
        }
      }

      return result;
    }

    function buildFormatLongFn(args) {
      return function (dirtyOptions) {
        var options = dirtyOptions || {};
        var width = options.width ? String(options.width) : args.defaultWidth;
        var format = args.formats[width] || args.formats[args.defaultWidth];
        return format;
      };
    }

    var dateFormats = {
      full: 'EEEE, MMMM do, y',
      long: 'MMMM do, y',
      medium: 'MMM d, y',
      short: 'MM/dd/yyyy'
    };
    var timeFormats = {
      full: 'h:mm:ss a zzzz',
      long: 'h:mm:ss a z',
      medium: 'h:mm:ss a',
      short: 'h:mm a'
    };
    var dateTimeFormats = {
      full: "{{date}} 'at' {{time}}",
      long: "{{date}} 'at' {{time}}",
      medium: '{{date}}, {{time}}',
      short: '{{date}}, {{time}}'
    };
    var formatLong = {
      date: buildFormatLongFn({
        formats: dateFormats,
        defaultWidth: 'full'
      }),
      time: buildFormatLongFn({
        formats: timeFormats,
        defaultWidth: 'full'
      }),
      dateTime: buildFormatLongFn({
        formats: dateTimeFormats,
        defaultWidth: 'full'
      })
    };

    var formatRelativeLocale = {
      lastWeek: "'last' eeee 'at' p",
      yesterday: "'yesterday at' p",
      today: "'today at' p",
      tomorrow: "'tomorrow at' p",
      nextWeek: "eeee 'at' p",
      other: 'P'
    };
    function formatRelative(token, _date, _baseDate, _options) {
      return formatRelativeLocale[token];
    }

    function buildLocalizeFn(args) {
      return function (dirtyIndex, dirtyOptions) {
        var options = dirtyOptions || {};
        var context = options.context ? String(options.context) : 'standalone';
        var valuesArray;

        if (context === 'formatting' && args.formattingValues) {
          var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
          var width = options.width ? String(options.width) : defaultWidth;
          valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
        } else {
          var _defaultWidth = args.defaultWidth;

          var _width = options.width ? String(options.width) : args.defaultWidth;

          valuesArray = args.values[_width] || args.values[_defaultWidth];
        }

        var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
        return valuesArray[index];
      };
    }

    var eraValues = {
      narrow: ['B', 'A'],
      abbreviated: ['BC', 'AD'],
      wide: ['Before Christ', 'Anno Domini']
    };
    var quarterValues = {
      narrow: ['1', '2', '3', '4'],
      abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
      wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter'] // Note: in English, the names of days of the week and months are capitalized.
      // If you are making a new locale based on this one, check if the same is true for the language you're working on.
      // Generally, formatted dates should look like they are in the middle of a sentence,
      // e.g. in Spanish language the weekdays and months should be in the lowercase.

    };
    var monthValues = {
      narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
      abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
      wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
    };
    var dayValues = {
      narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
      short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
      abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
      wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
    };
    var dayPeriodValues = {
      narrow: {
        am: 'a',
        pm: 'p',
        midnight: 'mi',
        noon: 'n',
        morning: 'morning',
        afternoon: 'afternoon',
        evening: 'evening',
        night: 'night'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'morning',
        afternoon: 'afternoon',
        evening: 'evening',
        night: 'night'
      },
      wide: {
        am: 'a.m.',
        pm: 'p.m.',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'morning',
        afternoon: 'afternoon',
        evening: 'evening',
        night: 'night'
      }
    };
    var formattingDayPeriodValues = {
      narrow: {
        am: 'a',
        pm: 'p',
        midnight: 'mi',
        noon: 'n',
        morning: 'in the morning',
        afternoon: 'in the afternoon',
        evening: 'in the evening',
        night: 'at night'
      },
      abbreviated: {
        am: 'AM',
        pm: 'PM',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'in the morning',
        afternoon: 'in the afternoon',
        evening: 'in the evening',
        night: 'at night'
      },
      wide: {
        am: 'a.m.',
        pm: 'p.m.',
        midnight: 'midnight',
        noon: 'noon',
        morning: 'in the morning',
        afternoon: 'in the afternoon',
        evening: 'in the evening',
        night: 'at night'
      }
    };

    function ordinalNumber(dirtyNumber, _dirtyOptions) {
      var number = Number(dirtyNumber); // If ordinal numbers depend on context, for example,
      // if they are different for different grammatical genders,
      // use `options.unit`:
      //
      //   var options = dirtyOptions || {}
      //   var unit = String(options.unit)
      //
      // where `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
      // 'day', 'hour', 'minute', 'second'

      var rem100 = number % 100;

      if (rem100 > 20 || rem100 < 10) {
        switch (rem100 % 10) {
          case 1:
            return number + 'st';

          case 2:
            return number + 'nd';

          case 3:
            return number + 'rd';
        }
      }

      return number + 'th';
    }

    var localize = {
      ordinalNumber: ordinalNumber,
      era: buildLocalizeFn({
        values: eraValues,
        defaultWidth: 'wide'
      }),
      quarter: buildLocalizeFn({
        values: quarterValues,
        defaultWidth: 'wide',
        argumentCallback: function (quarter) {
          return Number(quarter) - 1;
        }
      }),
      month: buildLocalizeFn({
        values: monthValues,
        defaultWidth: 'wide'
      }),
      day: buildLocalizeFn({
        values: dayValues,
        defaultWidth: 'wide'
      }),
      dayPeriod: buildLocalizeFn({
        values: dayPeriodValues,
        defaultWidth: 'wide',
        formattingValues: formattingDayPeriodValues,
        defaultFormattingWidth: 'wide'
      })
    };

    function buildMatchPatternFn(args) {
      return function (dirtyString, dirtyOptions) {
        var string = String(dirtyString);
        var options = dirtyOptions || {};
        var matchResult = string.match(args.matchPattern);

        if (!matchResult) {
          return null;
        }

        var matchedString = matchResult[0];
        var parseResult = string.match(args.parsePattern);

        if (!parseResult) {
          return null;
        }

        var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
        value = options.valueCallback ? options.valueCallback(value) : value;
        return {
          value: value,
          rest: string.slice(matchedString.length)
        };
      };
    }

    function buildMatchFn(args) {
      return function (dirtyString, dirtyOptions) {
        var string = String(dirtyString);
        var options = dirtyOptions || {};
        var width = options.width;
        var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
        var matchResult = string.match(matchPattern);

        if (!matchResult) {
          return null;
        }

        var matchedString = matchResult[0];
        var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
        var value;

        if (Object.prototype.toString.call(parsePatterns) === '[object Array]') {
          value = parsePatterns.findIndex(function (pattern) {
            return pattern.test(string);
          });
        } else {
          value = findKey(parsePatterns, function (pattern) {
            return pattern.test(string);
          });
        }

        value = args.valueCallback ? args.valueCallback(value) : value;
        value = options.valueCallback ? options.valueCallback(value) : value;
        return {
          value: value,
          rest: string.slice(matchedString.length)
        };
      };
    }

    function findKey(object, predicate) {
      for (var key in object) {
        if (object.hasOwnProperty(key) && predicate(object[key])) {
          return key;
        }
      }
    }

    var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
    var parseOrdinalNumberPattern = /\d+/i;
    var matchEraPatterns = {
      narrow: /^(b|a)/i,
      abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
      wide: /^(before christ|before common era|anno domini|common era)/i
    };
    var parseEraPatterns = {
      any: [/^b/i, /^(a|c)/i]
    };
    var matchQuarterPatterns = {
      narrow: /^[1234]/i,
      abbreviated: /^q[1234]/i,
      wide: /^[1234](th|st|nd|rd)? quarter/i
    };
    var parseQuarterPatterns = {
      any: [/1/i, /2/i, /3/i, /4/i]
    };
    var matchMonthPatterns = {
      narrow: /^[jfmasond]/i,
      abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
      wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
    };
    var parseMonthPatterns = {
      narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
      any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
    };
    var matchDayPatterns = {
      narrow: /^[smtwf]/i,
      short: /^(su|mo|tu|we|th|fr|sa)/i,
      abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
      wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
    };
    var parseDayPatterns = {
      narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
      any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
    };
    var matchDayPeriodPatterns = {
      narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
      any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
    };
    var parseDayPeriodPatterns = {
      any: {
        am: /^a/i,
        pm: /^p/i,
        midnight: /^mi/i,
        noon: /^no/i,
        morning: /morning/i,
        afternoon: /afternoon/i,
        evening: /evening/i,
        night: /night/i
      }
    };
    var match = {
      ordinalNumber: buildMatchPatternFn({
        matchPattern: matchOrdinalNumberPattern,
        parsePattern: parseOrdinalNumberPattern,
        valueCallback: function (value) {
          return parseInt(value, 10);
        }
      }),
      era: buildMatchFn({
        matchPatterns: matchEraPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseEraPatterns,
        defaultParseWidth: 'any'
      }),
      quarter: buildMatchFn({
        matchPatterns: matchQuarterPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseQuarterPatterns,
        defaultParseWidth: 'any',
        valueCallback: function (index) {
          return index + 1;
        }
      }),
      month: buildMatchFn({
        matchPatterns: matchMonthPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseMonthPatterns,
        defaultParseWidth: 'any'
      }),
      day: buildMatchFn({
        matchPatterns: matchDayPatterns,
        defaultMatchWidth: 'wide',
        parsePatterns: parseDayPatterns,
        defaultParseWidth: 'any'
      }),
      dayPeriod: buildMatchFn({
        matchPatterns: matchDayPeriodPatterns,
        defaultMatchWidth: 'any',
        parsePatterns: parseDayPeriodPatterns,
        defaultParseWidth: 'any'
      })
    };

    /**
     * @type {Locale}
     * @category Locales
     * @summary English locale (United States).
     * @language English
     * @iso-639-2 eng
     * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
     * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
     */

    var locale = {
      formatDistance: formatDistance,
      formatLong: formatLong,
      formatRelative: formatRelative,
      localize: localize,
      match: match,
      options: {
        weekStartsOn: 0
        /* Sunday */
        ,
        firstWeekContainsDate: 1
      }
    };

    /**
     * @name subMilliseconds
     * @category Millisecond Helpers
     * @summary Subtract the specified number of milliseconds from the given date.
     *
     * @description
     * Subtract the specified number of milliseconds from the given date.
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * @param {Date|Number} date - the date to be changed
     * @param {Number} amount - the amount of milliseconds to be subtracted
     * @returns {Date} the new date with the milliseconds subtracted
     * @throws {TypeError} 2 arguments required
     *
     * @example
     * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
     * var result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
     * //=> Thu Jul 10 2014 12:45:29.250
     */

    function subMilliseconds(dirtyDate, dirtyAmount) {
      if (arguments.length < 2) {
        throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
      }

      var amount = toInteger(dirtyAmount);
      return addMilliseconds(dirtyDate, -amount);
    }

    function addLeadingZeros(number, targetLength) {
      var sign = number < 0 ? '-' : '';
      var output = Math.abs(number).toString();

      while (output.length < targetLength) {
        output = '0' + output;
      }

      return sign + output;
    }

    /*
     * |     | Unit                           |     | Unit                           |
     * |-----|--------------------------------|-----|--------------------------------|
     * |  a  | AM, PM                         |  A* |                                |
     * |  d  | Day of month                   |  D  |                                |
     * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
     * |  m  | Minute                         |  M  | Month                          |
     * |  s  | Second                         |  S  | Fraction of second             |
     * |  y  | Year (abs)                     |  Y  |                                |
     *
     * Letters marked by * are not implemented but reserved by Unicode standard.
     */

    var formatters = {
      // Year
      y: function (date, token) {
        // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
        // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
        // |----------|-------|----|-------|-------|-------|
        // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
        // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
        // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
        // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
        // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
        var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

        var year = signedYear > 0 ? signedYear : 1 - signedYear;
        return addLeadingZeros(token === 'yy' ? year % 100 : year, token.length);
      },
      // Month
      M: function (date, token) {
        var month = date.getUTCMonth();
        return token === 'M' ? String(month + 1) : addLeadingZeros(month + 1, 2);
      },
      // Day of the month
      d: function (date, token) {
        return addLeadingZeros(date.getUTCDate(), token.length);
      },
      // AM or PM
      a: function (date, token) {
        var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';

        switch (token) {
          case 'a':
          case 'aa':
          case 'aaa':
            return dayPeriodEnumValue.toUpperCase();

          case 'aaaaa':
            return dayPeriodEnumValue[0];

          case 'aaaa':
          default:
            return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';
        }
      },
      // Hour [1-12]
      h: function (date, token) {
        return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
      },
      // Hour [0-23]
      H: function (date, token) {
        return addLeadingZeros(date.getUTCHours(), token.length);
      },
      // Minute
      m: function (date, token) {
        return addLeadingZeros(date.getUTCMinutes(), token.length);
      },
      // Second
      s: function (date, token) {
        return addLeadingZeros(date.getUTCSeconds(), token.length);
      },
      // Fraction of second
      S: function (date, token) {
        var numberOfDigits = token.length;
        var milliseconds = date.getUTCMilliseconds();
        var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
        return addLeadingZeros(fractionalSeconds, token.length);
      }
    };

    var MILLISECONDS_IN_DAY$1 = 86400000; // This function will be a part of public API when UTC function will be implemented.
    // See issue: https://github.com/date-fns/date-fns/issues/376

    function getUTCDayOfYear(dirtyDate) {
      if (arguments.length < 1) {
        throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
      }

      var date = toDate(dirtyDate);
      var timestamp = date.getTime();
      date.setUTCMonth(0, 1);
      date.setUTCHours(0, 0, 0, 0);
      var startOfYearTimestamp = date.getTime();
      var difference = timestamp - startOfYearTimestamp;
      return Math.floor(difference / MILLISECONDS_IN_DAY$1) + 1;
    }

    // See issue: https://github.com/date-fns/date-fns/issues/376

    function startOfUTCISOWeek(dirtyDate) {
      if (arguments.length < 1) {
        throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
      }

      var weekStartsOn = 1;
      var date = toDate(dirtyDate);
      var day = date.getUTCDay();
      var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
      date.setUTCDate(date.getUTCDate() - diff);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }

    // See issue: https://github.com/date-fns/date-fns/issues/376

    function getUTCISOWeekYear(dirtyDate) {
      if (arguments.length < 1) {
        throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
      }

      var date = toDate(dirtyDate);
      var year = date.getUTCFullYear();
      var fourthOfJanuaryOfNextYear = new Date(0);
      fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
      fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
      var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
      var fourthOfJanuaryOfThisYear = new Date(0);
      fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
      fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
      var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);

      if (date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
      } else if (date.getTime() >= startOfThisYear.getTime()) {
        return year;
      } else {
        return year - 1;
      }
    }

    // See issue: https://github.com/date-fns/date-fns/issues/376

    function startOfUTCISOWeekYear(dirtyDate) {
      if (arguments.length < 1) {
        throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
      }

      var year = getUTCISOWeekYear(dirtyDate);
      var fourthOfJanuary = new Date(0);
      fourthOfJanuary.setUTCFullYear(year, 0, 4);
      fourthOfJanuary.setUTCHours(0, 0, 0, 0);
      var date = startOfUTCISOWeek(fourthOfJanuary);
      return date;
    }

    var MILLISECONDS_IN_WEEK = 604800000; // This function will be a part of public API when UTC function will be implemented.
    // See issue: https://github.com/date-fns/date-fns/issues/376

    function getUTCISOWeek(dirtyDate) {
      if (arguments.length < 1) {
        throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
      }

      var date = toDate(dirtyDate);
      var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime(); // Round the number of days to the nearest integer
      // because the number of milliseconds in a week is not constant
      // (e.g. it's different in the week of the daylight saving time clock shift)

      return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
    }

    // See issue: https://github.com/date-fns/date-fns/issues/376

    function startOfUTCWeek(dirtyDate, dirtyOptions) {
      if (arguments.length < 1) {
        throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
      }

      var options = dirtyOptions || {};
      var locale = options.locale;
      var localeWeekStartsOn = locale && locale.options && locale.options.weekStartsOn;
      var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
      var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
      }

      var date = toDate(dirtyDate);
      var day = date.getUTCDay();
      var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
      date.setUTCDate(date.getUTCDate() - diff);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }

    // See issue: https://github.com/date-fns/date-fns/issues/376

    function getUTCWeekYear(dirtyDate, dirtyOptions) {
      if (arguments.length < 1) {
        throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
      }

      var date = toDate(dirtyDate, dirtyOptions);
      var year = date.getUTCFullYear();
      var options = dirtyOptions || {};
      var locale = options.locale;
      var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
      var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
      var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

      if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
        throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
      }

      var firstWeekOfNextYear = new Date(0);
      firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
      firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
      var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, dirtyOptions);
      var firstWeekOfThisYear = new Date(0);
      firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
      firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
      var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, dirtyOptions);

      if (date.getTime() >= startOfNextYear.getTime()) {
        return year + 1;
      } else if (date.getTime() >= startOfThisYear.getTime()) {
        return year;
      } else {
        return year - 1;
      }
    }

    // See issue: https://github.com/date-fns/date-fns/issues/376

    function startOfUTCWeekYear(dirtyDate, dirtyOptions) {
      if (arguments.length < 1) {
        throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
      }

      var options = dirtyOptions || {};
      var locale = options.locale;
      var localeFirstWeekContainsDate = locale && locale.options && locale.options.firstWeekContainsDate;
      var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
      var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate);
      var year = getUTCWeekYear(dirtyDate, dirtyOptions);
      var firstWeek = new Date(0);
      firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
      firstWeek.setUTCHours(0, 0, 0, 0);
      var date = startOfUTCWeek(firstWeek, dirtyOptions);
      return date;
    }

    var MILLISECONDS_IN_WEEK$1 = 604800000; // This function will be a part of public API when UTC function will be implemented.
    // See issue: https://github.com/date-fns/date-fns/issues/376

    function getUTCWeek(dirtyDate, options) {
      if (arguments.length < 1) {
        throw new TypeError('1 argument required, but only ' + arguments.length + ' present');
      }

      var date = toDate(dirtyDate);
      var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime(); // Round the number of days to the nearest integer
      // because the number of milliseconds in a week is not constant
      // (e.g. it's different in the week of the daylight saving time clock shift)

      return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
    }

    var dayPeriodEnum = {
      am: 'am',
      pm: 'pm',
      midnight: 'midnight',
      noon: 'noon',
      morning: 'morning',
      afternoon: 'afternoon',
      evening: 'evening',
      night: 'night'
      /*
       * |     | Unit                           |     | Unit                           |
       * |-----|--------------------------------|-----|--------------------------------|
       * |  a  | AM, PM                         |  A* | Milliseconds in day            |
       * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
       * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
       * |  d  | Day of month                   |  D  | Day of year                    |
       * |  e  | Local day of week              |  E  | Day of week                    |
       * |  f  |                                |  F* | Day of week in month           |
       * |  g* | Modified Julian day            |  G  | Era                            |
       * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
       * |  i! | ISO day of week                |  I! | ISO week of year               |
       * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
       * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
       * |  l* | (deprecated)                   |  L  | Stand-alone month              |
       * |  m  | Minute                         |  M  | Month                          |
       * |  n  |                                |  N  |                                |
       * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
       * |  p! | Long localized time            |  P! | Long localized date            |
       * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
       * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
       * |  s  | Second                         |  S  | Fraction of second             |
       * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
       * |  u  | Extended year                  |  U* | Cyclic year                    |
       * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
       * |  w  | Local week of year             |  W* | Week of month                  |
       * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
       * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
       * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
       *
       * Letters marked by * are not implemented but reserved by Unicode standard.
       *
       * Letters marked by ! are non-standard, but implemented by date-fns:
       * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
       * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
       *   i.e. 7 for Sunday, 1 for Monday, etc.
       * - `I` is ISO week of year, as opposed to `w` which is local week of year.
       * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
       *   `R` is supposed to be used in conjunction with `I` and `i`
       *   for universal ISO week-numbering date, whereas
       *   `Y` is supposed to be used in conjunction with `w` and `e`
       *   for week-numbering date specific to the locale.
       * - `P` is long localized date format
       * - `p` is long localized time format
       */

    };
    var formatters$1 = {
      // Era
      G: function (date, token, localize) {
        var era = date.getUTCFullYear() > 0 ? 1 : 0;

        switch (token) {
          // AD, BC
          case 'G':
          case 'GG':
          case 'GGG':
            return localize.era(era, {
              width: 'abbreviated'
            });
          // A, B

          case 'GGGGG':
            return localize.era(era, {
              width: 'narrow'
            });
          // Anno Domini, Before Christ

          case 'GGGG':
          default:
            return localize.era(era, {
              width: 'wide'
            });
        }
      },
      // Year
      y: function (date, token, localize) {
        // Ordinal number
        if (token === 'yo') {
          var signedYear = date.getUTCFullYear(); // Returns 1 for 1 BC (which is year 0 in JavaScript)

          var year = signedYear > 0 ? signedYear : 1 - signedYear;
          return localize.ordinalNumber(year, {
            unit: 'year'
          });
        }

        return formatters.y(date, token);
      },
      // Local week-numbering year
      Y: function (date, token, localize, options) {
        var signedWeekYear = getUTCWeekYear(date, options); // Returns 1 for 1 BC (which is year 0 in JavaScript)

        var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear; // Two digit year

        if (token === 'YY') {
          var twoDigitYear = weekYear % 100;
          return addLeadingZeros(twoDigitYear, 2);
        } // Ordinal number


        if (token === 'Yo') {
          return localize.ordinalNumber(weekYear, {
            unit: 'year'
          });
        } // Padding


        return addLeadingZeros(weekYear, token.length);
      },
      // ISO week-numbering year
      R: function (date, token) {
        var isoWeekYear = getUTCISOWeekYear(date); // Padding

        return addLeadingZeros(isoWeekYear, token.length);
      },
      // Extended year. This is a single number designating the year of this calendar system.
      // The main difference between `y` and `u` localizers are B.C. years:
      // | Year | `y` | `u` |
      // |------|-----|-----|
      // | AC 1 |   1 |   1 |
      // | BC 1 |   1 |   0 |
      // | BC 2 |   2 |  -1 |
      // Also `yy` always returns the last two digits of a year,
      // while `uu` pads single digit years to 2 characters and returns other years unchanged.
      u: function (date, token) {
        var year = date.getUTCFullYear();
        return addLeadingZeros(year, token.length);
      },
      // Quarter
      Q: function (date, token, localize) {
        var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

        switch (token) {
          // 1, 2, 3, 4
          case 'Q':
            return String(quarter);
          // 01, 02, 03, 04

          case 'QQ':
            return addLeadingZeros(quarter, 2);
          // 1st, 2nd, 3rd, 4th

          case 'Qo':
            return localize.ordinalNumber(quarter, {
              unit: 'quarter'
            });
          // Q1, Q2, Q3, Q4

          case 'QQQ':
            return localize.quarter(quarter, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // 1, 2, 3, 4 (narrow quarter; could be not numerical)

          case 'QQQQQ':
            return localize.quarter(quarter, {
              width: 'narrow',
              context: 'formatting'
            });
          // 1st quarter, 2nd quarter, ...

          case 'QQQQ':
          default:
            return localize.quarter(quarter, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Stand-alone quarter
      q: function (date, token, localize) {
        var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);

        switch (token) {
          // 1, 2, 3, 4
          case 'q':
            return String(quarter);
          // 01, 02, 03, 04

          case 'qq':
            return addLeadingZeros(quarter, 2);
          // 1st, 2nd, 3rd, 4th

          case 'qo':
            return localize.ordinalNumber(quarter, {
              unit: 'quarter'
            });
          // Q1, Q2, Q3, Q4

          case 'qqq':
            return localize.quarter(quarter, {
              width: 'abbreviated',
              context: 'standalone'
            });
          // 1, 2, 3, 4 (narrow quarter; could be not numerical)

          case 'qqqqq':
            return localize.quarter(quarter, {
              width: 'narrow',
              context: 'standalone'
            });
          // 1st quarter, 2nd quarter, ...

          case 'qqqq':
          default:
            return localize.quarter(quarter, {
              width: 'wide',
              context: 'standalone'
            });
        }
      },
      // Month
      M: function (date, token, localize) {
        var month = date.getUTCMonth();

        switch (token) {
          case 'M':
          case 'MM':
            return formatters.M(date, token);
          // 1st, 2nd, ..., 12th

          case 'Mo':
            return localize.ordinalNumber(month + 1, {
              unit: 'month'
            });
          // Jan, Feb, ..., Dec

          case 'MMM':
            return localize.month(month, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // J, F, ..., D

          case 'MMMMM':
            return localize.month(month, {
              width: 'narrow',
              context: 'formatting'
            });
          // January, February, ..., December

          case 'MMMM':
          default:
            return localize.month(month, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Stand-alone month
      L: function (date, token, localize) {
        var month = date.getUTCMonth();

        switch (token) {
          // 1, 2, ..., 12
          case 'L':
            return String(month + 1);
          // 01, 02, ..., 12

          case 'LL':
            return addLeadingZeros(month + 1, 2);
          // 1st, 2nd, ..., 12th

          case 'Lo':
            return localize.ordinalNumber(month + 1, {
              unit: 'month'
            });
          // Jan, Feb, ..., Dec

          case 'LLL':
            return localize.month(month, {
              width: 'abbreviated',
              context: 'standalone'
            });
          // J, F, ..., D

          case 'LLLLL':
            return localize.month(month, {
              width: 'narrow',
              context: 'standalone'
            });
          // January, February, ..., December

          case 'LLLL':
          default:
            return localize.month(month, {
              width: 'wide',
              context: 'standalone'
            });
        }
      },
      // Local week of year
      w: function (date, token, localize, options) {
        var week = getUTCWeek(date, options);

        if (token === 'wo') {
          return localize.ordinalNumber(week, {
            unit: 'week'
          });
        }

        return addLeadingZeros(week, token.length);
      },
      // ISO week of year
      I: function (date, token, localize) {
        var isoWeek = getUTCISOWeek(date);

        if (token === 'Io') {
          return localize.ordinalNumber(isoWeek, {
            unit: 'week'
          });
        }

        return addLeadingZeros(isoWeek, token.length);
      },
      // Day of the month
      d: function (date, token, localize) {
        if (token === 'do') {
          return localize.ordinalNumber(date.getUTCDate(), {
            unit: 'date'
          });
        }

        return formatters.d(date, token);
      },
      // Day of year
      D: function (date, token, localize) {
        var dayOfYear = getUTCDayOfYear(date);

        if (token === 'Do') {
          return localize.ordinalNumber(dayOfYear, {
            unit: 'dayOfYear'
          });
        }

        return addLeadingZeros(dayOfYear, token.length);
      },
      // Day of week
      E: function (date, token, localize) {
        var dayOfWeek = date.getUTCDay();

        switch (token) {
          // Tue
          case 'E':
          case 'EE':
          case 'EEE':
            return localize.day(dayOfWeek, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // T

          case 'EEEEE':
            return localize.day(dayOfWeek, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu

          case 'EEEEEE':
            return localize.day(dayOfWeek, {
              width: 'short',
              context: 'formatting'
            });
          // Tuesday

          case 'EEEE':
          default:
            return localize.day(dayOfWeek, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Local day of week
      e: function (date, token, localize, options) {
        var dayOfWeek = date.getUTCDay();
        var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

        switch (token) {
          // Numerical value (Nth day of week with current locale or weekStartsOn)
          case 'e':
            return String(localDayOfWeek);
          // Padded numerical value

          case 'ee':
            return addLeadingZeros(localDayOfWeek, 2);
          // 1st, 2nd, ..., 7th

          case 'eo':
            return localize.ordinalNumber(localDayOfWeek, {
              unit: 'day'
            });

          case 'eee':
            return localize.day(dayOfWeek, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // T

          case 'eeeee':
            return localize.day(dayOfWeek, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu

          case 'eeeeee':
            return localize.day(dayOfWeek, {
              width: 'short',
              context: 'formatting'
            });
          // Tuesday

          case 'eeee':
          default:
            return localize.day(dayOfWeek, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Stand-alone local day of week
      c: function (date, token, localize, options) {
        var dayOfWeek = date.getUTCDay();
        var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;

        switch (token) {
          // Numerical value (same as in `e`)
          case 'c':
            return String(localDayOfWeek);
          // Padded numerical value

          case 'cc':
            return addLeadingZeros(localDayOfWeek, token.length);
          // 1st, 2nd, ..., 7th

          case 'co':
            return localize.ordinalNumber(localDayOfWeek, {
              unit: 'day'
            });

          case 'ccc':
            return localize.day(dayOfWeek, {
              width: 'abbreviated',
              context: 'standalone'
            });
          // T

          case 'ccccc':
            return localize.day(dayOfWeek, {
              width: 'narrow',
              context: 'standalone'
            });
          // Tu

          case 'cccccc':
            return localize.day(dayOfWeek, {
              width: 'short',
              context: 'standalone'
            });
          // Tuesday

          case 'cccc':
          default:
            return localize.day(dayOfWeek, {
              width: 'wide',
              context: 'standalone'
            });
        }
      },
      // ISO day of week
      i: function (date, token, localize) {
        var dayOfWeek = date.getUTCDay();
        var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;

        switch (token) {
          // 2
          case 'i':
            return String(isoDayOfWeek);
          // 02

          case 'ii':
            return addLeadingZeros(isoDayOfWeek, token.length);
          // 2nd

          case 'io':
            return localize.ordinalNumber(isoDayOfWeek, {
              unit: 'day'
            });
          // Tue

          case 'iii':
            return localize.day(dayOfWeek, {
              width: 'abbreviated',
              context: 'formatting'
            });
          // T

          case 'iiiii':
            return localize.day(dayOfWeek, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu

          case 'iiiiii':
            return localize.day(dayOfWeek, {
              width: 'short',
              context: 'formatting'
            });
          // Tuesday

          case 'iiii':
          default:
            return localize.day(dayOfWeek, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // AM or PM
      a: function (date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';

        switch (token) {
          case 'a':
          case 'aa':
          case 'aaa':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            });

          case 'aaaaa':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'aaaa':
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // AM, PM, midnight, noon
      b: function (date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue;

        if (hours === 12) {
          dayPeriodEnumValue = dayPeriodEnum.noon;
        } else if (hours === 0) {
          dayPeriodEnumValue = dayPeriodEnum.midnight;
        } else {
          dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
        }

        switch (token) {
          case 'b':
          case 'bb':
          case 'bbb':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            });

          case 'bbbbb':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'bbbb':
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // in the morning, in the afternoon, in the evening, at night
      B: function (date, token, localize) {
        var hours = date.getUTCHours();
        var dayPeriodEnumValue;

        if (hours >= 17) {
          dayPeriodEnumValue = dayPeriodEnum.evening;
        } else if (hours >= 12) {
          dayPeriodEnumValue = dayPeriodEnum.afternoon;
        } else if (hours >= 4) {
          dayPeriodEnumValue = dayPeriodEnum.morning;
        } else {
          dayPeriodEnumValue = dayPeriodEnum.night;
        }

        switch (token) {
          case 'B':
          case 'BB':
          case 'BBB':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'abbreviated',
              context: 'formatting'
            });

          case 'BBBBB':
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'narrow',
              context: 'formatting'
            });

          case 'BBBB':
          default:
            return localize.dayPeriod(dayPeriodEnumValue, {
              width: 'wide',
              context: 'formatting'
            });
        }
      },
      // Hour [1-12]
      h: function (date, token, localize) {
        if (token === 'ho') {
          var hours = date.getUTCHours() % 12;
          if (hours === 0) hours = 12;
          return localize.ordinalNumber(hours, {
            unit: 'hour'
          });
        }

        return formatters.h(date, token);
      },
      // Hour [0-23]
      H: function (date, token, localize) {
        if (token === 'Ho') {
          return localize.ordinalNumber(date.getUTCHours(), {
            unit: 'hour'
          });
        }

        return formatters.H(date, token);
      },
      // Hour [0-11]
      K: function (date, token, localize) {
        var hours = date.getUTCHours() % 12;

        if (token === 'Ko') {
          return localize.ordinalNumber(hours, {
            unit: 'hour'
          });
        }

        return addLeadingZeros(hours, token.length);
      },
      // Hour [1-24]
      k: function (date, token, localize) {
        var hours = date.getUTCHours();
        if (hours === 0) hours = 24;

        if (token === 'ko') {
          return localize.ordinalNumber(hours, {
            unit: 'hour'
          });
        }

        return addLeadingZeros(hours, token.length);
      },
      // Minute
      m: function (date, token, localize) {
        if (token === 'mo') {
          return localize.ordinalNumber(date.getUTCMinutes(), {
            unit: 'minute'
          });
        }

        return formatters.m(date, token);
      },
      // Second
      s: function (date, token, localize) {
        if (token === 'so') {
          return localize.ordinalNumber(date.getUTCSeconds(), {
            unit: 'second'
          });
        }

        return formatters.s(date, token);
      },
      // Fraction of second
      S: function (date, token) {
        return formatters.S(date, token);
      },
      // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
      X: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();

        if (timezoneOffset === 0) {
          return 'Z';
        }

        switch (token) {
          // Hours and optional minutes
          case 'X':
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          // Hours, minutes and optional seconds without `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `XX`

          case 'XXXX':
          case 'XX':
            // Hours and minutes without `:` delimiter
            return formatTimezone(timezoneOffset);
          // Hours, minutes and optional seconds with `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `XXX`

          case 'XXXXX':
          case 'XXX': // Hours and minutes with `:` delimiter

          default:
            return formatTimezone(timezoneOffset, ':');
        }
      },
      // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
      x: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();

        switch (token) {
          // Hours and optional minutes
          case 'x':
            return formatTimezoneWithOptionalMinutes(timezoneOffset);
          // Hours, minutes and optional seconds without `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `xx`

          case 'xxxx':
          case 'xx':
            // Hours and minutes without `:` delimiter
            return formatTimezone(timezoneOffset);
          // Hours, minutes and optional seconds with `:` delimiter
          // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
          // so this token always has the same output as `xxx`

          case 'xxxxx':
          case 'xxx': // Hours and minutes with `:` delimiter

          default:
            return formatTimezone(timezoneOffset, ':');
        }
      },
      // Timezone (GMT)
      O: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();

        switch (token) {
          // Short
          case 'O':
          case 'OO':
          case 'OOO':
            return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
          // Long

          case 'OOOO':
          default:
            return 'GMT' + formatTimezone(timezoneOffset, ':');
        }
      },
      // Timezone (specific non-location)
      z: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timezoneOffset = originalDate.getTimezoneOffset();

        switch (token) {
          // Short
          case 'z':
          case 'zz':
          case 'zzz':
            return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
          // Long

          case 'zzzz':
          default:
            return 'GMT' + formatTimezone(timezoneOffset, ':');
        }
      },
      // Seconds timestamp
      t: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timestamp = Math.floor(originalDate.getTime() / 1000);
        return addLeadingZeros(timestamp, token.length);
      },
      // Milliseconds timestamp
      T: function (date, token, _localize, options) {
        var originalDate = options._originalDate || date;
        var timestamp = originalDate.getTime();
        return addLeadingZeros(timestamp, token.length);
      }
    };

    function formatTimezoneShort(offset, dirtyDelimiter) {
      var sign = offset > 0 ? '-' : '+';
      var absOffset = Math.abs(offset);
      var hours = Math.floor(absOffset / 60);
      var minutes = absOffset % 60;

      if (minutes === 0) {
        return sign + String(hours);
      }

      var delimiter = dirtyDelimiter || '';
      return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
    }

    function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
      if (offset % 60 === 0) {
        var sign = offset > 0 ? '-' : '+';
        return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
      }

      return formatTimezone(offset, dirtyDelimiter);
    }

    function formatTimezone(offset, dirtyDelimiter) {
      var delimiter = dirtyDelimiter || '';
      var sign = offset > 0 ? '-' : '+';
      var absOffset = Math.abs(offset);
      var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
      var minutes = addLeadingZeros(absOffset % 60, 2);
      return sign + hours + delimiter + minutes;
    }

    function dateLongFormatter(pattern, formatLong) {
      switch (pattern) {
        case 'P':
          return formatLong.date({
            width: 'short'
          });

        case 'PP':
          return formatLong.date({
            width: 'medium'
          });

        case 'PPP':
          return formatLong.date({
            width: 'long'
          });

        case 'PPPP':
        default:
          return formatLong.date({
            width: 'full'
          });
      }
    }

    function timeLongFormatter(pattern, formatLong) {
      switch (pattern) {
        case 'p':
          return formatLong.time({
            width: 'short'
          });

        case 'pp':
          return formatLong.time({
            width: 'medium'
          });

        case 'ppp':
          return formatLong.time({
            width: 'long'
          });

        case 'pppp':
        default:
          return formatLong.time({
            width: 'full'
          });
      }
    }

    function dateTimeLongFormatter(pattern, formatLong) {
      var matchResult = pattern.match(/(P+)(p+)?/);
      var datePattern = matchResult[1];
      var timePattern = matchResult[2];

      if (!timePattern) {
        return dateLongFormatter(pattern, formatLong);
      }

      var dateTimeFormat;

      switch (datePattern) {
        case 'P':
          dateTimeFormat = formatLong.dateTime({
            width: 'short'
          });
          break;

        case 'PP':
          dateTimeFormat = formatLong.dateTime({
            width: 'medium'
          });
          break;

        case 'PPP':
          dateTimeFormat = formatLong.dateTime({
            width: 'long'
          });
          break;

        case 'PPPP':
        default:
          dateTimeFormat = formatLong.dateTime({
            width: 'full'
          });
          break;
      }

      return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
    }

    var longFormatters = {
      p: timeLongFormatter,
      P: dateTimeLongFormatter
    };

    var protectedDayOfYearTokens = ['D', 'DD'];
    var protectedWeekYearTokens = ['YY', 'YYYY'];
    function isProtectedDayOfYearToken(token) {
      return protectedDayOfYearTokens.indexOf(token) !== -1;
    }
    function isProtectedWeekYearToken(token) {
      return protectedWeekYearTokens.indexOf(token) !== -1;
    }
    function throwProtectedError(token) {
      if (token === 'YYYY') {
        throw new RangeError('Use `yyyy` instead of `YYYY` for formatting years; see: https://git.io/fxCyr');
      } else if (token === 'YY') {
        throw new RangeError('Use `yy` instead of `YY` for formatting years; see: https://git.io/fxCyr');
      } else if (token === 'D') {
        throw new RangeError('Use `d` instead of `D` for formatting days of the month; see: https://git.io/fxCyr');
      } else if (token === 'DD') {
        throw new RangeError('Use `dd` instead of `DD` for formatting days of the month; see: https://git.io/fxCyr');
      }
    }

    // - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
    //   (one of the certain letters followed by `o`)
    // - (\w)\1* matches any sequences of the same letter
    // - '' matches two quote characters in a row
    // - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
    //   except a single quote symbol, which ends the sequence.
    //   Two quote characters do not end the sequence.
    //   If there is no matching single quote
    //   then the sequence will continue until the end of the string.
    // - . matches any single character unmatched by previous parts of the RegExps

    var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
    // sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

    var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
    var escapedStringRegExp = /^'(.*?)'?$/;
    var doubleQuoteRegExp = /''/g;
    var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
    /**
     * @name format
     * @category Common Helpers
     * @summary Format the date.
     *
     * @description
     * Return the formatted date string in the given format. The result may vary by locale.
     *
     * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
     * > See: https://git.io/fxCyr
     *
     * The characters wrapped between two single quotes characters (') are escaped.
     * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
     * (see the last example)
     *
     * Format of the string is based on Unicode Technical Standard #35:
     * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
     * with a few additions (see note 7 below the table).
     *
     * Accepted patterns:
     * | Unit                            | Pattern | Result examples                   | Notes |
     * |---------------------------------|---------|-----------------------------------|-------|
     * | Era                             | G..GGG  | AD, BC                            |       |
     * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
     * |                                 | GGGGG   | A, B                              |       |
     * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
     * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
     * |                                 | yy      | 44, 01, 00, 17                    | 5     |
     * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
     * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
     * |                                 | yyyyy   | ...                               | 3,5   |
     * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
     * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
     * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
     * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
     * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
     * |                                 | YYYYY   | ...                               | 3,5   |
     * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
     * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
     * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
     * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
     * |                                 | RRRRR   | ...                               | 3,5,7 |
     * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
     * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
     * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
     * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
     * |                                 | uuuuu   | ...                               | 3,5   |
     * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
     * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
     * |                                 | QQ      | 01, 02, 03, 04                    |       |
     * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
     * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
     * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
     * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
     * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
     * |                                 | qq      | 01, 02, 03, 04                    |       |
     * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
     * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
     * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
     * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
     * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
     * |                                 | MM      | 01, 02, ..., 12                   |       |
     * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
     * |                                 | MMMM    | January, February, ..., December  | 2     |
     * |                                 | MMMMM   | J, F, ..., D                      |       |
     * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
     * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
     * |                                 | LL      | 01, 02, ..., 12                   |       |
     * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
     * |                                 | LLLL    | January, February, ..., December  | 2     |
     * |                                 | LLLLL   | J, F, ..., D                      |       |
     * | Local week of year              | w       | 1, 2, ..., 53                     |       |
     * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
     * |                                 | ww      | 01, 02, ..., 53                   |       |
     * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
     * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
     * |                                 | II      | 01, 02, ..., 53                   | 7     |
     * | Day of month                    | d       | 1, 2, ..., 31                     |       |
     * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
     * |                                 | dd      | 01, 02, ..., 31                   |       |
     * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
     * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
     * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
     * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
     * |                                 | DDDD    | ...                               | 3     |
     * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Su            |       |
     * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
     * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
     * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
     * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
     * |                                 | ii      | 01, 02, ..., 07                   | 7     |
     * |                                 | iii     | Mon, Tue, Wed, ..., Su            | 7     |
     * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
     * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
     * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Su, Sa        | 7     |
     * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
     * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
     * |                                 | ee      | 02, 03, ..., 01                   |       |
     * |                                 | eee     | Mon, Tue, Wed, ..., Su            |       |
     * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
     * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
     * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
     * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
     * |                                 | cc      | 02, 03, ..., 01                   |       |
     * |                                 | ccc     | Mon, Tue, Wed, ..., Su            |       |
     * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
     * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
     * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
     * | AM, PM                          | a..aaa  | AM, PM                            |       |
     * |                                 | aaaa    | a.m., p.m.                        | 2     |
     * |                                 | aaaaa   | a, p                              |       |
     * | AM, PM, noon, midnight          | b..bbb  | AM, PM, noon, midnight            |       |
     * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
     * |                                 | bbbbb   | a, p, n, mi                       |       |
     * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
     * |                                 | BBBB    | at night, in the morning, ...     | 2     |
     * |                                 | BBBBB   | at night, in the morning, ...     |       |
     * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
     * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
     * |                                 | hh      | 01, 02, ..., 11, 12               |       |
     * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
     * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
     * |                                 | HH      | 00, 01, 02, ..., 23               |       |
     * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
     * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
     * |                                 | KK      | 1, 2, ..., 11, 0                  |       |
     * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
     * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
     * |                                 | kk      | 24, 01, 02, ..., 23               |       |
     * | Minute                          | m       | 0, 1, ..., 59                     |       |
     * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
     * |                                 | mm      | 00, 01, ..., 59                   |       |
     * | Second                          | s       | 0, 1, ..., 59                     |       |
     * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
     * |                                 | ss      | 00, 01, ..., 59                   |       |
     * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
     * |                                 | SS      | 00, 01, ..., 99                   |       |
     * |                                 | SSS     | 000, 0001, ..., 999               |       |
     * |                                 | SSSS    | ...                               | 3     |
     * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
     * |                                 | XX      | -0800, +0530, Z                   |       |
     * |                                 | XXX     | -08:00, +05:30, Z                 |       |
     * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
     * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
     * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
     * |                                 | xx      | -0800, +0530, +0000               |       |
     * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
     * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
     * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
     * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
     * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
     * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
     * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
     * | Seconds timestamp               | t       | 512969520                         | 7     |
     * |                                 | tt      | ...                               | 3,7   |
     * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
     * |                                 | TT      | ...                               | 3,7   |
     * | Long localized date             | P       | 05/29/1453                        | 7     |
     * |                                 | PP      | May 29, 1453                      | 7     |
     * |                                 | PPP     | May 29th, 1453                    | 7     |
     * |                                 | PPPP    | Sunday, May 29th, 1453            | 2,7   |
     * | Long localized time             | p       | 12:00 AM                          | 7     |
     * |                                 | pp      | 12:00:00 AM                       | 7     |
     * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
     * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
     * | Combination of date and time    | Pp      | 05/29/1453, 12:00 AM              | 7     |
     * |                                 | PPpp    | May 29, 1453, 12:00:00 AM         | 7     |
     * |                                 | PPPppp  | May 29th, 1453 at ...             | 7     |
     * |                                 | PPPPpppp| Sunday, May 29th, 1453 at ...     | 2,7   |
     * Notes:
     * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
     *    are the same as "stand-alone" units, but are different in some languages.
     *    "Formatting" units are declined according to the rules of the language
     *    in the context of a date. "Stand-alone" units are always nominative singular:
     *
     *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
     *
     *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
     *
     * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
     *    the single quote characters (see below).
     *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
     *    the output will be the same as default pattern for this unit, usually
     *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
     *    are marked with "2" in the last column of the table.
     *
     *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
     *
     *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
     *
     *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
     *
     *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
     *
     *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
     *
     * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
     *    The output will be padded with zeros to match the length of the pattern.
     *
     *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
     *
     * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
     *    These tokens represent the shortest form of the quarter.
     *
     * 5. The main difference between `y` and `u` patterns are B.C. years:
     *
     *    | Year | `y` | `u` |
     *    |------|-----|-----|
     *    | AC 1 |   1 |   1 |
     *    | BC 1 |   1 |   0 |
     *    | BC 2 |   2 |  -1 |
     *
     *    Also `yy` always returns the last two digits of a year,
     *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
     *
     *    | Year | `yy` | `uu` |
     *    |------|------|------|
     *    | 1    |   01 |   01 |
     *    | 14   |   14 |   14 |
     *    | 376  |   76 |  376 |
     *    | 1453 |   53 | 1453 |
     *
     *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
     *    except local week-numbering years are dependent on `options.weekStartsOn`
     *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
     *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
     *
     * 6. Specific non-location timezones are currently unavailable in `date-fns`,
     *    so right now these tokens fall back to GMT timezones.
     *
     * 7. These patterns are not in the Unicode Technical Standard #35:
     *    - `i`: ISO day of week
     *    - `I`: ISO week of year
     *    - `R`: ISO week-numbering year
     *    - `t`: seconds timestamp
     *    - `T`: milliseconds timestamp
     *    - `o`: ordinal number modifier
     *    - `P`: long localized date
     *    - `p`: long localized time
     *
     * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
     *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://git.io/fxCyr
     *
     * 9. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
     *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://git.io/fxCyr
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * - The second argument is now required for the sake of explicitness.
     *
     *   ```javascript
     *   // Before v2.0.0
     *   format(new Date(2016, 0, 1))
     *
     *   // v2.0.0 onward
     *   format(new Date(2016, 0, 1), "yyyy-MM-dd'T'HH:mm:ss.SSSxxx")
     *   ```
     *
     * - New format string API for `format` function
     *   which is based on [Unicode Technical Standard #35](https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table).
     *   See [this post](https://blog.date-fns.org/post/unicode-tokens-in-date-fns-v2-sreatyki91jg) for more details.
     *
     * - Characters are now escaped using single quote symbols (`'`) instead of square brackets.
     *
     * @param {Date|Number} date - the original date
     * @param {String} format - the string of tokens
     * @param {Object} [options] - an object with options.
     * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
     * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
     * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
     * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
     *   see: https://git.io/fxCyr
     * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
     *   see: https://git.io/fxCyr
     * @returns {String} the formatted date string
     * @throws {TypeError} 2 arguments required
     * @throws {RangeError} `options.locale` must contain `localize` property
     * @throws {RangeError} `options.locale` must contain `formatLong` property
     * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
     * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
     * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years; see: https://git.io/fxCyr
     * @throws {RangeError} use `yy` instead of `YY` for formatting years; see: https://git.io/fxCyr
     * @throws {RangeError} use `d` instead of `D` for formatting days of the month; see: https://git.io/fxCyr
     * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month; see: https://git.io/fxCyr
     * @throws {RangeError} format string contains an unescaped latin alphabet character
     *
     * @example
     * // Represent 11 February 2014 in middle-endian format:
     * var result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
     * //=> '02/11/2014'
     *
     * @example
     * // Represent 2 July 2014 in Esperanto:
     * import { eoLocale } from 'date-fns/locale/eo'
     * var result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
     *   locale: eoLocale
     * })
     * //=> '2-a de julio 2014'
     *
     * @example
     * // Escape string by single quote characters:
     * var result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
     * //=> "3 o'clock"
     */

    function format(dirtyDate, dirtyFormatStr, dirtyOptions) {
      if (arguments.length < 2) {
        throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
      }

      var formatStr = String(dirtyFormatStr);
      var options = dirtyOptions || {};
      var locale$1 = options.locale || locale;
      var localeFirstWeekContainsDate = locale$1.options && locale$1.options.firstWeekContainsDate;
      var defaultFirstWeekContainsDate = localeFirstWeekContainsDate == null ? 1 : toInteger(localeFirstWeekContainsDate);
      var firstWeekContainsDate = options.firstWeekContainsDate == null ? defaultFirstWeekContainsDate : toInteger(options.firstWeekContainsDate); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

      if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
        throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
      }

      var localeWeekStartsOn = locale$1.options && locale$1.options.weekStartsOn;
      var defaultWeekStartsOn = localeWeekStartsOn == null ? 0 : toInteger(localeWeekStartsOn);
      var weekStartsOn = options.weekStartsOn == null ? defaultWeekStartsOn : toInteger(options.weekStartsOn); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

      if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
        throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
      }

      if (!locale$1.localize) {
        throw new RangeError('locale must contain localize property');
      }

      if (!locale$1.formatLong) {
        throw new RangeError('locale must contain formatLong property');
      }

      var originalDate = toDate(dirtyDate);

      if (!isValid(originalDate)) {
        throw new RangeError('Invalid time value');
      } // Convert the date in system timezone to the same date in UTC+00:00 timezone.
      // This ensures that when UTC functions will be implemented, locales will be compatible with them.
      // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376


      var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
      var utcDate = subMilliseconds(originalDate, timezoneOffset);
      var formatterOptions = {
        firstWeekContainsDate: firstWeekContainsDate,
        weekStartsOn: weekStartsOn,
        locale: locale$1,
        _originalDate: originalDate
      };
      var result = formatStr.match(longFormattingTokensRegExp).map(function (substring) {
        var firstCharacter = substring[0];

        if (firstCharacter === 'p' || firstCharacter === 'P') {
          var longFormatter = longFormatters[firstCharacter];
          return longFormatter(substring, locale$1.formatLong, formatterOptions);
        }

        return substring;
      }).join('').match(formattingTokensRegExp).map(function (substring) {
        // Replace two single quote characters with one single quote character
        if (substring === "''") {
          return "'";
        }

        var firstCharacter = substring[0];

        if (firstCharacter === "'") {
          return cleanEscapedString(substring);
        }

        var formatter = formatters$1[firstCharacter];

        if (formatter) {
          if (!options.useAdditionalWeekYearTokens && isProtectedWeekYearToken(substring)) {
            throwProtectedError(substring);
          }

          if (!options.useAdditionalDayOfYearTokens && isProtectedDayOfYearToken(substring)) {
            throwProtectedError(substring);
          }

          return formatter(utcDate, substring, locale$1.localize, formatterOptions);
        }

        if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
          throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
        }

        return substring;
      }).join('');
      return result;
    }

    function cleanEscapedString(input) {
      return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
    }

    function assign$1(target, dirtyObject) {
      if (target == null) {
        throw new TypeError('assign requires that input parameter not be null or undefined');
      }

      dirtyObject = dirtyObject || {};

      for (var property in dirtyObject) {
        if (dirtyObject.hasOwnProperty(property)) {
          target[property] = dirtyObject[property];
        }
      }

      return target;
    }

    function cloneObject(dirtyObject) {
      return assign$1({}, dirtyObject);
    }

    var MINUTES_IN_DAY = 1440;
    var MINUTES_IN_ALMOST_TWO_DAYS = 2520;
    var MINUTES_IN_MONTH = 43200;
    var MINUTES_IN_TWO_MONTHS = 86400;
    /**
     * @name formatDistance
     * @category Common Helpers
     * @summary Return the distance between the given dates in words.
     *
     * @description
     * Return the distance between the given dates in words.
     *
     * | Distance between dates                                            | Result              |
     * |-------------------------------------------------------------------|---------------------|
     * | 0 ... 30 secs                                                     | less than a minute  |
     * | 30 secs ... 1 min 30 secs                                         | 1 minute            |
     * | 1 min 30 secs ... 44 mins 30 secs                                 | [2..44] minutes     |
     * | 44 mins ... 30 secs ... 89 mins 30 secs                           | about 1 hour        |
     * | 89 mins 30 secs ... 23 hrs 59 mins 30 secs                        | about [2..24] hours |
     * | 23 hrs 59 mins 30 secs ... 41 hrs 59 mins 30 secs                 | 1 day               |
     * | 41 hrs 59 mins 30 secs ... 29 days 23 hrs 59 mins 30 secs         | [2..30] days        |
     * | 29 days 23 hrs 59 mins 30 secs ... 44 days 23 hrs 59 mins 30 secs | about 1 month       |
     * | 44 days 23 hrs 59 mins 30 secs ... 59 days 23 hrs 59 mins 30 secs | about 2 months      |
     * | 59 days 23 hrs 59 mins 30 secs ... 1 yr                           | [2..12] months      |
     * | 1 yr ... 1 yr 3 months                                            | about 1 year        |
     * | 1 yr 3 months ... 1 yr 9 month s                                  | over 1 year         |
     * | 1 yr 9 months ... 2 yrs                                           | almost 2 years      |
     * | N yrs ... N yrs 3 months                                          | about N years       |
     * | N yrs 3 months ... N yrs 9 months                                 | over N years        |
     * | N yrs 9 months ... N+1 yrs                                        | almost N+1 years    |
     *
     * With `options.includeSeconds == true`:
     * | Distance between dates | Result               |
     * |------------------------|----------------------|
     * | 0 secs ... 5 secs      | less than 5 seconds  |
     * | 5 secs ... 10 secs     | less than 10 seconds |
     * | 10 secs ... 20 secs    | less than 20 seconds |
     * | 20 secs ... 40 secs    | half a minute        |
     * | 40 secs ... 60 secs    | less than a minute   |
     * | 60 secs ... 90 secs    | 1 minute             |
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * - The function was renamed from `distanceInWords ` to `formatDistance`
     *   to make its name consistent with `format` and `formatRelative`.
     *
     * - The order of arguments is swapped to make the function
     *   consistent with `differenceIn...` functions.
     *
     *   ```javascript
     *   // Before v2.0.0
     *
     *   distanceInWords(
     *     new Date(1986, 3, 4, 10, 32, 0),
     *     new Date(1986, 3, 4, 11, 32, 0),
     *     { addSuffix: true }
     *   ) //=> 'in about 1 hour'
     *
     *   // v2.0.0 onward
     *
     *   formatDistance(
     *     new Date(1986, 3, 4, 11, 32, 0),
     *     new Date(1986, 3, 4, 10, 32, 0),
     *     { addSuffix: true }
     *   ) //=> 'in about 1 hour'
     *   ```
     *
     * @param {Date|Number} date - the date
     * @param {Date|Number} baseDate - the date to compare with
     * @param {Object} [options] - an object with options.
     * @param {Boolean} [options.includeSeconds=false] - distances less than a minute are more detailed
     * @param {Boolean} [options.addSuffix=false] - result indicates if the second date is earlier or later than the first
     * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
     * @returns {String} the distance in words
     * @throws {TypeError} 2 arguments required
     * @throws {RangeError} `options.locale` must contain `formatDistance` property
     *
     * @example
     * // What is the distance between 2 July 2014 and 1 January 2015?
     * var result = formatDistance(new Date(2014, 6, 2), new Date(2015, 0, 1))
     * //=> '6 months'
     *
     * @example
     * // What is the distance between 1 January 2015 00:00:15
     * // and 1 January 2015 00:00:00, including seconds?
     * var result = formatDistance(
     *   new Date(2015, 0, 1, 0, 0, 15),
     *   new Date(2015, 0, 1, 0, 0, 0),
     *   { includeSeconds: true }
     * )
     * //=> 'less than 20 seconds'
     *
     * @example
     * // What is the distance from 1 January 2016
     * // to 1 January 2015, with a suffix?
     * var result = formatDistance(new Date(2015, 0, 1), new Date(2016, 0, 1), {
     *   addSuffix: true
     * })
     * //=> 'about 1 year ago'
     *
     * @example
     * // What is the distance between 1 August 2016 and 1 January 2015 in Esperanto?
     * import { eoLocale } from 'date-fns/locale/eo'
     * var result = formatDistance(new Date(2016, 7, 1), new Date(2015, 0, 1), {
     *   locale: eoLocale
     * })
     * //=> 'pli ol 1 jaro'
     */

    function formatDistance$1(dirtyDate, dirtyBaseDate, dirtyOptions) {
      if (arguments.length < 2) {
        throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
      }

      var options = dirtyOptions || {};
      var locale$1 = options.locale || locale;

      if (!locale$1.formatDistance) {
        throw new RangeError('locale must contain formatDistance property');
      }

      var comparison = compareAsc(dirtyDate, dirtyBaseDate);

      if (isNaN(comparison)) {
        throw new RangeError('Invalid time value');
      }

      var localizeOptions = cloneObject(options);
      localizeOptions.addSuffix = Boolean(options.addSuffix);
      localizeOptions.comparison = comparison;
      var dateLeft;
      var dateRight;

      if (comparison > 0) {
        dateLeft = toDate(dirtyBaseDate);
        dateRight = toDate(dirtyDate);
      } else {
        dateLeft = toDate(dirtyDate);
        dateRight = toDate(dirtyBaseDate);
      }

      var seconds = differenceInSeconds(dateRight, dateLeft);
      var offsetInSeconds = (getTimezoneOffsetInMilliseconds(dateRight) - getTimezoneOffsetInMilliseconds(dateLeft)) / 1000;
      var minutes = Math.round((seconds - offsetInSeconds) / 60);
      var months; // 0 up to 2 mins

      if (minutes < 2) {
        if (options.includeSeconds) {
          if (seconds < 5) {
            return locale$1.formatDistance('lessThanXSeconds', 5, localizeOptions);
          } else if (seconds < 10) {
            return locale$1.formatDistance('lessThanXSeconds', 10, localizeOptions);
          } else if (seconds < 20) {
            return locale$1.formatDistance('lessThanXSeconds', 20, localizeOptions);
          } else if (seconds < 40) {
            return locale$1.formatDistance('halfAMinute', null, localizeOptions);
          } else if (seconds < 60) {
            return locale$1.formatDistance('lessThanXMinutes', 1, localizeOptions);
          } else {
            return locale$1.formatDistance('xMinutes', 1, localizeOptions);
          }
        } else {
          if (minutes === 0) {
            return locale$1.formatDistance('lessThanXMinutes', 1, localizeOptions);
          } else {
            return locale$1.formatDistance('xMinutes', minutes, localizeOptions);
          }
        } // 2 mins up to 0.75 hrs

      } else if (minutes < 45) {
        return locale$1.formatDistance('xMinutes', minutes, localizeOptions); // 0.75 hrs up to 1.5 hrs
      } else if (minutes < 90) {
        return locale$1.formatDistance('aboutXHours', 1, localizeOptions); // 1.5 hrs up to 24 hrs
      } else if (minutes < MINUTES_IN_DAY) {
        var hours = Math.round(minutes / 60);
        return locale$1.formatDistance('aboutXHours', hours, localizeOptions); // 1 day up to 1.75 days
      } else if (minutes < MINUTES_IN_ALMOST_TWO_DAYS) {
        return locale$1.formatDistance('xDays', 1, localizeOptions); // 1.75 days up to 30 days
      } else if (minutes < MINUTES_IN_MONTH) {
        var days = Math.round(minutes / MINUTES_IN_DAY);
        return locale$1.formatDistance('xDays', days, localizeOptions); // 1 month up to 2 months
      } else if (minutes < MINUTES_IN_TWO_MONTHS) {
        months = Math.round(minutes / MINUTES_IN_MONTH);
        return locale$1.formatDistance('aboutXMonths', months, localizeOptions);
      }

      months = differenceInMonths(dateRight, dateLeft); // 2 months up to 12 months

      if (months < 12) {
        var nearestMonth = Math.round(minutes / MINUTES_IN_MONTH);
        return locale$1.formatDistance('xMonths', nearestMonth, localizeOptions); // 1 year up to max Date
      } else {
        var monthsSinceStartOfYear = months % 12;
        var years = Math.floor(months / 12); // N years up to 1 years 3 months

        if (monthsSinceStartOfYear < 3) {
          return locale$1.formatDistance('aboutXYears', years, localizeOptions); // N years 3 months up to N years 9 months
        } else if (monthsSinceStartOfYear < 9) {
          return locale$1.formatDistance('overXYears', years, localizeOptions); // N years 9 months up to N year 12 months
        } else {
          return locale$1.formatDistance('almostXYears', years + 1, localizeOptions);
        }
      }
    }

    var MINUTES_IN_DAY$1 = 1440;
    var MINUTES_IN_MONTH$1 = 43200;
    var MINUTES_IN_YEAR = 525600;
    /**
     * @name formatDistanceStrict
     * @category Common Helpers
     * @summary Return the distance between the given dates in words.
     *
     * @description
     * Return the distance between the given dates in words, using strict units.
     * This is like `formatDistance`, but does not use helpers like 'almost', 'over',
     * 'less than' and the like.
     *
     * | Distance between dates | Result              |
     * |------------------------|---------------------|
     * | 0 ... 59 secs          | [0..59] seconds     |
     * | 1 ... 59 mins          | [1..59] minutes     |
     * | 1 ... 23 hrs           | [1..23] hours       |
     * | 1 ... 29 days          | [1..29] days        |
     * | 1 ... 11 months        | [1..11] months      |
     * | 1 ... N years          | [1..N]  years       |
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * - The function was renamed from `distanceInWordsStrict` to `formatDistanceStrict`
     *   to make its name consistent with `format` and `formatRelative`.
     *
     * - The order of arguments is swapped to make the function
     *   consistent with `differenceIn...` functions.
     *
     *   ```javascript
     *   // Before v2.0.0
     *
     *   distanceInWordsStrict(
     *     new Date(2015, 0, 2),
     *     new Date(2014, 6, 2)
     *   ) //=> '6 months'
     *
     *   // v2.0.0 onward
     *
     *   formatDistanceStrict(
     *     new Date(2014, 6, 2),
     *     new Date(2015, 0, 2)
     *   ) //=> '6 months'
     *   ```
     *
     * - `partialMethod` option is renamed to `roundingMethod`.
     *
     *   ```javascript
     *   // Before v2.0.0
     *
     *   distanceInWordsStrict(
     *     new Date(1986, 3, 4, 10, 32, 0),
     *     new Date(1986, 3, 4, 10, 33, 1),
     *     { partialMethod: 'ceil' }
     *   ) //=> '2 minutes'
     *
     *   // v2.0.0 onward
     *
     *   formatDistanceStrict(
     *     new Date(1986, 3, 4, 10, 33, 1),
     *     new Date(1986, 3, 4, 10, 32, 0),
     *     { roundingMethod: 'ceil' }
     *   ) //=> '2 minutes'
     *   ```
     *
     * - If `roundingMethod` is not specified, it now defaults to `round` instead of `floor`.
     *
     * - `unit` option now accepts one of the strings:
     *   'second', 'minute', 'hour', 'day', 'month' or 'year' instead of 's', 'm', 'h', 'd', 'M' or 'Y'
     *
     *   ```javascript
     *   // Before v2.0.0
     *
     *   distanceInWordsStrict(
     *     new Date(1986, 3, 4, 10, 32, 0),
     *     new Date(1986, 3, 4, 10, 33, 1),
     *     { unit: 'm' }
     *   )
     *
     *   // v2.0.0 onward
     *
     *   formatDistanceStrict(
     *     new Date(1986, 3, 4, 10, 33, 1),
     *     new Date(1986, 3, 4, 10, 32, 0),
     *     { unit: 'minute' }
     *   )
     *   ```
     *
     * @param {Date|Number} date - the date
     * @param {Date|Number} baseDate - the date to compare with
     * @param {Object} [options] - an object with options.
     * @param {Boolean} [options.addSuffix=false] - result indicates if the second date is earlier or later than the first
     * @param {'second'|'minute'|'hour'|'day'|'month'|'year'} [options.unit] - if specified, will force a unit
     * @param {'floor'|'ceil'|'round'} [options.roundingMethod='round'] - which way to round partial units
     * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
     * @returns {String} the distance in words
     * @throws {TypeError} 2 arguments required
     * @throws {RangeError} `options.roundingMethod` must be 'floor', 'ceil' or 'round'
     * @throws {RangeError} `options.unit` must be 'second', 'minute', 'hour', 'day', 'month' or 'year'
     * @throws {RangeError} `options.locale` must contain `formatDistance` property
     *
     * @example
     * // What is the distance between 2 July 2014 and 1 January 2015?
     * var result = formatDistanceStrict(new Date(2014, 6, 2), new Date(2015, 0, 2))
     * //=> '6 months'
     *
     * @example
     * // What is the distance between 1 January 2015 00:00:15
     * // and 1 January 2015 00:00:00?
     * var result = formatDistanceStrict(
     *   new Date(2015, 0, 1, 0, 0, 15),
     *   new Date(2015, 0, 1, 0, 0, 0)
     * )
     * //=> '15 seconds'
     *
     * @example
     * // What is the distance from 1 January 2016
     * // to 1 January 2015, with a suffix?
     * var result = formatDistanceStrict(new Date(2015, 0, 1), new Date(2016, 0, 1), {
     *   addSuffix: true
     * })
     * //=> '1 year ago'
     *
     * @example
     * // What is the distance from 1 January 2016
     * // to 1 January 2015, in minutes?
     * var result = formatDistanceStrict(new Date(2016, 0, 1), new Date(2015, 0, 1), {
     *   unit: 'minute'
     * })
     * //=> '525600 minutes'
     *
     * @example
     * // What is the distance from 1 January 2015
     * // to 28 January 2015, in months, rounded up?
     * var result = formatDistanceStrict(new Date(2015, 0, 28), new Date(2015, 0, 1), {
     *   unit: 'month',
     *   roundingMethod: 'ceil'
     * })
     * //=> '1 month'
     *
     * @example
     * // What is the distance between 1 August 2016 and 1 January 2015 in Esperanto?
     * import { eoLocale } from 'date-fns/locale/eo'
     * var result = formatDistanceStrict(new Date(2016, 7, 1), new Date(2015, 0, 1), {
     *   locale: eoLocale
     * })
     * //=> '1 jaro'
     */

    function formatDistanceStrict(dirtyDate, dirtyBaseDate, dirtyOptions) {
      if (arguments.length < 2) {
        throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
      }

      var options = dirtyOptions || {};
      var locale$1 = options.locale || locale;

      if (!locale$1.formatDistance) {
        throw new RangeError('locale must contain localize.formatDistance property');
      }

      var comparison = compareAsc(dirtyDate, dirtyBaseDate);

      if (isNaN(comparison)) {
        throw new RangeError('Invalid time value');
      }

      var localizeOptions = cloneObject(options);
      localizeOptions.addSuffix = Boolean(options.addSuffix);
      localizeOptions.comparison = comparison;
      var dateLeft;
      var dateRight;

      if (comparison > 0) {
        dateLeft = toDate(dirtyBaseDate);
        dateRight = toDate(dirtyDate);
      } else {
        dateLeft = toDate(dirtyDate);
        dateRight = toDate(dirtyBaseDate);
      }

      var roundingMethod = options.roundingMethod == null ? 'round' : String(options.roundingMethod);
      var roundingMethodFn;

      if (roundingMethod === 'floor') {
        roundingMethodFn = Math.floor;
      } else if (roundingMethod === 'ceil') {
        roundingMethodFn = Math.ceil;
      } else if (roundingMethod === 'round') {
        roundingMethodFn = Math.round;
      } else {
        throw new RangeError("roundingMethod must be 'floor', 'ceil' or 'round'");
      }

      var seconds = differenceInSeconds(dateRight, dateLeft);
      var offsetInSeconds = (getTimezoneOffsetInMilliseconds(dateRight) - getTimezoneOffsetInMilliseconds(dateLeft)) / 1000;
      var minutes = roundingMethodFn((seconds - offsetInSeconds) / 60);
      var unit;

      if (options.unit == null) {
        if (minutes < 1) {
          unit = 'second';
        } else if (minutes < 60) {
          unit = 'minute';
        } else if (minutes < MINUTES_IN_DAY$1) {
          unit = 'hour';
        } else if (minutes < MINUTES_IN_MONTH$1) {
          unit = 'day';
        } else if (minutes < MINUTES_IN_YEAR) {
          unit = 'month';
        } else {
          unit = 'year';
        }
      } else {
        unit = String(options.unit);
      } // 0 up to 60 seconds


      if (unit === 'second') {
        return locale$1.formatDistance('xSeconds', seconds, localizeOptions); // 1 up to 60 mins
      } else if (unit === 'minute') {
        return locale$1.formatDistance('xMinutes', minutes, localizeOptions); // 1 up to 24 hours
      } else if (unit === 'hour') {
        var hours = roundingMethodFn(minutes / 60);
        return locale$1.formatDistance('xHours', hours, localizeOptions); // 1 up to 30 days
      } else if (unit === 'day') {
        var days = roundingMethodFn(minutes / MINUTES_IN_DAY$1);
        return locale$1.formatDistance('xDays', days, localizeOptions); // 1 up to 12 months
      } else if (unit === 'month') {
        var months = roundingMethodFn(minutes / MINUTES_IN_MONTH$1);
        return locale$1.formatDistance('xMonths', months, localizeOptions); // 1 year up to max Date
      } else if (unit === 'year') {
        var years = roundingMethodFn(minutes / MINUTES_IN_YEAR);
        return locale$1.formatDistance('xYears', years, localizeOptions);
      }

      throw new RangeError("unit must be 'second', 'minute', 'hour', 'day', 'month' or 'year'");
    }

    /**
     * @name formatRelative
     * @category Common Helpers
     * @summary Represent the date in words relative to the given base date.
     *
     * @description
     * Represent the date in words relative to the given base date.
     *
     * | Distance to the base date | Result                    |
     * |---------------------------|---------------------------|
     * | Previous 6 days           | last Sunday at 04:30 AM   |
     * | Last day                  | yesterday at 04:30 AM     |
     * | Same day                  | today at 04:30 AM         |
     * | Next day                  | tomorrow at 04:30 AM      |
     * | Next 6 days               | Sunday at 04:30 AM        |
     * | Other                     | 12/31/2017                |
     *
     * ### v2.0.0 breaking changes:
     *
     * - [Changes that are common for the whole library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
     *
     * @param {Date|Number} date - the date to format
     * @param {Date|Number} baseDate - the date to compare with
     * @param {Object} [options] - an object with options.
     * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
     * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
     * @returns {String} the date in words
     * @throws {TypeError} 2 arguments required
     * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
     * @throws {RangeError} `options.locale` must contain `localize` property
     * @throws {RangeError} `options.locale` must contain `formatLong` property
     * @throws {RangeError} `options.locale` must contain `formatRelative` property
     */

    function formatRelative$1(dirtyDate, dirtyBaseDate, dirtyOptions) {
      if (arguments.length < 2) {
        throw new TypeError('2 arguments required, but only ' + arguments.length + ' present');
      }

      var date = toDate(dirtyDate);
      var baseDate = toDate(dirtyBaseDate);
      var options = dirtyOptions || {};
      var locale$1 = options.locale || locale;

      if (!locale$1.localize) {
        throw new RangeError('locale must contain localize property');
      }

      if (!locale$1.formatLong) {
        throw new RangeError('locale must contain formatLong property');
      }

      if (!locale$1.formatRelative) {
        throw new RangeError('locale must contain formatRelative property');
      }

      var diff = differenceInCalendarDays(date, baseDate);

      if (isNaN(diff)) {
        throw new RangeError('Invalid time value');
      }

      var token;

      if (diff < -6) {
        token = 'other';
      } else if (diff < -1) {
        token = 'lastWeek';
      } else if (diff < 0) {
        token = 'yesterday';
      } else if (diff < 1) {
        token = 'today';
      } else if (diff < 2) {
        token = 'tomorrow';
      } else if (diff < 7) {
        token = 'nextWeek';
      } else {
        token = 'other';
      }

      var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
      var utcBaseDate = subMilliseconds(baseDate, getTimezoneOffsetInMilliseconds(baseDate));
      var formatStr = locale$1.formatRelative(token, utcDate, utcBaseDate, options);
      return format(date, formatStr, options);
    }

    /* admin/src/components/sessions/DeleteSession.svelte generated by Svelte v3.9.2 */

    const file$v = "admin/src/components/sessions/DeleteSession.svelte";

    // (32:0) <ConfirmDelete name="session" on:delete={handleDelete} {errors} {loading} bind:open>
    function create_default_slot$7(ctx) {
    	var span, t0, t1_value = ctx.dateString(ctx.session.startsAt) + "", t1, t2, t3_value = ctx.session.group.name + "", t3, t4;

    	return {
    		c: function create() {
    			span = element("span");
    			t0 = text("the session which takes place ");
    			t1 = text(t1_value);
    			t2 = text(" with ");
    			t3 = text(t3_value);
    			t4 = text(" class?");
    			add_location(span, file$v, 32, 2, 856);
    		},

    		m: function mount(target, anchor) {
    			insert(target, span, anchor);
    			append(span, t0);
    			append(span, t1);
    			append(span, t2);
    			append(span, t3);
    			append(span, t4);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.session) && t1_value !== (t1_value = ctx.dateString(ctx.session.startsAt) + "")) {
    				set_data(t1, t1_value);
    			}

    			if ((changed.session) && t3_value !== (t3_value = ctx.session.group.name + "")) {
    				set_data(t3, t3_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(span);
    			}
    		}
    	};
    }

    function create_fragment$A(ctx) {
    	var updating_open, current;

    	function confirmdelete_open_binding(value) {
    		ctx.confirmdelete_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let confirmdelete_props = {
    		name: "session",
    		errors: ctx.errors,
    		loading: ctx.loading,
    		$$slots: { default: [create_default_slot$7] },
    		$$scope: { ctx }
    	};
    	if (ctx.open !== void 0) {
    		confirmdelete_props.open = ctx.open;
    	}
    	var confirmdelete = new ConfirmDelete({
    		props: confirmdelete_props,
    		$$inline: true
    	});

    	binding_callbacks.push(() => bind(confirmdelete, 'open', confirmdelete_open_binding));
    	confirmdelete.$on("delete", ctx.handleDelete);

    	return {
    		c: function create() {
    			confirmdelete.$$.fragment.c();
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			mount_component(confirmdelete, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var confirmdelete_changes = {};
    			if (changed.errors) confirmdelete_changes.errors = ctx.errors;
    			if (changed.loading) confirmdelete_changes.loading = ctx.loading;
    			if (changed.$$scope || changed.session) confirmdelete_changes.$$scope = { changed, ctx };
    			if (!updating_open && changed.open) {
    				confirmdelete_changes.open = ctx.open;
    			}
    			confirmdelete.$set(confirmdelete_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(confirmdelete.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(confirmdelete.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(confirmdelete, detaching);
    		}
    	};
    }

    function instance$z($$self, $$props, $$invalidate) {
    	

      let { open = false, session = {} } = $$props;
      let loading = false;
      let errors = '';

      const handleDelete = async () => {
        $$invalidate('loading', loading = true);
        try {
          await sessions.remove(session.id);
          $$invalidate('open', open = false);
          notifications.add({ text: `Session deleted`, type: 'success' });
        } catch (error) {
          $$invalidate('errors', errors = error);
          notifications.add({
            text: `Could not delete session'`, type: 'danger'
          });
        } finally {
          $$invalidate('loading', loading = false);
        }
      };
      const dateString = (date) => {
        return formatRelative$1(new Date(date), new Date())
      };

    	const writable_props = ['open', 'session'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<DeleteSession> was created with unknown prop '${key}'`);
    	});

    	function confirmdelete_open_binding(value) {
    		open = value;
    		$$invalidate('open', open);
    	}

    	$$self.$set = $$props => {
    		if ('open' in $$props) $$invalidate('open', open = $$props.open);
    		if ('session' in $$props) $$invalidate('session', session = $$props.session);
    	};

    	return {
    		open,
    		session,
    		loading,
    		errors,
    		handleDelete,
    		dateString,
    		confirmdelete_open_binding
    	};
    }

    class DeleteSession extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$z, create_fragment$A, safe_not_equal, ["open", "session"]);
    	}

    	get open() {
    		throw new Error("<DeleteSession>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set open(value) {
    		throw new Error("<DeleteSession>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get session() {
    		throw new Error("<DeleteSession>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set session(value) {
    		throw new Error("<DeleteSession>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/sessions/SemesterSelect.svelte generated by Svelte v3.9.2 */

    const file$w = "admin/src/components/sessions/SemesterSelect.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.id = list[i].id;
    	child_ctx.name = list[i].name;
    	return child_ctx;
    }

    // (38:4) {:else}
    function create_else_block$8(ctx) {
    	var option;

    	return {
    		c: function create() {
    			option = element("option");
    			option.textContent = "Loading semesters...";
    			option.__value = "";
    			option.value = option.__value;
    			add_location(option, file$w, 38, 4, 907);
    		},

    		m: function mount(target, anchor) {
    			insert(target, option, anchor);
    		},

    		p: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(option);
    			}
    		}
    	};
    }

    // (34:4) {#if $semesters}
    function create_if_block$l(ctx) {
    	var each_blocks = [], each_1_lookup = new Map(), each_1_anchor;

    	var each_value = ctx.$semesters;

    	const get_key = ctx => ctx.id;

    	for (var i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$9(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$9(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();

    			each_1_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(target, anchor);

    			insert(target, each_1_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			const each_value = ctx.$semesters;
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$9, each_1_anchor, get_each_context$9);
    		},

    		d: function destroy(detaching) {
    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d(detaching);

    			if (detaching) {
    				detach(each_1_anchor);
    			}
    		}
    	};
    }

    // (35:4) {#each $semesters as {id, name}
    function create_each_block$9(key_1, ctx) {
    	var option, t_value = ctx.name + "", t, option_value_value;

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = ctx.id;
    			option.value = option.__value;
    			add_location(option, file$w, 35, 4, 844);
    			this.first = option;
    		},

    		m: function mount(target, anchor) {
    			insert(target, option, anchor);
    			append(option, t);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.$semesters) && t_value !== (t_value = ctx.name + "")) {
    				set_data(t, t_value);
    			}

    			if ((changed.$semesters) && option_value_value !== (option_value_value = ctx.id)) {
    				option.__value = option_value_value;
    			}

    			option.value = option.__value;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(option);
    			}
    		}
    	};
    }

    function create_fragment$B(ctx) {
    	var div, select, select_value_value, dispose;

    	function select_block_type(changed, ctx) {
    		if (ctx.$semesters) return create_if_block$l;
    		return create_else_block$8;
    	}

    	var current_block_type = select_block_type(null, ctx);
    	var if_block = current_block_type(ctx);

    	return {
    		c: function create() {
    			div = element("div");
    			select = element("select");
    			if_block.c();
    			add_location(select, file$w, 32, 2, 682);
    			attr(div, "class", "select svelte-t5dn19");
    			add_location(div, file$w, 30, 0, 658);
    			dispose = listen(select, "change", ctx.handleChange);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, select);
    			if_block.m(select, null);
    			ctx.select_binding(select);

    			select_value_value = ctx.$semester && ctx.$semester.id;
    			for (var i = 0; i < select.options.length; i += 1) {
    				var option = select.options[i];

    				if (option.__value === select_value_value) {
    					option.selected = true;
    					break;
    				}
    			}
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(changed, ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);
    				if (if_block) {
    					if_block.c();
    					if_block.m(select, null);
    				}
    			}

    			if ((changed.$semester) && select_value_value !== (select_value_value = ctx.$semester && ctx.$semester.id)) {
    				for (var i = 0; i < select.options.length; i += 1) {
    					var option = select.options[i];

    					if (option.__value === select_value_value) {
    						option.selected = true;
    						break;
    					}
    				}
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			if_block.d();
    			ctx.select_binding(null);
    			dispose();
    		}
    	};
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let $semester, $semesters;

    	validate_store(semester, 'semester');
    	component_subscribe($$self, semester, $$value => { $semester = $$value; $$invalidate('$semester', $semester); });
    	validate_store(semesters, 'semesters');
    	component_subscribe($$self, semesters, $$value => { $semesters = $$value; $$invalidate('$semesters', $semesters); });

    	

      let semesterSelect;

      onMount(async () => {
        await semesters.get();
        if (!$semester) { // not already chosen then get default
          const now = new Date().toISOString();
          const current = $semesters.find(s => s.startDate < now && s.endDate > now);
          if (current) {
            semester.set(current);
          }
        }
      });

      const handleChange = () => {
        const chosen = $semesters.find(s => s.id === semesterSelect.value);
        semester.set(chosen);
      };

    	function select_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('semesterSelect', semesterSelect = $$value);
    		});
    	}

    	return {
    		semesterSelect,
    		handleChange,
    		$semester,
    		$semesters,
    		select_binding
    	};
    }

    class SemesterSelect$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$A, create_fragment$B, safe_not_equal, []);
    	}
    }

    const LessonFields = /* GraphQL */`
  fragment LessonFields on Lesson {
    id
    name
    summaryEN
    summaryZH
    homeworkEN
    homeworkZH
    tags {
      id
      name
    }
    words {
      id
      english
      chinese
    }
    materials {
        id
        title
        type
      }
  }`;

    const GET_LESSONS = /* GraphQL */`
  query ($orderBy: LessonOrderByInput, $where: LessonWhereInput) {
    lessons (orderBy: $orderBy, where: $where) {
      id
      name
      tags {
        id
        name
      }
    }
  }`;

    const LESSON = /* GraphQL */`
  query Lesson($id: ID!) {
    lesson(id: $id){
      ...LessonFields
    }
  }
  ${LessonFields}`;

    const CREATE_LESSON = /* GraphQL */`
  mutation CreateLesson($input: LessonCreateInput!){
    createLesson(input: $input) {
      ...LessonFields
    }
  }
  ${LessonFields}`;

    const UPDATE_LESSON = /* GraphQL */`
  mutation UpdateLesson($input: LessonUpdateInput!, $id: ID!){
    updateLesson(input: $input, id: $id) {
      ...LessonFields
    }
  }
  ${LessonFields}`;

    const DELETE_LESSON = /* GraphQL */`
  mutation DeleteLesson($id: ID!){
    deleteLesson(id: $id) {
      id
    }
  }`;

    const createLessonsStore = () => {
      const { subscribe, set, update } = writable();

      return {
        subscribe,
        get: async (options = {}) => {
          const { orderBy, where } = options;
          const response = await request(GET_LESSONS, { orderBy, where });
          set(response.lessons);
        },
        remove: async id => {
          await request(DELETE_LESSON, { id });
          update(previous => previous && previous.filter(lesson => lesson.id !== id));
        },
        create: async (input) => {
          const response = await request(CREATE_LESSON, { input });
          update(previous => !previous ? [response.createLesson] : [...previous, response.createLesson]);
        },
        patch: async ({ input, id }) => {
          const response = await request(UPDATE_LESSON, { id, input });
          update(previous => !previous ? [response.updateLesson] : previous.map((lesson) => {
            if (lesson.id !== id) return lesson
            return response.updateLesson
          }));
          lesson.update(previous => {
            if (previous && previous.id === id) {
              return response.updateLesson
            }
            return previous
          });
        }
      }
    };

    const lessons = createLessonsStore();

    const createLessonStore = () => {
      const { subscribe, set, update } = writable();

      return {
        subscribe,
        update,
        patch: lessons.patch,
        get: async (id) => {
          const response = await request(LESSON, { id });
          set(response.lesson);
        }
      }
    };

    const lesson = createLessonStore();

    /* admin/src/components/FilterItems.svelte generated by Svelte v3.9.2 */
    const { console: console_1 } = globals;

    const file$x = "admin/src/components/FilterItems.svelte";

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.tag = list[i];
    	return child_ctx;
    }

    // (80:2) {#if tags}
    function create_if_block$m(ctx) {
    	var div3, div2, div0, select, option, each_blocks = [], each_1_lookup = new Map(), t_1, div1, i, dispose;

    	var each_value = ctx.unique(ctx.tags);

    	const get_key = ctx => ctx.tag.id;

    	for (var i_1 = 0; i_1 < each_value.length; i_1 += 1) {
    		let child_ctx = get_each_context$a(ctx, each_value, i_1);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i_1] = create_each_block$a(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			select = element("select");
    			option = element("option");
    			option.textContent = "No tag filter";

    			for (i_1 = 0; i_1 < each_blocks.length; i_1 += 1) each_blocks[i_1].c();

    			t_1 = space();
    			div1 = element("div");
    			i = element("i");
    			option.__value = "";
    			option.value = option.__value;
    			add_location(option, file$x, 84, 12, 2029);
    			if (ctx.tagFilter === void 0) add_render_callback(() => ctx.select_change_handler.call(select));
    			add_location(select, file$x, 83, 10, 1964);
    			attr(div0, "class", "select");
    			add_location(div0, file$x, 82, 8, 1933);
    			attr(i, "class", "fas fa-tag");
    			add_location(i, file$x, 91, 10, 2284);
    			attr(div1, "class", "icon is-small is-left");
    			add_location(div1, file$x, 90, 8, 2238);
    			attr(div2, "class", "control has-icons-left");
    			add_location(div2, file$x, 81, 6, 1888);
    			attr(div3, "class", "field svelte-1038q9s");
    			add_location(div3, file$x, 80, 4, 1862);

    			dispose = [
    				listen(select, "change", ctx.select_change_handler),
    				listen(select, "change", ctx.getItems)
    			];
    		},

    		m: function mount(target, anchor) {
    			insert(target, div3, anchor);
    			append(div3, div2);
    			append(div2, div0);
    			append(div0, select);
    			append(select, option);

    			for (i_1 = 0; i_1 < each_blocks.length; i_1 += 1) each_blocks[i_1].m(select, null);

    			select_option(select, ctx.tagFilter);

    			append(div2, t_1);
    			append(div2, div1);
    			append(div1, i);
    		},

    		p: function update(changed, ctx) {
    			const each_value = ctx.unique(ctx.tags);
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, select, destroy_block, create_each_block$a, null, get_each_context$a);

    			if (changed.tagFilter) select_option(select, ctx.tagFilter);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div3);
    			}

    			for (i_1 = 0; i_1 < each_blocks.length; i_1 += 1) each_blocks[i_1].d();

    			run_all(dispose);
    		}
    	};
    }

    // (86:12) {#each unique(tags) as tag (tag.id)}
    function create_each_block$a(key_1, ctx) {
    	var option, t_value = ctx.tag.name + "", t, option_value_value;

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = ctx.tag.id;
    			option.value = option.__value;
    			add_location(option, file$x, 86, 14, 2132);
    			this.first = option;
    		},

    		m: function mount(target, anchor) {
    			insert(target, option, anchor);
    			append(option, t);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.tags) && t_value !== (t_value = ctx.tag.name + "")) {
    				set_data(t, t_value);
    			}

    			if ((changed.tags) && option_value_value !== (option_value_value = ctx.tag.id)) {
    				option.__value = option_value_value;
    			}

    			option.value = option.__value;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(option);
    			}
    		}
    	};
    }

    function create_fragment$C(ctx) {
    	var section, div1, div0, input, t0, span, i, t1, dispose;

    	var if_block = (ctx.tags) && create_if_block$m(ctx);

    	return {
    		c: function create() {
    			section = element("section");
    			div1 = element("div");
    			div0 = element("div");
    			input = element("input");
    			t0 = space();
    			span = element("span");
    			i = element("i");
    			t1 = space();
    			if (if_block) if_block.c();
    			attr(input, "class", "input");
    			attr(input, "type", "text");
    			attr(input, "placeholder", "Search");
    			add_location(input, file$x, 72, 6, 1628);
    			attr(i, "class", "fas fa-search");
    			add_location(i, file$x, 74, 8, 1780);
    			attr(span, "class", "icon is-small is-left");
    			add_location(span, file$x, 73, 6, 1735);
    			attr(div0, "class", "control search has-icons-left");
    			toggle_class(div0, "is-loading", ctx.loading);
    			add_location(div0, file$x, 71, 4, 1551);
    			attr(div1, "class", "field svelte-1038q9s");
    			add_location(div1, file$x, 70, 2, 1527);
    			attr(section, "class", "filters svelte-1038q9s");
    			add_location(section, file$x, 68, 0, 1498);

    			dispose = [
    				listen(input, "input", ctx.input_input_handler),
    				listen(input, "input", ctx.getItems)
    			];
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, section, anchor);
    			append(section, div1);
    			append(div1, div0);
    			append(div0, input);

    			set_input_value(input, ctx.searchString);

    			append(div0, t0);
    			append(div0, span);
    			append(span, i);
    			append(section, t1);
    			if (if_block) if_block.m(section, null);
    		},

    		p: function update(changed, ctx) {
    			if (changed.searchString && (input.value !== ctx.searchString)) set_input_value(input, ctx.searchString);

    			if (changed.loading) {
    				toggle_class(div0, "is-loading", ctx.loading);
    			}

    			if (ctx.tags) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$m(ctx);
    					if_block.c();
    					if_block.m(section, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(section);
    			}

    			if (if_block) if_block.d();
    			run_all(dispose);
    		}
    	};
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let $store;

    	let searchString = '';
      let loading = false;
      let tagFilter = '';
      let { searchParams = 'name', store } = $$props; validate_store(store, 'store'); component_subscribe($$self, store, $$value => { $store = $$value; $$invalidate('$store', $store); });

      const getItems = async () => {
        const where = {};
        $$invalidate('loading', loading = true);
        if (searchString) {
          where.OR = [];
          if (typeof searchParams === 'string') {
            $$invalidate('searchParams', searchParams = [searchParams]);
          }
          searchParams.forEach(param => {
            const whereItem = {};
            whereItem[param + '_contains'] = searchString;
            where.OR.push(whereItem);
          });
          // where.OR = [{ english_contains: searchString }, { chinese_contains: searchString }]
        }
        if (tagFilter) {
          where.tags_some = { id: tagFilter };
        }
        try {
          await store.get({ where });
        } catch (error) {
          console.error(error);
        } finally {
          $$invalidate('loading', loading = false);
        }
      };

      const unique = tags => {
        if (!tags) return
        return tags.reduce((uniqueones, tag) => {
          if (!uniqueones.find(t => t.id === tag.id)) {
            uniqueones.push(tag);
          }
          return uniqueones
        }, [])
          .sort((a, b) => {
            const nameA = a.name.toUpperCase();
            const nameB = b.name.toUpperCase();
            if (nameA < nameB) return -1
            if (nameA > nameB) return 1
          })
      };

    	const writable_props = ['searchParams', 'store'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console_1.warn(`<FilterItems> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		searchString = this.value;
    		$$invalidate('searchString', searchString);
    	}

    	function select_change_handler() {
    		tagFilter = select_value(this);
    		$$invalidate('tagFilter', tagFilter);
    		$$invalidate('unique', unique);
    		$$invalidate('tags', tags), $$invalidate('$store', $store);
    	}

    	$$self.$set = $$props => {
    		if ('searchParams' in $$props) $$invalidate('searchParams', searchParams = $$props.searchParams);
    		if ('store' in $$props) $$invalidate('store', store = $$props.store);
    	};

    	let tags;

    	$$self.$$.update = ($$dirty = { $store: 1 }) => {
    		if ($$dirty.$store) { $$invalidate('tags', tags = $store && $store.reduce((tags, item) => {
            return [...tags, ...item.tags]
          }, [])); }
    	};

    	return {
    		searchString,
    		loading,
    		tagFilter,
    		searchParams,
    		store,
    		getItems,
    		unique,
    		tags,
    		input_input_handler,
    		select_change_handler
    	};
    }

    class FilterItems extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$B, create_fragment$C, safe_not_equal, ["searchParams", "store"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.store === undefined && !('store' in props)) {
    			console_1.warn("<FilterItems> was created without expected prop 'store'");
    		}
    	}

    	get searchParams() {
    		throw new Error("<FilterItems>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set searchParams(value) {
    		throw new Error("<FilterItems>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get store() {
    		throw new Error("<FilterItems>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set store(value) {
    		throw new Error("<FilterItems>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/sessions/LessonSelect.svelte generated by Svelte v3.9.2 */

    const file$y = "admin/src/components/sessions/LessonSelect.svelte";

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.lesson = list[i];
    	return child_ctx;
    }

    // (29:6) {:else}
    function create_else_block$9(ctx) {
    	var option;

    	return {
    		c: function create() {
    			option = element("option");
    			option.textContent = "Loading lessons...";
    			option.__value = "";
    			option.value = option.__value;
    			add_location(option, file$y, 29, 6, 676);
    		},

    		m: function mount(target, anchor) {
    			insert(target, option, anchor);
    		},

    		p: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(option);
    			}
    		}
    	};
    }

    // (24:6) {#if $lessons}
    function create_if_block$n(ctx) {
    	var option, t0_value = ctx.$lessons.length + "", t0, t1, each_blocks = [], each_1_lookup = new Map(), each_1_anchor;

    	var each_value = ctx.$lessons;

    	const get_key = ctx => ctx.lesson.id;

    	for (var i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$b(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$b(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			option = element("option");
    			t0 = text(t0_value);
    			t1 = text(" matching lessons");

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();

    			each_1_anchor = empty();
    			option.__value = "";
    			option.value = option.__value;
    			add_location(option, file$y, 24, 6, 445);
    		},

    		m: function mount(target, anchor) {
    			insert(target, option, anchor);
    			append(option, t0);
    			append(option, t1);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(target, anchor);

    			insert(target, each_1_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.$lessons) && t0_value !== (t0_value = ctx.$lessons.length + "")) {
    				set_data(t0, t0_value);
    			}

    			const each_value = ctx.$lessons;
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$b, each_1_anchor, get_each_context$b);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(option);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d(detaching);

    			if (detaching) {
    				detach(each_1_anchor);
    			}
    		}
    	};
    }

    // (26:6) {#each $lessons as lesson (lesson.id)}
    function create_each_block$b(key_1, ctx) {
    	var option, t_value = ctx.lesson.name + "", t, option_value_value, option_selected_value;

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = ctx.lesson.id;
    			option.value = option.__value;
    			option.selected = option_selected_value = ctx.lesson.id === ctx.lessonId;
    			add_location(option, file$y, 26, 8, 559);
    			this.first = option;
    		},

    		m: function mount(target, anchor) {
    			insert(target, option, anchor);
    			append(option, t);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.$lessons) && t_value !== (t_value = ctx.lesson.name + "")) {
    				set_data(t, t_value);
    			}

    			if ((changed.$lessons) && option_value_value !== (option_value_value = ctx.lesson.id)) {
    				option.__value = option_value_value;
    			}

    			option.value = option.__value;

    			if ((changed.$lessons || changed.lessonId) && option_selected_value !== (option_selected_value = ctx.lesson.id === ctx.lessonId)) {
    				option.selected = option_selected_value;
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(option);
    			}
    		}
    	};
    }

    function create_fragment$D(ctx) {
    	var div1, t, div0, select, current, dispose;

    	var filteritems = new FilterItems({
    		props: { store: lessons },
    		$$inline: true
    	});

    	function select_block_type(changed, ctx) {
    		if (ctx.$lessons) return create_if_block$n;
    		return create_else_block$9;
    	}

    	var current_block_type = select_block_type(null, ctx);
    	var if_block = current_block_type(ctx);

    	return {
    		c: function create() {
    			div1 = element("div");
    			filteritems.$$.fragment.c();
    			t = space();
    			div0 = element("div");
    			select = element("select");
    			if_block.c();
    			if (ctx.lessonId === void 0) add_render_callback(() => ctx.select_change_handler.call(select));
    			add_location(select, file$y, 22, 4, 387);
    			attr(div0, "class", "select");
    			add_location(div0, file$y, 21, 2, 362);
    			attr(div1, "class", "lesson-select svelte-610gz2");
    			add_location(div1, file$y, 18, 0, 297);
    			dispose = listen(select, "change", ctx.select_change_handler);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div1, anchor);
    			mount_component(filteritems, div1, null);
    			append(div1, t);
    			append(div1, div0);
    			append(div0, select);
    			if_block.m(select, null);

    			select_option(select, ctx.lessonId);

    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var filteritems_changes = {};
    			if (changed.lessons) filteritems_changes.store = lessons;
    			filteritems.$set(filteritems_changes);

    			if (current_block_type === (current_block_type = select_block_type(changed, ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);
    				if (if_block) {
    					if_block.c();
    					if_block.m(select, null);
    				}
    			}

    			if (changed.lessonId) select_option(select, ctx.lessonId);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(filteritems.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(filteritems.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div1);
    			}

    			destroy_component(filteritems);

    			if_block.d();
    			dispose();
    		}
    	};
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let $lessons;

    	validate_store(lessons, 'lessons');
    	component_subscribe($$self, lessons, $$value => { $lessons = $$value; $$invalidate('$lessons', $lessons); });

    	

      let { lessonId = '' } = $$props;

      onMount(async () => {
        await lessons.get();
      });

    	const writable_props = ['lessonId'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<LessonSelect> was created with unknown prop '${key}'`);
    	});

    	function select_change_handler() {
    		lessonId = select_value(this);
    		$$invalidate('lessonId', lessonId);
    	}

    	$$self.$set = $$props => {
    		if ('lessonId' in $$props) $$invalidate('lessonId', lessonId = $$props.lessonId);
    	};

    	return {
    		lessonId,
    		$lessons,
    		select_change_handler
    	};
    }

    class LessonSelect extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$C, create_fragment$D, safe_not_equal, ["lessonId"]);
    	}

    	get lessonId() {
    		throw new Error("<LessonSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lessonId(value) {
    		throw new Error("<LessonSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/sessions/SessionForm.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$a } = globals;

    const file$z = "admin/src/components/sessions/SessionForm.svelte";

    // (49:30) {:else}
    function create_else_block$a(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Add");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (49:18) {#if id}
    function create_if_block_1$b(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Edit");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (58:2) {#if $semester}
    function create_if_block$o(ctx) {
    	var updating_groupId, current;

    	function groupselect_groupId_binding(value) {
    		ctx.groupselect_groupId_binding.call(null, value);
    		updating_groupId = true;
    		add_flush_callback(() => updating_groupId = false);
    	}

    	let groupselect_props = { groups: ctx.$semester.groups, required: true };
    	if (ctx.groupId !== void 0) {
    		groupselect_props.groupId = ctx.groupId;
    	}
    	var groupselect = new GroupSelect({ props: groupselect_props, $$inline: true });

    	binding_callbacks.push(() => bind(groupselect, 'groupId', groupselect_groupId_binding));

    	return {
    		c: function create() {
    			groupselect.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(groupselect, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var groupselect_changes = {};
    			if (changed.$semester) groupselect_changes.groups = ctx.$semester.groups;
    			if (!updating_groupId && changed.groupId) {
    				groupselect_changes.groupId = ctx.groupId;
    			}
    			groupselect.$set(groupselect_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(groupselect.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(groupselect.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(groupselect, detaching);
    		}
    	};
    }

    function create_fragment$E(ctx) {
    	var h2, t0, t1, t2, form_1, updating_value, t3, updating_value_1, t4, label0, t6, t7, t8, label1, t10, updating_lessonId, t11, div, button, t13, input2, current, dispose;

    	function select_block_type(changed, ctx) {
    		if (ctx.id) return create_if_block_1$b;
    		return create_else_block$a;
    	}

    	var current_block_type = select_block_type(null, ctx);
    	var if_block0 = current_block_type(ctx);

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	function input0_value_binding(value) {
    		ctx.input0_value_binding.call(null, value);
    		updating_value = true;
    		add_flush_callback(() => updating_value = false);
    	}

    	let input0_props = {
    		label: "Start time",
    		type: "datetime-local",
    		required: true
    	};
    	if (ctx.startsAt !== void 0) {
    		input0_props.value = ctx.startsAt;
    	}
    	var input0 = new Input({ props: input0_props, $$inline: true });

    	binding_callbacks.push(() => bind(input0, 'value', input0_value_binding));

    	function input1_value_binding(value_1) {
    		ctx.input1_value_binding.call(null, value_1);
    		updating_value_1 = true;
    		add_flush_callback(() => updating_value_1 = false);
    	}

    	let input1_props = {
    		label: "End time",
    		type: "datetime-local",
    		required: true
    	};
    	if (ctx.endsAt !== void 0) {
    		input1_props.value = ctx.endsAt;
    	}
    	var input1 = new Input({ props: input1_props, $$inline: true });

    	binding_callbacks.push(() => bind(input1, 'value', input1_value_binding));

    	var semesterselect = new SemesterSelect$1({ $$inline: true });

    	var if_block1 = (ctx.$semester) && create_if_block$o(ctx);

    	function lessonselect_lessonId_binding(value_2) {
    		ctx.lessonselect_lessonId_binding.call(null, value_2);
    		updating_lessonId = true;
    		add_flush_callback(() => updating_lessonId = false);
    	}

    	let lessonselect_props = {};
    	if (ctx.lessonId !== void 0) {
    		lessonselect_props.lessonId = ctx.lessonId;
    	}
    	var lessonselect = new LessonSelect({
    		props: lessonselect_props,
    		$$inline: true
    	});

    	binding_callbacks.push(() => bind(lessonselect, 'lessonId', lessonselect_lessonId_binding));

    	return {
    		c: function create() {
    			h2 = element("h2");
    			if_block0.c();
    			t0 = text(" a class session");
    			t1 = space();
    			error.$$.fragment.c();
    			t2 = space();
    			form_1 = element("form");
    			input0.$$.fragment.c();
    			t3 = space();
    			input1.$$.fragment.c();
    			t4 = space();
    			label0 = element("label");
    			label0.textContent = "Semester & Group";
    			t6 = space();
    			semesterselect.$$.fragment.c();
    			t7 = space();
    			if (if_block1) if_block1.c();
    			t8 = space();
    			label1 = element("label");
    			label1.textContent = "Add lesson";
    			t10 = space();
    			lessonselect.$$.fragment.c();
    			t11 = space();
    			div = element("div");
    			button = element("button");
    			button.textContent = "Save";
    			t13 = space();
    			input2 = element("input");
    			attr(h2, "class", "title");
    			add_location(h2, file$z, 48, 0, 1272);
    			attr(label0, "class", "label");
    			add_location(label0, file$z, 53, 1, 1607);
    			attr(label1, "class", "label");
    			add_location(label1, file$z, 61, 2, 1777);
    			attr(button, "class", "button is-primary");
    			attr(button, "type", "submit");
    			toggle_class(button, "is-loading", ctx.loading);
    			add_location(button, file$z, 66, 6, 1882);
    			attr(input2, "class", "button");
    			attr(input2, "type", "reset");
    			input2.value = "Cancel";
    			add_location(input2, file$z, 68, 6, 2009);
    			attr(div, "class", "buttons svelte-jsaq7t");
    			add_location(div, file$z, 65, 2, 1854);
    			form_1.noValidate = true;
    			add_location(form_1, file$z, 50, 0, 1358);

    			dispose = [
    				listen(form_1, "submit", prevent_default(ctx.handleSubmit)),
    				listen(form_1, "reset", ctx.reset_handler)
    			];
    		},

    		l: function claim(nodes) {
    			throw new Error_1$a("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, h2, anchor);
    			if_block0.m(h2, null);
    			append(h2, t0);
    			insert(target, t1, anchor);
    			mount_component(error, target, anchor);
    			insert(target, t2, anchor);
    			insert(target, form_1, anchor);
    			mount_component(input0, form_1, null);
    			append(form_1, t3);
    			mount_component(input1, form_1, null);
    			append(form_1, t4);
    			append(form_1, label0);
    			append(form_1, t6);
    			mount_component(semesterselect, form_1, null);
    			append(form_1, t7);
    			if (if_block1) if_block1.m(form_1, null);
    			append(form_1, t8);
    			append(form_1, label1);
    			append(form_1, t10);
    			mount_component(lessonselect, form_1, null);
    			append(form_1, t11);
    			append(form_1, div);
    			append(div, button);
    			ctx.button_binding(button);
    			append(div, t13);
    			append(div, input2);
    			ctx.form_1_binding(form_1);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type !== (current_block_type = select_block_type(changed, ctx))) {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);
    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(h2, t0);
    				}
    			}

    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);

    			var input0_changes = {};
    			if (!updating_value && changed.startsAt) {
    				input0_changes.value = ctx.startsAt;
    			}
    			input0.$set(input0_changes);

    			var input1_changes = {};
    			if (!updating_value_1 && changed.endsAt) {
    				input1_changes.value = ctx.endsAt;
    			}
    			input1.$set(input1_changes);

    			if (ctx.$semester) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    					transition_in(if_block1, 1);
    				} else {
    					if_block1 = create_if_block$o(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(form_1, t8);
    				}
    			} else if (if_block1) {
    				group_outros();
    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});
    				check_outros();
    			}

    			var lessonselect_changes = {};
    			if (!updating_lessonId && changed.lessonId) {
    				lessonselect_changes.lessonId = ctx.lessonId;
    			}
    			lessonselect.$set(lessonselect_changes);

    			if (changed.loading) {
    				toggle_class(button, "is-loading", ctx.loading);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);

    			transition_in(input0.$$.fragment, local);

    			transition_in(input1.$$.fragment, local);

    			transition_in(semesterselect.$$.fragment, local);

    			transition_in(if_block1);

    			transition_in(lessonselect.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			transition_out(input0.$$.fragment, local);
    			transition_out(input1.$$.fragment, local);
    			transition_out(semesterselect.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(lessonselect.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h2);
    			}

    			if_block0.d();

    			if (detaching) {
    				detach(t1);
    			}

    			destroy_component(error, detaching);

    			if (detaching) {
    				detach(t2);
    				detach(form_1);
    			}

    			destroy_component(input0);

    			destroy_component(input1);

    			destroy_component(semesterselect);

    			if (if_block1) if_block1.d();

    			destroy_component(lessonselect);

    			ctx.button_binding(null);
    			ctx.form_1_binding(null);
    			run_all(dispose);
    		}
    	};
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let $semester;

    	validate_store(semester, 'semester');
    	component_subscribe($$self, semester, $$value => { $semester = $$value; $$invalidate('$semester', $semester); });

    	

      const dispatch = createEventDispatcher();
      const defaultStart = new Date();
      defaultStart.setHours(19);
      defaultStart.setMinutes(0);
      const defaultEnd = new Date();
      defaultEnd.setHours(20);
      defaultEnd.setMinutes(30);

      let { errors, loading = false } = $$props;
      let form;
      let saveButton;
      let { id = '', groupId = '', startsAt = format(defaultStart, "yyyy-MM-dd'T'HH:mm"), endsAt = format(defaultEnd, "yyyy-MM-dd'T'HH:mm"), lessonId = '' } = $$props;

      const handleSubmit = () => {
        const isValid = form.checkValidity();
        if (!isValid) {
          notifications.add({
            text: 'Please fix form errors first.',
            type: 'danger'
          });
          return
        }
        dispatch('submit', { id, groupId, startsAt, endsAt, lessonId });
      };

    	const writable_props = ['errors', 'loading', 'id', 'groupId', 'startsAt', 'endsAt', 'lessonId'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<SessionForm> was created with unknown prop '${key}'`);
    	});

    	function reset_handler(event) {
    		bubble($$self, event);
    	}

    	function input0_value_binding(value) {
    		startsAt = value;
    		$$invalidate('startsAt', startsAt);
    	}

    	function input1_value_binding(value_1) {
    		endsAt = value_1;
    		$$invalidate('endsAt', endsAt);
    	}

    	function groupselect_groupId_binding(value) {
    		groupId = value;
    		$$invalidate('groupId', groupId);
    	}

    	function lessonselect_lessonId_binding(value_2) {
    		lessonId = value_2;
    		$$invalidate('lessonId', lessonId);
    	}

    	function button_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('saveButton', saveButton = $$value);
    		});
    	}

    	function form_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('form', form = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ('errors' in $$props) $$invalidate('errors', errors = $$props.errors);
    		if ('loading' in $$props) $$invalidate('loading', loading = $$props.loading);
    		if ('id' in $$props) $$invalidate('id', id = $$props.id);
    		if ('groupId' in $$props) $$invalidate('groupId', groupId = $$props.groupId);
    		if ('startsAt' in $$props) $$invalidate('startsAt', startsAt = $$props.startsAt);
    		if ('endsAt' in $$props) $$invalidate('endsAt', endsAt = $$props.endsAt);
    		if ('lessonId' in $$props) $$invalidate('lessonId', lessonId = $$props.lessonId);
    	};

    	return {
    		errors,
    		loading,
    		form,
    		saveButton,
    		id,
    		groupId,
    		startsAt,
    		endsAt,
    		lessonId,
    		handleSubmit,
    		reset_handler,
    		$semester,
    		input0_value_binding,
    		input1_value_binding,
    		groupselect_groupId_binding,
    		lessonselect_lessonId_binding,
    		button_binding,
    		form_1_binding
    	};
    }

    class SessionForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$D, create_fragment$E, safe_not_equal, ["errors", "loading", "id", "groupId", "startsAt", "endsAt", "lessonId"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.errors === undefined && !('errors' in props)) {
    			console.warn("<SessionForm> was created without expected prop 'errors'");
    		}
    	}

    	get errors() {
    		throw new Error_1$a("<SessionForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set errors(value) {
    		throw new Error_1$a("<SessionForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loading() {
    		throw new Error_1$a("<SessionForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loading(value) {
    		throw new Error_1$a("<SessionForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error_1$a("<SessionForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error_1$a("<SessionForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get groupId() {
    		throw new Error_1$a("<SessionForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set groupId(value) {
    		throw new Error_1$a("<SessionForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get startsAt() {
    		throw new Error_1$a("<SessionForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set startsAt(value) {
    		throw new Error_1$a("<SessionForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get endsAt() {
    		throw new Error_1$a("<SessionForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set endsAt(value) {
    		throw new Error_1$a("<SessionForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lessonId() {
    		throw new Error_1$a("<SessionForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lessonId(value) {
    		throw new Error_1$a("<SessionForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/sessions/EditSession.svelte generated by Svelte v3.9.2 */

    function create_fragment$F(ctx) {
    	var current;

    	var sessionform = new SessionForm({
    		props: {
    		errors: ctx.errors,
    		groupId: ctx.session.group.id,
    		startsAt: ctx.startsAtLocal,
    		endsAt: ctx.endsAtLocal,
    		id: ctx.session.id,
    		lessonId: ctx.lessonId,
    		loading: ctx.loading
    	},
    		$$inline: true
    	});
    	sessionform.$on("submit", ctx.save);
    	sessionform.$on("reset", ctx.reset);

    	return {
    		c: function create() {
    			sessionform.$$.fragment.c();
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			mount_component(sessionform, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var sessionform_changes = {};
    			if (changed.errors) sessionform_changes.errors = ctx.errors;
    			if (changed.session) sessionform_changes.groupId = ctx.session.group.id;
    			if (changed.startsAtLocal) sessionform_changes.startsAt = ctx.startsAtLocal;
    			if (changed.endsAtLocal) sessionform_changes.endsAt = ctx.endsAtLocal;
    			if (changed.session) sessionform_changes.id = ctx.session.id;
    			if (changed.lessonId) sessionform_changes.lessonId = ctx.lessonId;
    			if (changed.loading) sessionform_changes.loading = ctx.loading;
    			sessionform.$set(sessionform_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(sessionform.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(sessionform.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(sessionform, detaching);
    		}
    	};
    }

    function instance$E($$self, $$props, $$invalidate) {
    	

      let errors = '';
      let loading = false;
      let { open = false, session = {} } = $$props;
      const reset = () => {
        $$invalidate('errors', errors = '');
        $$invalidate('open', open = false);
      };

      const save = async ({ detail }) => {
        const { id, groupId, lessonId, ...input } = detail;
        input.startsAt = new Date(input.startsAt).toISOString();
        input.endsAt = new Date(input.endsAt).toISOString();
        $$invalidate('loading', loading = true);
        try {
          const updatedSession = await sessions.patch(id, input, groupId, lessonId);
          const date = formatRelative$1(new Date(input.startsAt), new Date(), { addSuffix: true });
          notifications.add({ text: `Updated session to ${date} with ${updatedSession.group.name} class`, type: 'success' });
          reset();
        } catch (error) {
          $$invalidate('errors', errors = error);
          notifications.add({ text: "Couldn't save changes to session", type: 'danger' });
        } finally {
          $$invalidate('loading', loading = false);
        }
      };

    	const writable_props = ['open', 'session'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<EditSession> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('open' in $$props) $$invalidate('open', open = $$props.open);
    		if ('session' in $$props) $$invalidate('session', session = $$props.session);
    	};

    	let startsAtLocal, endsAtLocal, lessonId;

    	$$self.$$.update = ($$dirty = { session: 1 }) => {
    		if ($$dirty.session) { $$invalidate('startsAtLocal', startsAtLocal = format(new Date(session.startsAt), "yyyy-MM-dd'T'HH:mm")); }
    		if ($$dirty.session) { $$invalidate('endsAtLocal', endsAtLocal = format(new Date(session.endsAt), "yyyy-MM-dd'T'HH:mm")); }
    		if ($$dirty.session) { $$invalidate('lessonId', lessonId = session.lesson ? session.lesson.id : null); }
    	};

    	return {
    		errors,
    		loading,
    		open,
    		session,
    		reset,
    		save,
    		startsAtLocal,
    		endsAtLocal,
    		lessonId
    	};
    }

    class EditSession extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$E, create_fragment$F, safe_not_equal, ["open", "session"]);
    	}

    	get open() {
    		throw new Error("<EditSession>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set open(value) {
    		throw new Error("<EditSession>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get session() {
    		throw new Error("<EditSession>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set session(value) {
    		throw new Error("<EditSession>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/sessions/SessionListItem.svelte generated by Svelte v3.9.2 */

    const file$A = "admin/src/components/sessions/SessionListItem.svelte";

    // (70:0) {#if session}
    function create_if_block_2$5(ctx) {
    	var li, show_if, t0, div, t1, current;

    	function select_block_type(changed, ctx) {
    		if ((show_if == null) || changed.session) show_if = !!(ctx.isCurrentOrPast(ctx.session.startsAt));
    		if (show_if) return create_if_block_3$2;
    		return create_else_block$b;
    	}

    	var current_block_type = select_block_type(null, ctx);
    	var if_block = current_block_type(ctx);

    	var iconbutton0 = new IconButton({ props: { name: "edit" }, $$inline: true });
    	iconbutton0.$on("click", ctx.click_handler_2);

    	var iconbutton1 = new IconButton({ props: { name: "minus" }, $$inline: true });
    	iconbutton1.$on("click", ctx.click_handler_3);

    	return {
    		c: function create() {
    			li = element("li");
    			if_block.c();
    			t0 = space();
    			div = element("div");
    			iconbutton0.$$.fragment.c();
    			t1 = space();
    			iconbutton1.$$.fragment.c();
    			attr(div, "class", "buttons svelte-ik776v");
    			add_location(div, file$A, 83, 2, 2240);
    			attr(li, "class", "svelte-ik776v");
    			add_location(li, file$A, 70, 0, 1671);
    		},

    		m: function mount(target, anchor) {
    			insert(target, li, anchor);
    			if_block.m(li, null);
    			append(li, t0);
    			append(li, div);
    			mount_component(iconbutton0, div, null);
    			append(div, t1);
    			mount_component(iconbutton1, div, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type(changed, ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);
    				if (if_block) {
    					if_block.c();
    					if_block.m(li, t0);
    				}
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(iconbutton0.$$.fragment, local);

    			transition_in(iconbutton1.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(iconbutton0.$$.fragment, local);
    			transition_out(iconbutton1.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(li);
    			}

    			if_block.d();

    			destroy_component(iconbutton0);

    			destroy_component(iconbutton1);
    		}
    	};
    }

    // (78:0) {:else}
    function create_else_block$b(ctx) {
    	var span, t0_value = ctx.session.group.name + "", t0, t1, t2_value = ctx.relativeDate(ctx.session.startsAt, ctx.time) + "", t2, t3, t4_value = ctx.maybeDate(ctx.session.startsAt) || ctx.formatTime(ctx.session.startsAt) + "", t4, t5, t6_value = ctx.formatTime(ctx.session.endsAt) + "", t6, dispose;

    	return {
    		c: function create() {
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(" class ");
    			t2 = text(t2_value);
    			t3 = text(", ");
    			t4 = text(t4_value);
    			t5 = text(" to ");
    			t6 = text(t6_value);
    			add_location(span, file$A, 78, 0, 2001);
    			dispose = listen(span, "click", ctx.click_handler_1);
    		},

    		m: function mount(target, anchor) {
    			insert(target, span, anchor);
    			append(span, t0);
    			append(span, t1);
    			append(span, t2);
    			append(span, t3);
    			append(span, t4);
    			append(span, t5);
    			append(span, t6);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.session) && t0_value !== (t0_value = ctx.session.group.name + "")) {
    				set_data(t0, t0_value);
    			}

    			if ((changed.session || changed.time) && t2_value !== (t2_value = ctx.relativeDate(ctx.session.startsAt, ctx.time) + "")) {
    				set_data(t2, t2_value);
    			}

    			if ((changed.session) && t4_value !== (t4_value = ctx.maybeDate(ctx.session.startsAt) || ctx.formatTime(ctx.session.startsAt) + "")) {
    				set_data(t4, t4_value);
    			}

    			if ((changed.session) && t6_value !== (t6_value = ctx.formatTime(ctx.session.endsAt) + "")) {
    				set_data(t6, t6_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(span);
    			}

    			dispose();
    		}
    	};
    }

    // (72:2) {#if isCurrentOrPast(session.startsAt)}
    function create_if_block_3$2(ctx) {
    	var a, span, t0_value = ctx.session.group.name + "", t0, t1, t2_value = ctx.relativeDate(ctx.session.startsAt, ctx.time) + "", t2, t3, t4_value = ctx.maybeDate(ctx.session.startsAt) || ctx.formatTime(ctx.session.startsAt) + "", t4, t5, t6_value = ctx.formatTime(ctx.session.endsAt) + "", t6, a_href_value, dispose;

    	return {
    		c: function create() {
    			a = element("a");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(" class ");
    			t2 = text(t2_value);
    			t3 = text(", ");
    			t4 = text(t4_value);
    			t5 = text(" to ");
    			t6 = text(t6_value);
    			add_location(span, file$A, 73, 4, 1758);
    			attr(a, "href", a_href_value = "#/session/" + ctx.session.id);
    			add_location(a, file$A, 72, 2, 1720);
    			dispose = listen(span, "click", ctx.click_handler);
    		},

    		m: function mount(target, anchor) {
    			insert(target, a, anchor);
    			append(a, span);
    			append(span, t0);
    			append(span, t1);
    			append(span, t2);
    			append(span, t3);
    			append(span, t4);
    			append(span, t5);
    			append(span, t6);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.session) && t0_value !== (t0_value = ctx.session.group.name + "")) {
    				set_data(t0, t0_value);
    			}

    			if ((changed.session || changed.time) && t2_value !== (t2_value = ctx.relativeDate(ctx.session.startsAt, ctx.time) + "")) {
    				set_data(t2, t2_value);
    			}

    			if ((changed.session) && t4_value !== (t4_value = ctx.maybeDate(ctx.session.startsAt) || ctx.formatTime(ctx.session.startsAt) + "")) {
    				set_data(t4, t4_value);
    			}

    			if ((changed.session) && t6_value !== (t6_value = ctx.formatTime(ctx.session.endsAt) + "")) {
    				set_data(t6, t6_value);
    			}

    			if ((changed.session) && a_href_value !== (a_href_value = "#/session/" + ctx.session.id)) {
    				attr(a, "href", a_href_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(a);
    			}

    			dispose();
    		}
    	};
    }

    // (92:2) {#if showDelete}
    function create_if_block_1$c(ctx) {
    	var updating_open, current;

    	function deletesession_open_binding(value) {
    		ctx.deletesession_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let deletesession_props = { session: ctx.session };
    	if (ctx.showDelete !== void 0) {
    		deletesession_props.open = ctx.showDelete;
    	}
    	var deletesession = new DeleteSession({
    		props: deletesession_props,
    		$$inline: true
    	});

    	binding_callbacks.push(() => bind(deletesession, 'open', deletesession_open_binding));

    	return {
    		c: function create() {
    			deletesession.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(deletesession, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var deletesession_changes = {};
    			if (changed.session) deletesession_changes.session = ctx.session;
    			if (!updating_open && changed.showDelete) {
    				deletesession_changes.open = ctx.showDelete;
    			}
    			deletesession.$set(deletesession_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(deletesession.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(deletesession.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(deletesession, detaching);
    		}
    	};
    }

    // (91:0) <Modal bind:open={showDelete}>
    function create_default_slot_1$2(ctx) {
    	var if_block_anchor, current;

    	var if_block = (ctx.showDelete) && create_if_block_1$c(ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.showDelete) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block_1$c(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    // (98:2) {#if showEdit}
    function create_if_block$p(ctx) {
    	var updating_open, current;

    	function editsession_open_binding(value) {
    		ctx.editsession_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let editsession_props = { session: ctx.session };
    	if (ctx.showEdit !== void 0) {
    		editsession_props.open = ctx.showEdit;
    	}
    	var editsession = new EditSession({ props: editsession_props, $$inline: true });

    	binding_callbacks.push(() => bind(editsession, 'open', editsession_open_binding));

    	return {
    		c: function create() {
    			editsession.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(editsession, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var editsession_changes = {};
    			if (changed.session) editsession_changes.session = ctx.session;
    			if (!updating_open && changed.showEdit) {
    				editsession_changes.open = ctx.showEdit;
    			}
    			editsession.$set(editsession_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(editsession.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(editsession.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(editsession, detaching);
    		}
    	};
    }

    // (97:0) <Modal bind:open={showEdit}>
    function create_default_slot$8(ctx) {
    	var if_block_anchor, current;

    	var if_block = (ctx.showEdit) && create_if_block$p(ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.showEdit) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$p(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function create_fragment$G(ctx) {
    	var t0, updating_open, t1, updating_open_1, current;

    	var if_block = (ctx.session) && create_if_block_2$5(ctx);

    	function modal0_open_binding(value) {
    		ctx.modal0_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let modal0_props = {
    		$$slots: { default: [create_default_slot_1$2] },
    		$$scope: { ctx }
    	};
    	if (ctx.showDelete !== void 0) {
    		modal0_props.open = ctx.showDelete;
    	}
    	var modal0 = new Modal({ props: modal0_props, $$inline: true });

    	binding_callbacks.push(() => bind(modal0, 'open', modal0_open_binding));

    	function modal1_open_binding(value_1) {
    		ctx.modal1_open_binding.call(null, value_1);
    		updating_open_1 = true;
    		add_flush_callback(() => updating_open_1 = false);
    	}

    	let modal1_props = {
    		$$slots: { default: [create_default_slot$8] },
    		$$scope: { ctx }
    	};
    	if (ctx.showEdit !== void 0) {
    		modal1_props.open = ctx.showEdit;
    	}
    	var modal1 = new Modal({ props: modal1_props, $$inline: true });

    	binding_callbacks.push(() => bind(modal1, 'open', modal1_open_binding));

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			t0 = space();
    			modal0.$$.fragment.c();
    			t1 = space();
    			modal1.$$.fragment.c();
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, t0, anchor);
    			mount_component(modal0, target, anchor);
    			insert(target, t1, anchor);
    			mount_component(modal1, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.session) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block_2$5(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t0.parentNode, t0);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}

    			var modal0_changes = {};
    			if (changed.$$scope || changed.showDelete || changed.session) modal0_changes.$$scope = { changed, ctx };
    			if (!updating_open && changed.showDelete) {
    				modal0_changes.open = ctx.showDelete;
    			}
    			modal0.$set(modal0_changes);

    			var modal1_changes = {};
    			if (changed.$$scope || changed.showEdit || changed.session) modal1_changes.$$scope = { changed, ctx };
    			if (!updating_open_1 && changed.showEdit) {
    				modal1_changes.open = ctx.showEdit;
    			}
    			modal1.$set(modal1_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);

    			transition_in(modal0.$$.fragment, local);

    			transition_in(modal1.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(modal0.$$.fragment, local);
    			transition_out(modal1.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(t0);
    			}

    			destroy_component(modal0, detaching);

    			if (detaching) {
    				detach(t1);
    			}

    			destroy_component(modal1, detaching);
    		}
    	};
    }

    function instance$F($$self, $$props, $$invalidate) {
    	

      let { session } = $$props;
      let showDelete = false;
      let showEdit = false;
      let showActions = false;
      let { time = new Date() } = $$props;

      const relativeDate = (date, time) => {
        if (!date) return
        return formatDistance$1(new Date(date), new Date(), { addSuffix: true })
      };

      const formatTime = (time) => {
        if (!time) return
        const dateTime = new Date(time);
        if (dateTime.getMinutes() === 0) {
          return format(dateTime, 'h b')
        }
        return format(dateTime, 'p')
      };

      const maybeDate = (date) => {
        const timeDiff = (new Date(date) - new Date());
        if (Math.abs(timeDiff) > 8.64e7) { // more than a day ago
          const dateString = formatRelative$1(new Date(date), new Date());
          return ['AM', 'PM'].includes(dateString.slice(-2))
            ? dateString
            : `${dateString} ${formatTime(date)}`
        }
        return ''
      };
      const isCurrentOrPast = (date) => {
        const now = new Date();
        const in30 = new Date(now.valueOf() + 30 * 6e+4);
        return (date < in30.toISOString())
      };

    	const writable_props = ['session', 'time'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<SessionListItem> was created with unknown prop '${key}'`);
    	});

    	function click_handler() { showActions = !showActions; $$invalidate('showActions', showActions); }

    	function click_handler_1() { showActions = !showActions; $$invalidate('showActions', showActions); }

    	function click_handler_2() { showEdit = true; $$invalidate('showEdit', showEdit); }

    	function click_handler_3() { showDelete = true; $$invalidate('showDelete', showDelete); }

    	function deletesession_open_binding(value) {
    		showDelete = value;
    		$$invalidate('showDelete', showDelete);
    	}

    	function modal0_open_binding(value) {
    		showDelete = value;
    		$$invalidate('showDelete', showDelete);
    	}

    	function editsession_open_binding(value) {
    		showEdit = value;
    		$$invalidate('showEdit', showEdit);
    	}

    	function modal1_open_binding(value_1) {
    		showEdit = value_1;
    		$$invalidate('showEdit', showEdit);
    	}

    	$$self.$set = $$props => {
    		if ('session' in $$props) $$invalidate('session', session = $$props.session);
    		if ('time' in $$props) $$invalidate('time', time = $$props.time);
    	};

    	return {
    		session,
    		showDelete,
    		showEdit,
    		showActions,
    		time,
    		relativeDate,
    		formatTime,
    		maybeDate,
    		isCurrentOrPast,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		deletesession_open_binding,
    		modal0_open_binding,
    		editsession_open_binding,
    		modal1_open_binding
    	};
    }

    class SessionListItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$F, create_fragment$G, safe_not_equal, ["session", "time"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.session === undefined && !('session' in props)) {
    			console.warn("<SessionListItem> was created without expected prop 'session'");
    		}
    	}

    	get session() {
    		throw new Error("<SessionListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set session(value) {
    		throw new Error("<SessionListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get time() {
    		throw new Error("<SessionListItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set time(value) {
    		throw new Error("<SessionListItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/sessions/UpcomingSessions.svelte generated by Svelte v3.9.2 */

    const file$B = "admin/src/components/sessions/UpcomingSessions.svelte";

    function get_each_context$c(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.session = list[i];
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.session = list[i];
    	return child_ctx;
    }

    // (22:0) {:else}
    function create_else_block$c(ctx) {
    	var current;

    	var loading = new Loading({
    		props: { what: "today's lessons" },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			loading.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},

    		p: noop,

    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};
    }

    // (8:0) {#if $todaysSessions}
    function create_if_block$q(ctx) {
    	var t, if_block1_anchor, current;

    	var if_block0 = (ctx.$todaysSessions.soon) && create_if_block_2$6(ctx);

    	var if_block1 = (ctx.$todaysSessions.later) && create_if_block_1$d(ctx);

    	return {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert(target, if_block1_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.$todaysSessions.soon) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    					transition_in(if_block0, 1);
    				} else {
    					if_block0 = create_if_block_2$6(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				group_outros();
    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});
    				check_outros();
    			}

    			if (ctx.$todaysSessions.later) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    					transition_in(if_block1, 1);
    				} else {
    					if_block1 = create_if_block_1$d(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();
    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);

    			if (detaching) {
    				detach(t);
    			}

    			if (if_block1) if_block1.d(detaching);

    			if (detaching) {
    				detach(if_block1_anchor);
    			}
    		}
    	};
    }

    // (9:2) {#if $todaysSessions.soon}
    function create_if_block_2$6(ctx) {
    	var h3, t0_value = ctx.$todaysSessions.soon.length + "", t0, t1, t2_value = ctx.$todaysSessions.soon.length - 1 && 's' || '' + "", t2, t3, t4, each_blocks = [], each_1_lookup = new Map(), each_1_anchor, current;

    	var each_value_1 = ctx.$todaysSessions.soon;

    	const get_key = ctx => ctx.session.id;

    	for (var i = 0; i < each_value_1.length; i += 1) {
    		let child_ctx = get_each_context_1$1(ctx, each_value_1, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_1$1(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			h3 = element("h3");
    			t0 = text(t0_value);
    			t1 = text(" Lesson");
    			t2 = text(t2_value);
    			t3 = text(" within 30 minutes");
    			t4 = space();

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();

    			each_1_anchor = empty();
    			attr(h3, "class", "title is-5");
    			add_location(h3, file$B, 9, 4, 258);
    		},

    		m: function mount(target, anchor) {
    			insert(target, h3, anchor);
    			append(h3, t0);
    			append(h3, t1);
    			append(h3, t2);
    			append(h3, t3);
    			insert(target, t4, anchor);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(target, anchor);

    			insert(target, each_1_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if ((!current || changed.$todaysSessions) && t0_value !== (t0_value = ctx.$todaysSessions.soon.length + "")) {
    				set_data(t0, t0_value);
    			}

    			if ((!current || changed.$todaysSessions) && t2_value !== (t2_value = ctx.$todaysSessions.soon.length - 1 && 's' || '' + "")) {
    				set_data(t2, t2_value);
    			}

    			const each_value_1 = ctx.$todaysSessions.soon;

    			group_outros();
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value_1, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_1$1, each_1_anchor, get_each_context_1$1);
    			check_outros();
    		},

    		i: function intro(local) {
    			if (current) return;
    			for (var i = 0; i < each_value_1.length; i += 1) transition_in(each_blocks[i]);

    			current = true;
    		},

    		o: function outro(local) {
    			for (i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h3);
    				detach(t4);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d(detaching);

    			if (detaching) {
    				detach(each_1_anchor);
    			}
    		}
    	};
    }

    // (11:4) {#each $todaysSessions.soon as session (session.id)}
    function create_each_block_1$1(key_1, ctx) {
    	var first, current;

    	var sessionlistitem = new SessionListItem({
    		props: { session: ctx.session, time: ctx.$time },
    		$$inline: true
    	});

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			first = empty();
    			sessionlistitem.$$.fragment.c();
    			this.first = first;
    		},

    		m: function mount(target, anchor) {
    			insert(target, first, anchor);
    			mount_component(sessionlistitem, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var sessionlistitem_changes = {};
    			if (changed.$todaysSessions) sessionlistitem_changes.session = ctx.session;
    			if (changed.$time) sessionlistitem_changes.time = ctx.$time;
    			sessionlistitem.$set(sessionlistitem_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(sessionlistitem.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(sessionlistitem.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(first);
    			}

    			destroy_component(sessionlistitem, detaching);
    		}
    	};
    }

    // (16:2) {#if $todaysSessions.later}
    function create_if_block_1$d(ctx) {
    	var h3, t0_value = ctx.$todaysSessions.later.length + "", t0, t1, t2_value = ctx.$todaysSessions.later.length - 1 && 's' || '' + "", t2, t3, t4, each_blocks = [], each_1_lookup = new Map(), each_1_anchor, current;

    	var each_value = ctx.$todaysSessions.later;

    	const get_key = ctx => ctx.session.id;

    	for (var i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$c(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$c(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			h3 = element("h3");
    			t0 = text(t0_value);
    			t1 = text(" Lesson");
    			t2 = text(t2_value);
    			t3 = text(" within 24 hours");
    			t4 = space();

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();

    			each_1_anchor = empty();
    			attr(h3, "class", "title is-5");
    			add_location(h3, file$B, 16, 4, 551);
    		},

    		m: function mount(target, anchor) {
    			insert(target, h3, anchor);
    			append(h3, t0);
    			append(h3, t1);
    			append(h3, t2);
    			append(h3, t3);
    			insert(target, t4, anchor);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(target, anchor);

    			insert(target, each_1_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if ((!current || changed.$todaysSessions) && t0_value !== (t0_value = ctx.$todaysSessions.later.length + "")) {
    				set_data(t0, t0_value);
    			}

    			if ((!current || changed.$todaysSessions) && t2_value !== (t2_value = ctx.$todaysSessions.later.length - 1 && 's' || '' + "")) {
    				set_data(t2, t2_value);
    			}

    			const each_value = ctx.$todaysSessions.later;

    			group_outros();
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$c, each_1_anchor, get_each_context$c);
    			check_outros();
    		},

    		i: function intro(local) {
    			if (current) return;
    			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

    			current = true;
    		},

    		o: function outro(local) {
    			for (i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h3);
    				detach(t4);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d(detaching);

    			if (detaching) {
    				detach(each_1_anchor);
    			}
    		}
    	};
    }

    // (18:4) {#each $todaysSessions.later as session (session.id)}
    function create_each_block$c(key_1, ctx) {
    	var first, current;

    	var sessionlistitem = new SessionListItem({
    		props: { session: ctx.session, time: ctx.$time },
    		$$inline: true
    	});

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			first = empty();
    			sessionlistitem.$$.fragment.c();
    			this.first = first;
    		},

    		m: function mount(target, anchor) {
    			insert(target, first, anchor);
    			mount_component(sessionlistitem, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var sessionlistitem_changes = {};
    			if (changed.$todaysSessions) sessionlistitem_changes.session = ctx.session;
    			if (changed.$time) sessionlistitem_changes.time = ctx.$time;
    			sessionlistitem.$set(sessionlistitem_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(sessionlistitem.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(sessionlistitem.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(first);
    			}

    			destroy_component(sessionlistitem, detaching);
    		}
    	};
    }

    function create_fragment$H(ctx) {
    	var current_block_type_index, if_block, if_block_anchor, current;

    	var if_block_creators = [
    		create_if_block$q,
    		create_else_block$c
    	];

    	var if_blocks = [];

    	function select_block_type(changed, ctx) {
    		if (ctx.$todaysSessions) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(null, ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(changed, ctx);
    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(changed, ctx);
    			} else {
    				group_outros();
    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});
    				check_outros();

    				if_block = if_blocks[current_block_type_index];
    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}
    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let $todaysSessions, $time;

    	validate_store(todaysSessions, 'todaysSessions');
    	component_subscribe($$self, todaysSessions, $$value => { $todaysSessions = $$value; $$invalidate('$todaysSessions', $todaysSessions); });
    	validate_store(time, 'time');
    	component_subscribe($$self, time, $$value => { $time = $$value; $$invalidate('$time', $time); });

    	return { $todaysSessions, $time };
    }

    class UpcomingSessions extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$G, create_fragment$H, safe_not_equal, []);
    	}
    }

    /* admin/src/components/sessions/SessionsList.svelte generated by Svelte v3.9.2 */

    const file$C = "admin/src/components/sessions/SessionsList.svelte";

    function get_each_context$d(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.session = list[i];
    	return child_ctx;
    }

    // (16:0) {:else}
    function create_else_block$d(ctx) {
    	var current;

    	var loading = new Loading({
    		props: { what: "sessions" },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			loading.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},

    		p: noop,

    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};
    }

    // (7:0) {#if $sessions}
    function create_if_block$r(ctx) {
    	var h3, t0, t1_value = ctx.$sessions.length + "", t1, t2, t3, p, t5, ul, each_blocks = [], each_1_lookup = new Map(), current;

    	var each_value = ctx.$sessions;

    	const get_key = ctx => ctx.session.id;

    	for (var i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$d(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$d(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			h3 = element("h3");
    			t0 = text("Showing ");
    			t1 = text(t1_value);
    			t2 = text(" sessions");
    			t3 = space();
    			p = element("p");
    			p.textContent = "Click a session to view details.";
    			t5 = space();
    			ul = element("ul");

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();
    			attr(h3, "class", "title is-5");
    			add_location(h3, file$C, 7, 0, 171);
    			add_location(p, file$C, 8, 0, 235);
    			add_location(ul, file$C, 9, 0, 275);
    		},

    		m: function mount(target, anchor) {
    			insert(target, h3, anchor);
    			append(h3, t0);
    			append(h3, t1);
    			append(h3, t2);
    			insert(target, t3, anchor);
    			insert(target, p, anchor);
    			insert(target, t5, anchor);
    			insert(target, ul, anchor);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(ul, null);

    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if ((!current || changed.$sessions) && t1_value !== (t1_value = ctx.$sessions.length + "")) {
    				set_data(t1, t1_value);
    			}

    			const each_value = ctx.$sessions;

    			group_outros();
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$d, null, get_each_context$d);
    			check_outros();
    		},

    		i: function intro(local) {
    			if (current) return;
    			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

    			current = true;
    		},

    		o: function outro(local) {
    			for (i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h3);
    				detach(t3);
    				detach(p);
    				detach(t5);
    				detach(ul);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d();
    		}
    	};
    }

    // (11:2) {#each $sessions as session (session.id)}
    function create_each_block$d(key_1, ctx) {
    	var first, current;

    	var sessionlistitem = new SessionListItem({
    		props: { session: ctx.session },
    		$$inline: true
    	});

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			first = empty();
    			sessionlistitem.$$.fragment.c();
    			this.first = first;
    		},

    		m: function mount(target, anchor) {
    			insert(target, first, anchor);
    			mount_component(sessionlistitem, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var sessionlistitem_changes = {};
    			if (changed.$sessions) sessionlistitem_changes.session = ctx.session;
    			sessionlistitem.$set(sessionlistitem_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(sessionlistitem.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(sessionlistitem.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(first);
    			}

    			destroy_component(sessionlistitem, detaching);
    		}
    	};
    }

    function create_fragment$I(ctx) {
    	var current_block_type_index, if_block, if_block_anchor, current;

    	var if_block_creators = [
    		create_if_block$r,
    		create_else_block$d
    	];

    	var if_blocks = [];

    	function select_block_type(changed, ctx) {
    		if (ctx.$sessions) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(null, ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(changed, ctx);
    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(changed, ctx);
    			} else {
    				group_outros();
    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});
    				check_outros();

    				if_block = if_blocks[current_block_type_index];
    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}
    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function instance$H($$self, $$props, $$invalidate) {
    	let $sessions;

    	validate_store(sessions, 'sessions');
    	component_subscribe($$self, sessions, $$value => { $sessions = $$value; $$invalidate('$sessions', $sessions); });

    	return { $sessions };
    }

    class SessionsList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$H, create_fragment$I, safe_not_equal, []);
    	}
    }

    /* admin/src/components/sessions/AddSession.svelte generated by Svelte v3.9.2 */

    const file$D = "admin/src/components/sessions/AddSession.svelte";

    // (46:0) <Modal bind:open>
    function create_default_slot$9(ctx) {
    	var current;

    	var sessionform = new SessionForm({
    		props: {
    		errors: ctx.errors,
    		loading: ctx.loading
    	},
    		$$inline: true
    	});
    	sessionform.$on("submit", ctx.save);
    	sessionform.$on("reset", ctx.reset);

    	return {
    		c: function create() {
    			sessionform.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(sessionform, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var sessionform_changes = {};
    			if (changed.errors) sessionform_changes.errors = ctx.errors;
    			if (changed.loading) sessionform_changes.loading = ctx.loading;
    			sessionform.$set(sessionform_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(sessionform.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(sessionform.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(sessionform, detaching);
    		}
    	};
    }

    function create_fragment$J(ctx) {
    	var button, i, t0, t1, updating_open, current, dispose;

    	function modal_open_binding(value) {
    		ctx.modal_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let modal_props = {
    		$$slots: { default: [create_default_slot$9] },
    		$$scope: { ctx }
    	};
    	if (ctx.open !== void 0) {
    		modal_props.open = ctx.open;
    	}
    	var modal = new Modal({ props: modal_props, $$inline: true });

    	binding_callbacks.push(() => bind(modal, 'open', modal_open_binding));

    	return {
    		c: function create() {
    			button = element("button");
    			i = element("i");
    			t0 = text(" Add a\n  session");
    			t1 = space();
    			modal.$$.fragment.c();
    			attr(i, "class", "fas fa-plus");
    			add_location(i, file$D, 42, 79, 1250);
    			attr(button, "class", "button add-button is-primary svelte-1igl3a3");
    			add_location(button, file$D, 42, 0, 1171);
    			dispose = listen(button, "click", ctx.click_handler);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);
    			append(button, i);
    			append(button, t0);
    			insert(target, t1, anchor);
    			mount_component(modal, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var modal_changes = {};
    			if (changed.$$scope || changed.errors || changed.loading) modal_changes.$$scope = { changed, ctx };
    			if (!updating_open && changed.open) {
    				modal_changes.open = ctx.open;
    			}
    			modal.$set(modal_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(button);
    				detach(t1);
    			}

    			destroy_component(modal, detaching);

    			dispose();
    		}
    	};
    }

    function instance$I($$self, $$props, $$invalidate) {
    	

      let errors = null;
      let open = false;
      let loading = false;

      const reset = () => {
        $$invalidate('errors', errors = null);
        $$invalidate('open', open = false);
      };

      const save = async ({ detail }) => {
        const { groupId, lessonId, startsAt, endsAt } = detail;
        console.log(detail);
        const startsAtUTC = new Date(startsAt).toISOString();
        const endsAtUTC = new Date(endsAt).toISOString();
        $$invalidate('loading', loading = true);
        try {
          const newSession = await sessions.create(startsAtUTC, endsAtUTC, groupId, lessonId);
          const date = formatRelative$1(new Date(startsAt), new Date(), { addSuffix: true });
          notifications.add({ text: `Created new session ${date} with ${newSession.group.name} class`, type: 'success' });
          reset();
        } catch (error) {
          $$invalidate('errors', errors = error);
          notifications.add({ text: 'Could not create new session', type: 'danger' });
        } finally {
          $$invalidate('loading', loading = false);
        }
      };

    	function click_handler() { open = true; $$invalidate('open', open); }

    	function modal_open_binding(value) {
    		open = value;
    		$$invalidate('open', open);
    	}

    	return {
    		errors,
    		open,
    		loading,
    		reset,
    		save,
    		click_handler,
    		modal_open_binding
    	};
    }

    class AddSession extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$I, create_fragment$J, safe_not_equal, []);
    	}
    }

    /* admin/src/components/sessions/Sessions.svelte generated by Svelte v3.9.2 */

    const file$E = "admin/src/components/sessions/Sessions.svelte";

    function create_fragment$K(ctx) {
    	var t0, h1, t2, t3, button0, i, t4, t5, nav, button1, t7, button2, t9, button3, t11, button4, t13, switch_instance_anchor, current, dispose;

    	var addsession = new AddSession({ $$inline: true });

    	var switch_value = ctx.activeComponent;

    	function switch_props(ctx) {
    		return { $$inline: true };
    	}

    	if (switch_value) {
    		var switch_instance = new switch_value(switch_props());
    	}

    	return {
    		c: function create() {
    			t0 = space();
    			h1 = element("h1");
    			h1.textContent = "Class schedule";
    			t2 = space();
    			addsession.$$.fragment.c();
    			t3 = space();
    			button0 = element("button");
    			i = element("i");
    			t4 = text("Reload sessions");
    			t5 = space();
    			nav = element("nav");
    			button1 = element("button");
    			button1.textContent = "24 hours";
    			t7 = space();
    			button2 = element("button");
    			button2.textContent = "Past";
    			t9 = space();
    			button3 = element("button");
    			button3.textContent = "Future";
    			t11 = space();
    			button4 = element("button");
    			button4.textContent = "All";
    			t13 = space();
    			if (switch_instance) switch_instance.$$.fragment.c();
    			switch_instance_anchor = empty();
    			document.title = "Class schedule";
    			attr(h1, "class", "title");
    			add_location(h1, file$E, 41, 0, 998);
    			attr(i, "class", "fas fa-sync");
    			add_location(i, file$E, 47, 47, 1104);
    			attr(button0, "class", "button");
    			add_location(button0, file$E, 47, 0, 1057);
    			attr(button1, "class", "button is-link svelte-1rwunha");
    			toggle_class(button1, "is-outlined", ctx.active !== 'upcoming');
    			add_location(button1, file$E, 50, 2, 1204);
    			attr(button2, "class", "button is-link svelte-1rwunha");
    			toggle_class(button2, "is-outlined", ctx.active !== 'past');
    			add_location(button2, file$E, 54, 2, 1349);
    			attr(button3, "class", "button is-link svelte-1rwunha");
    			toggle_class(button3, "is-outlined", ctx.active !== 'future');
    			add_location(button3, file$E, 58, 2, 1483);
    			attr(button4, "class", "button is-link svelte-1rwunha");
    			toggle_class(button4, "is-outlined", ctx.active !== 'all');
    			add_location(button4, file$E, 60, 2, 1614);
    			attr(nav, "class", "buttons has-addons is-centered svelte-1rwunha");
    			add_location(nav, file$E, 49, 0, 1157);

    			dispose = [
    				listen(button0, "click", sessions.get),
    				listen(button1, "click", ctx.click_handler),
    				listen(button2, "click", ctx.click_handler_1),
    				listen(button3, "click", ctx.click_handler_2),
    				listen(button4, "click", ctx.click_handler_3)
    			];
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t0, anchor);
    			insert(target, h1, anchor);
    			insert(target, t2, anchor);
    			mount_component(addsession, target, anchor);
    			insert(target, t3, anchor);
    			insert(target, button0, anchor);
    			append(button0, i);
    			append(button0, t4);
    			insert(target, t5, anchor);
    			insert(target, nav, anchor);
    			append(nav, button1);
    			append(nav, t7);
    			append(nav, button2);
    			append(nav, t9);
    			append(nav, button3);
    			append(nav, t11);
    			append(nav, button4);
    			insert(target, t13, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert(target, switch_instance_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (changed.active) {
    				toggle_class(button1, "is-outlined", ctx.active !== 'upcoming');
    				toggle_class(button2, "is-outlined", ctx.active !== 'past');
    				toggle_class(button3, "is-outlined", ctx.active !== 'future');
    				toggle_class(button4, "is-outlined", ctx.active !== 'all');
    			}

    			if (switch_value !== (switch_value = ctx.activeComponent)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;
    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});
    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());

    					switch_instance.$$.fragment.c();
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(addsession.$$.fragment, local);

    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(addsession.$$.fragment, local);
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t0);
    				detach(h1);
    				detach(t2);
    			}

    			destroy_component(addsession, detaching);

    			if (detaching) {
    				detach(t3);
    				detach(button0);
    				detach(t5);
    				detach(nav);
    				detach(t13);
    				detach(switch_instance_anchor);
    			}

    			if (switch_instance) destroy_component(switch_instance, detaching);
    			run_all(dispose);
    		}
    	};
    }

    function instance$J($$self, $$props, $$invalidate) {
    	

      let activeComponent = UpcomingSessions;
      let active = 'upcoming';

      onMount(() => {
        sessions.get();
        const refetch = setInterval(sessions.get, 5 * 6e+4);
        return () => { refetch && clearInterval(refetch); }
      });

      const switchTab = (tab) => {
        let where = null;
        $$invalidate('active', active = tab);
        if (tab === 'past') {
          where = { endsAt_lt: new Date().toISOString() };
        } else if (tab === 'future') {
          where = { startsAt_gt: new Date().toISOString() };
        }
        sessionsFilter.set(where);
        sessions.get();
        $$invalidate('activeComponent', activeComponent = tab === 'upcoming' ? UpcomingSessions : SessionsList);
      };

    	function click_handler() {
    		return switchTab('upcoming');
    	}

    	function click_handler_1() {
    		return switchTab('past');
    	}

    	function click_handler_2() {
    		return switchTab('future');
    	}

    	function click_handler_3() {
    		return switchTab('all');
    	}

    	return {
    		activeComponent,
    		active,
    		switchTab,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3
    	};
    }

    class Sessions extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$J, create_fragment$K, safe_not_equal, []);
    	}
    }

    const AllSessionFields = /* GraphQL */`
  fragment AllSessionFields on ClassSession {
    id
     stage
     startsAt
     startedAt
     endsAt
     endedAt
     number
     group {
       id
       name
     }
     report {
      id
      published
      homeworkEN
      homeworkZH
      summaryEN
      summaryZH
      performance
      materials {
        id
        type
        title
        url
        notes
      }
      words {
        id
        english
        chinese
        audio
      }
    }
    lesson {
      id
      name
    }
  }
`;

    const CLASS_SESSION = /* GraphQL */`
  query classSession($id: ID!){
    classSession (id: $id){
      ...AllSessionFields
    }
  }
  ${AllSessionFields}`;

    const CLASS_SESSION_SUB = /* GraphQL */`
subscription classSession($id: ID!){
  classSession (id: $id){
    ...AllSessionFields
  }
}
${AllSessionFields}`;

    const GET_SESSION_STUDENTS = /* GraphQL */`
query students($groupId: ID!, $classSessionId: ID!){
  students (where: { groups_some: {id: $groupId}}) {
    id
    chineseName
    pinyinName
    englishName
  }
  attendances (where: {classSession: {id: $classSessionId}}) {
    id
    student {
      id
    }
    status
  }
}
`;

    const ATTENDANCE_SUB = /* GraphQL */`
subscription attendances($classSessionId: ID!){
  attendances (classSessionId: $classSessionId){
    id
    student {
      id
    }
    status
  }
}`;

    const GET_SESSION_POINTS = /* GraphQL */`
query points($classSessionId: ID!) {
 points(where: { classSession: {id: $classSessionId}}) {
      id 
      value
      student {
        englishName
        chineseName
        id
      }
    }
}
`;
    const POINTS_SUB = /* GraphQL */`
subscription sessionPoints($classSessionId: ID!){
  points(classSessionId: $classSessionId){
    mutation
    previousValues {
      id
    }
    node {
      id
      value
      student {
        englishName
        chineseName
        id
      }
    }
    
  }
}
`;

    const SESSION_RESULTS = /* GraphQL */`
query sessionResults($id: ID!) {
  classSession (id: $id){
    id
    stage
    startsAt
    startedAt
    endsAt
    endedAt
    number
    group {
      id
      name
    }
    attendances {
      status
      arrivedAt 
      student {
        id
        chineseName
        englishName
        pinyinName
      }
    }
    points {
      value
      student {
        id
        chineseName
        englishName
        pinyinName
      }
    }
  }
}
`;

    const ACTIVATE_SESSION = /* GraphQL */`
 mutation activateSession($id:ID!){
   activateSession(id:$id) {
     id
   }
 }`;

    const START_CLASS = /* GraphQL */`
mutation startClass($id: ID!, $now: DateTime!) {
  updateClassSession(id: $id, input: {stage: Started, startedAt: $now}) {
    id
  }
  markRestAbsent(classSessionId: $id)
}
`;

    const END_CLASS = /* GraphQL */`
mutation endClass($id: ID!, $now: DateTime!) {
  updateClassSession(id: $id, input: {stage: Ended, endedAt: $now}) {
    id
  }
}`;

    const UPDATE_ATTENDANCE = /* GraphQL */`
mutation updateAttendance($classSessionId: ID!, $studentId: ID!, $status: String!){
  updateAttendance(classSessionId: $classSessionId, studentId: $studentId, status: $status){
    id
  }
}
`;

    const MARK_ALL_PRESENT = /* GraphQL */`
mutation markAllPresent($classSessionId: ID!) {
  markAllPresent(classSessionId: $classSessionId)
}
`;

    const UNDO_POINT = /* GraphQL */`
mutation undoPoint($id: ID!) {
  undoPoint(id: $id) {
    id
  }
}
`;

    const ADD_POINT = /* GraphQL */`
mutation addPoint($value: Int!, $studentId: ID!, $classSessionId: ID!) {
  addPoint(value: $value, studentId: $studentId, classSessionId: $classSessionId) {
    id
    value
    student {
      englishName
      chineseName
      id
    }
  }
} `;

    const ADD_LESSON_TO_SESSION = /* GraphQL */ `
mutation AddLessonToSession($id: ID!, $lessonId: ID!) {
  addLessonToClassSession(id: $id, lessonId: $lessonId) {
    ...AllSessionFields
  }
}
${AllSessionFields}`;

    // have it reset itself to null when not in use
    const sessionId = writable(null, set => set(null));

    const session = readable(null, set => {
      let subscription;
      const unsubscribe = sessionId.subscribe(id => {
        if (!id) {
          set(null);
          return
        }
        if (subscription) {
          subscription.unsubscribe();
        }
        request(CLASS_SESSION, { id })
          .then(response => {
            set(response.classSession);
          });
        subscription = ws.request({ query: CLASS_SESSION_SUB, variables: { id } })
          .subscribe({
            next (message) {
              if (message.data && message.data.classSession) {
                set(message.data.classSession);
              }
            }
          });
      });
      return () => {
        subscription && subscription.unsubscribe();
        unsubscribe();
      }
    });

    const createSessionStudentStore = () => {
      const mapAttendanceToStudents = (attendances, students) => {
        if (attendances && attendances.length === 0) return students
        attendances = Array.isArray(attendances) ? attendances : [attendances];
        return students.map(student => {
          const attendance = attendances.find(a => {
            if (!a.student) return false
            return a.student.id === student.id
          });
          if (attendance) {
            student.attendance = attendance;
          }
          return student
        }).sort((a, b) => {
          if (a.englishName < b.englishName) return -1
          if (a.englishName > b.englishName) return 1
        })
      };
      const { subscribe, update } = writable(null, set => {
        let subscription;
        const unsubscribe = session.subscribe(session => {
          if (!session) return
          if (subscription) {
            subscription.unsubscribe();
          }
          // get initial data
          request(GET_SESSION_STUDENTS, { groupId: session.group.id, classSessionId: session.id })
            .then(response => {
              set(mapAttendanceToStudents(response.attendances, response.students));
            });
          // and subscribe to changes
          subscription = ws.request({ query: ATTENDANCE_SUB, variables: { classSessionId: session.id } })
            .subscribe({
              next (message) {
                if (message.data && message.data.attendances) {
                  update(previous => {
                    return mapAttendanceToStudents(message.data.attendances, previous)
                  });
                }
              }
            });
        });
        return () => {
          subscription && subscription.unsubscribe();
          unsubscribe();
        }
      });
      return {
        subscribe, update, mapAttendanceToStudents
      }
    };
    const sessionStudents = createSessionStudentStore();

    const createPointsLogStore = () => {
      const { subscribe, update } = writable([]);
      return {
        subscribe,
        update,
        add: (point) => {
          update(previous => [point, ...previous.slice(0, 9)]);
        },
        remove: (id) => {
          update(previous => previous.filter(point => point.id !== id));
        }
      }
    };
    const pointsLog = createPointsLogStore();

    const createPointsStore = () => {
      const { subscribe, update } = writable(null, set => {
        let subscription;
        const unsubscribe = session.subscribe(session => {
          if (!session) return
          if (subscription) {
            subscription.unsubscribe();
          }
          // get initial values
          request(GET_SESSION_POINTS, { classSessionId: session.id })
            .then(response => {
              set(response.points);
            });
          // and subscribe to changes from the server
          subscription = ws.request({ query: POINTS_SUB, variables: { classSessionId: session.id } })
            .subscribe({
              next (message) {
                if (message.data && message.data.points) {
                  const { node, mutation, previousValues } = message.data.points;
                  if (mutation === 'CREATED') {
                    update(previous => {
                      return [node, ...previous]
                    });
                  }
                  if (mutation === 'DELETED') {
                    update(previous => {
                      return previous.filter(point => point.id !== previousValues.id)
                    });
                    pointsLog.update(previous => {
                      return previous.filter(point => point.id !== previousValues.id)
                    });
                  }
                }
              }
            });
        });
        return () => {
          unsubscribe();
          subscription && subscription.unsubscribe();
        }
      });
      return {
        subscribe,
        update,
        undo: async (id) => {
          await request(UNDO_POINT, { id });
        },
        add: async (value, studentId, classSessionId) => {
          const response = await request(ADD_POINT, { value, studentId, classSessionId });
          pointsLog.add(response.addPoint);
        }
      }
    };

    const points = createPointsStore();

    const results = derived(sessionId, async ($sessionId, set) => {
      if (!$sessionId) return
      const response = await request(SESSION_RESULTS, { classSessionId: $sessionId });
      if (!response.classSession) return
      const { attendances, points } = response.classSession;
      const withPoints = attendances && attendances.map(attendance => {
        attendance.points = points && points.filter(point => {
          return point.student.id === attendance.student.id
        });
        attendance.pointsTally = attendance.points.reduce((sum, point) => {
          return sum + point.value
        }, 0);
        return attendance
      });
      set(withPoints.slice().sort((a, b) => {
        return b.pointsTally - a.pointsTally
      }));
    });

    const getResults = async (id) => {
      const response = await request(SESSION_RESULTS, { id });
      if (!response.classSession) return
      const { attendances, points } = response.classSession;
      const withPoints = attendances && attendances.map(attendance => {
        attendance.points = points && points.filter(point => {
          return point.student.id === attendance.student.id
        });
        attendance.pointsTally = attendance.points.reduce((sum, point) => {
          return sum + point.value
        }, 0);
        return attendance
      });
      return withPoints.slice().sort((a, b) => {
        return b.pointsTally - a.pointsTally
      })
    };

    /* admin/src/components/session/AttendanceRow.svelte generated by Svelte v3.9.2 */
    const { console: console_1$1 } = globals;

    const file$F = "admin/src/components/session/AttendanceRow.svelte";

    function create_fragment$L(ctx) {
    	var li, i, i_class_value, t0, span, t1_value = ctx.student.englishName || ctx.student.chineseName + "", t1, dispose;

    	return {
    		c: function create() {
    			li = element("li");
    			i = element("i");
    			t0 = space();
    			span = element("span");
    			t1 = text(t1_value);
    			attr(i, "class", i_class_value = "fas fa-" + (ctx.present ? 'check' : 'dot') + "-circle status" + " svelte-1199exf");
    			add_location(i, file$F, 37, 2, 834);
    			attr(span, "class", "name");
    			add_location(span, file$F, 38, 2, 901);
    			attr(li, "class", "svelte-1199exf");
    			toggle_class(li, "absent", !ctx.present);
    			add_location(li, file$F, 36, 0, 775);
    			dispose = listen(li, "click", ctx.updateAttendance);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, li, anchor);
    			append(li, i);
    			append(li, t0);
    			append(li, span);
    			append(span, t1);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.present) && i_class_value !== (i_class_value = "fas fa-" + (ctx.present ? 'check' : 'dot') + "-circle status" + " svelte-1199exf")) {
    				attr(i, "class", i_class_value);
    			}

    			if ((changed.student) && t1_value !== (t1_value = ctx.student.englishName || ctx.student.chineseName + "")) {
    				set_data(t1, t1_value);
    			}

    			if (changed.present) {
    				toggle_class(li, "absent", !ctx.present);
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(li);
    			}

    			dispose();
    		}
    	};
    }

    function instance$K($$self, $$props, $$invalidate) {
    	

      let { student = {}, sessionId = null, started = false } = $$props;

      const updateAttendance = () => {
        const status = present ? 'Absent' : started ? 'Late' : 'Present';
        try {
          request(UPDATE_ATTENDANCE, { classSessionId: sessionId, studentId: student.id, status });
        } catch (error) {
          console.error(error);
        }
      };

    	const writable_props = ['student', 'sessionId', 'started'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console_1$1.warn(`<AttendanceRow> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('student' in $$props) $$invalidate('student', student = $$props.student);
    		if ('sessionId' in $$props) $$invalidate('sessionId', sessionId = $$props.sessionId);
    		if ('started' in $$props) $$invalidate('started', started = $$props.started);
    	};

    	let present;

    	$$self.$$.update = ($$dirty = { student: 1 }) => {
    		if ($$dirty.student) { $$invalidate('present', present = !(!student.attendance || student.attendance.status === 'Absent')); }
    	};

    	return {
    		student,
    		sessionId,
    		started,
    		updateAttendance,
    		present
    	};
    }

    class AttendanceRow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$K, create_fragment$L, safe_not_equal, ["student", "sessionId", "started"]);
    	}

    	get student() {
    		throw new Error("<AttendanceRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set student(value) {
    		throw new Error("<AttendanceRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sessionId() {
    		throw new Error("<AttendanceRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sessionId(value) {
    		throw new Error("<AttendanceRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get started() {
    		throw new Error("<AttendanceRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set started(value) {
    		throw new Error("<AttendanceRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/session/AttendanceForm.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$b } = globals;

    const file$G = "admin/src/components/session/AttendanceForm.svelte";

    function get_each_context$e(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.student = list[i];
    	return child_ctx;
    }

    // (43:4) {:else}
    function create_else_block_1$1(ctx) {
    	var current;

    	var loading = new Loading({
    		props: { what: "students" },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			loading.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},

    		p: noop,

    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};
    }

    // (35:2) {#if $sessionStudents}
    function create_if_block$s(ctx) {
    	var current_block_type_index, if_block, if_block_anchor, current;

    	var if_block_creators = [
    		create_if_block_1$e,
    		create_else_block$e
    	];

    	var if_blocks = [];

    	function select_block_type_1(changed, ctx) {
    		if (ctx.$sessionStudents.length) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(null, ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(changed, ctx);
    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(changed, ctx);
    			} else {
    				group_outros();
    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});
    				check_outros();

    				if_block = if_blocks[current_block_type_index];
    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}
    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    // (40:6) {:else}
    function create_else_block$e(ctx) {
    	var p;

    	return {
    		c: function create() {
    			p = element("p");
    			p.textContent = "No students were found for this class session.";
    			add_location(p, file$G, 40, 8, 993);
    		},

    		m: function mount(target, anchor) {
    			insert(target, p, anchor);
    		},

    		p: noop,
    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(p);
    			}
    		}
    	};
    }

    // (36:6) {#if $sessionStudents.length}
    function create_if_block_1$e(ctx) {
    	var each_blocks = [], each_1_lookup = new Map(), each_1_anchor, current;

    	var each_value = ctx.$sessionStudents;

    	const get_key = ctx => ctx.student.id;

    	for (var i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$e(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$e(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();

    			each_1_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(target, anchor);

    			insert(target, each_1_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			const each_value = ctx.$sessionStudents;

    			group_outros();
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$e, each_1_anchor, get_each_context$e);
    			check_outros();
    		},

    		i: function intro(local) {
    			if (current) return;
    			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

    			current = true;
    		},

    		o: function outro(local) {
    			for (i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			current = false;
    		},

    		d: function destroy(detaching) {
    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d(detaching);

    			if (detaching) {
    				detach(each_1_anchor);
    			}
    		}
    	};
    }

    // (37:8) {#each $sessionStudents as student (student.id)}
    function create_each_block$e(key_1, ctx) {
    	var first, current;

    	var attendancerow = new AttendanceRow({
    		props: {
    		student: ctx.student,
    		sessionId: ctx.$session.id
    	},
    		$$inline: true
    	});

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			first = empty();
    			attendancerow.$$.fragment.c();
    			this.first = first;
    		},

    		m: function mount(target, anchor) {
    			insert(target, first, anchor);
    			mount_component(attendancerow, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var attendancerow_changes = {};
    			if (changed.$sessionStudents) attendancerow_changes.student = ctx.student;
    			if (changed.$session) attendancerow_changes.sessionId = ctx.$session.id;
    			attendancerow.$set(attendancerow_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(attendancerow.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(attendancerow.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(first);
    			}

    			destroy_component(attendancerow, detaching);
    		}
    	};
    }

    function create_fragment$M(ctx) {
    	var section, t0, button, i, t1, t2, current_block_type_index, if_block, current, dispose;

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	var if_block_creators = [
    		create_if_block$s,
    		create_else_block_1$1
    	];

    	var if_blocks = [];

    	function select_block_type(changed, ctx) {
    		if (ctx.$sessionStudents) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(null, ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	return {
    		c: function create() {
    			section = element("section");
    			error.$$.fragment.c();
    			t0 = space();
    			button = element("button");
    			i = element("i");
    			t1 = text("All\n    present");
    			t2 = space();
    			if_block.c();
    			attr(i, "class", "fas fa-clipboard-check");
    			add_location(i, file$G, 32, 74, 712);
    			attr(button, "class", "button is-primary is-inverted svelte-1yp3byo");
    			add_location(button, file$G, 32, 2, 640);
    			attr(section, "class", "attendance-form svelte-1yp3byo");
    			add_location(section, file$G, 29, 0, 582);
    			dispose = listen(button, "click", ctx.markAllPresent);
    		},

    		l: function claim(nodes) {
    			throw new Error_1$b("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, section, anchor);
    			mount_component(error, section, null);
    			append(section, t0);
    			append(section, button);
    			append(button, i);
    			append(button, t1);
    			append(section, t2);
    			if_blocks[current_block_type_index].m(section, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);

    			var previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(changed, ctx);
    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(changed, ctx);
    			} else {
    				group_outros();
    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});
    				check_outros();

    				if_block = if_blocks[current_block_type_index];
    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}
    				transition_in(if_block, 1);
    				if_block.m(section, null);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);

    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(section);
    			}

    			destroy_component(error);

    			if_blocks[current_block_type_index].d();
    			dispose();
    		}
    	};
    }

    function instance$L($$self, $$props, $$invalidate) {
    	let $session, $sessionStudents;

    	validate_store(session, 'session');
    	component_subscribe($$self, session, $$value => { $session = $$value; $$invalidate('$session', $session); });
    	validate_store(sessionStudents, 'sessionStudents');
    	component_subscribe($$self, sessionStudents, $$value => { $sessionStudents = $$value; $$invalidate('$sessionStudents', $sessionStudents); });

    	

      let errors = '';

      const markAllPresent = () => {
        try {
          request(MARK_ALL_PRESENT, { classSessionId: $session.id });
        } catch (error) {
          $$invalidate('errors', errors = error);
        }
      };

    	return {
    		errors,
    		markAllPresent,
    		$session,
    		$sessionStudents
    	};
    }

    class AttendanceForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$L, create_fragment$M, safe_not_equal, []);
    	}
    }

    /* admin/src/components/session/ActiveSession.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$c } = globals;

    const file$H = "admin/src/components/session/ActiveSession.svelte";

    function create_fragment$N(ctx) {
    	var t0, p, t1, t2, t3, t4, t5, button, i, t6, current, dispose;

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	var attendanceform = new AttendanceForm({ $$inline: true });

    	return {
    		c: function create() {
    			t0 = space();
    			p = element("p");
    			t1 = text("Scheduled start time: ");
    			t2 = text(ctx.distance);
    			t3 = space();
    			error.$$.fragment.c();
    			t4 = space();
    			attendanceform.$$.fragment.c();
    			t5 = space();
    			button = element("button");
    			i = element("i");
    			t6 = text("\n  Start class");
    			document.title = "Active Session";
    			attr(p, "class", "subtitle svelte-1rayv7m");
    			toggle_class(p, "late", ctx.$session.startsAt < ctx.$time.toJSON());
    			add_location(p, file$H, 35, 0, 764);
    			attr(i, "class", "fas fa-play-circle");
    			add_location(i, file$H, 39, 2, 966);
    			attr(button, "class", "button is-primary");
    			add_location(button, file$H, 38, 0, 907);
    			dispose = listen(button, "click", ctx.startClass);
    		},

    		l: function claim(nodes) {
    			throw new Error_1$c("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t0, anchor);
    			insert(target, p, anchor);
    			append(p, t1);
    			append(p, t2);
    			insert(target, t3, anchor);
    			mount_component(error, target, anchor);
    			insert(target, t4, anchor);
    			mount_component(attendanceform, target, anchor);
    			insert(target, t5, anchor);
    			insert(target, button, anchor);
    			append(button, i);
    			append(button, t6);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (!current || changed.distance) {
    				set_data(t2, ctx.distance);
    			}

    			if ((changed.$session || changed.$time)) {
    				toggle_class(p, "late", ctx.$session.startsAt < ctx.$time.toJSON());
    			}

    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);

    			transition_in(attendanceform.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			transition_out(attendanceform.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t0);
    				detach(p);
    				detach(t3);
    			}

    			destroy_component(error, detaching);

    			if (detaching) {
    				detach(t4);
    			}

    			destroy_component(attendanceform, detaching);

    			if (detaching) {
    				detach(t5);
    				detach(button);
    			}

    			dispose();
    		}
    	};
    }

    function instance$M($$self, $$props, $$invalidate) {
    	let $session, $time;

    	validate_store(session, 'session');
    	component_subscribe($$self, session, $$value => { $session = $$value; $$invalidate('$session', $session); });
    	validate_store(time, 'time');
    	component_subscribe($$self, time, $$value => { $time = $$value; $$invalidate('$time', $time); });

    	

      let errors = '';

      const startClass = () => {
        const now = new Date().toISOString();
        try {
          request(START_CLASS, { id: $session.id, now });
        } catch (error) {
          $$invalidate('errors', errors = error);
        }
      };

    	let distance;

    	$$self.$$.update = ($$dirty = { $session: 1, $time: 1 }) => {
    		if ($$dirty.$session || $$dirty.$time) { $$invalidate('distance', distance = $session &&
            $time &&
            formatDistance$1(new Date($session.startsAt), $time, { addSuffix: true })); }
    	};

    	return {
    		errors,
    		startClass,
    		$session,
    		distance,
    		$time
    	};
    }

    class ActiveSession extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$M, create_fragment$N, safe_not_equal, []);
    	}
    }

    /* admin/src/components/session/SessionActivator.svelte generated by Svelte v3.9.2 */

    const file$I = "admin/src/components/session/SessionActivator.svelte";

    function create_fragment$O(ctx) {
    	var p;

    	return {
    		c: function create() {
    			p = element("p");
    			p.textContent = "Activating class session...";
    			add_location(p, file$I, 12, 0, 261);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, p, anchor);
    		},

    		p: noop,
    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(p);
    			}
    		}
    	};
    }

    function instance$N($$self, $$props, $$invalidate) {
    	

      let { id = null } = $$props;
      onMount(() => {
        if (!id) return
        request(ACTIVATE_SESSION, { id });
      });

    	const writable_props = ['id'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<SessionActivator> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('id' in $$props) $$invalidate('id', id = $$props.id);
    	};

    	return { id };
    }

    class SessionActivator extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$N, create_fragment$O, safe_not_equal, ["id"]);
    	}

    	get id() {
    		throw new Error("<SessionActivator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<SessionActivator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/session/ConfirmEndSession.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$d } = globals;

    const file$J = "admin/src/components/session/ConfirmEndSession.svelte";

    function create_fragment$P(ctx) {
    	var h1, t0, t1_value = ctx.$session.group.name + "", t1, t2, t3_value = ctx.$session.number + "", t3, t4, t5, p0, t6, t7, t8, t9, t10, t11, p1, t12, t13_value = ctx.startDifference() + "", t13, t14, br, t15, p2, t17, div, button0, i, t18, t19, button1, current, dispose;

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			h1 = element("h1");
    			t0 = text("End ");
    			t1 = text(t1_value);
    			t2 = text(" class lesson ");
    			t3 = text(t3_value);
    			t4 = space();
    			error.$$.fragment.c();
    			t5 = space();
    			p0 = element("p");
    			t6 = text("Scheduled end: ");
    			t7 = text(ctx.endsAt);
    			t8 = text(" (");
    			t9 = text(ctx.endsAtDistance);
    			t10 = text(")");
    			t11 = space();
    			p1 = element("p");
    			t12 = text("Class started ");
    			t13 = text(t13_value);
    			t14 = space();
    			br = element("br");
    			t15 = space();
    			p2 = element("p");
    			p2.textContent = "Sure you want to end class now?";
    			t17 = space();
    			div = element("div");
    			button0 = element("button");
    			i = element("i");
    			t18 = text("\n    End class");
    			t19 = space();
    			button1 = element("button");
    			button1.textContent = "Nevermind";
    			attr(h1, "class", "title");
    			add_location(h1, file$J, 37, 0, 1006);
    			add_location(p0, file$J, 39, 0, 1105);
    			add_location(p1, file$J, 40, 0, 1155);
    			add_location(br, file$J, 41, 0, 1196);
    			add_location(p2, file$J, 42, 0, 1201);
    			attr(i, "class", "fas fa-thumbs-up");
    			add_location(i, file$J, 45, 4, 1370);
    			attr(button0, "class", "button is-primary");
    			button0.disabled = loading;
    			toggle_class(button0, "is-loading", loading);
    			add_location(button0, file$J, 44, 2, 1264);
    			attr(button1, "class", "button");
    			add_location(button1, file$J, 48, 2, 1431);
    			attr(div, "class", "buttons svelte-8v8jl6");
    			add_location(div, file$J, 43, 0, 1240);

    			dispose = [
    				listen(button0, "click", ctx.handleEnd),
    				listen(button1, "click", ctx.click_handler)
    			];
    		},

    		l: function claim(nodes) {
    			throw new Error_1$d("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, h1, anchor);
    			append(h1, t0);
    			append(h1, t1);
    			append(h1, t2);
    			append(h1, t3);
    			insert(target, t4, anchor);
    			mount_component(error, target, anchor);
    			insert(target, t5, anchor);
    			insert(target, p0, anchor);
    			append(p0, t6);
    			append(p0, t7);
    			append(p0, t8);
    			append(p0, t9);
    			append(p0, t10);
    			insert(target, t11, anchor);
    			insert(target, p1, anchor);
    			append(p1, t12);
    			append(p1, t13);
    			insert(target, t14, anchor);
    			insert(target, br, anchor);
    			insert(target, t15, anchor);
    			insert(target, p2, anchor);
    			insert(target, t17, anchor);
    			insert(target, div, anchor);
    			append(div, button0);
    			append(button0, i);
    			append(button0, t18);
    			append(div, t19);
    			append(div, button1);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if ((!current || changed.$session) && t1_value !== (t1_value = ctx.$session.group.name + "")) {
    				set_data(t1, t1_value);
    			}

    			if ((!current || changed.$session) && t3_value !== (t3_value = ctx.$session.number + "")) {
    				set_data(t3, t3_value);
    			}

    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);

    			if (changed.loading) {
    				toggle_class(button0, "is-loading", loading);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h1);
    				detach(t4);
    			}

    			destroy_component(error, detaching);

    			if (detaching) {
    				detach(t5);
    				detach(p0);
    				detach(t11);
    				detach(p1);
    				detach(t14);
    				detach(br);
    				detach(t15);
    				detach(p2);
    				detach(t17);
    				detach(div);
    			}

    			run_all(dispose);
    		}
    	};
    }

    let loading = false;

    function instance$O($$self, $$props, $$invalidate) {
    	let $session;

    	validate_store(session, 'session');
    	component_subscribe($$self, session, $$value => { $session = $$value; $$invalidate('$session', $session); });

    	

      let { open = false } = $$props;
      let errors = '';

      const handleEnd = () => {
        try {
          request(END_CLASS, { id: $session.id, now: new Date() });
        } catch (error) {
          $$invalidate('errors', errors = error);
        }
      };
      const endsAt = format(new Date($session.endsAt), 'p');
      const endsAtDistance = formatDistance$1(new Date($session.endsAt), new Date(), { addSuffix: true });
      const startDifference = () => {
        const starts = new Date($session.startsAt);
        const started = new Date($session.startedAt);
        const diff = starts - started;
        const diffString = formatDistance$1(starts, started);
        const direction = diff > 0 ? 'early' : 'late';
        return `${diffString}  ${direction}`
      };

    	const writable_props = ['open'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<ConfirmEndSession> was created with unknown prop '${key}'`);
    	});

    	function click_handler() { open = false; $$invalidate('open', open); }

    	$$self.$set = $$props => {
    		if ('open' in $$props) $$invalidate('open', open = $$props.open);
    	};

    	return {
    		open,
    		errors,
    		handleEnd,
    		endsAt,
    		endsAtDistance,
    		startDifference,
    		$session,
    		click_handler
    	};
    }

    class ConfirmEndSession extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$O, create_fragment$P, safe_not_equal, ["open"]);
    	}

    	get open() {
    		throw new Error_1$d("<ConfirmEndSession>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set open(value) {
    		throw new Error_1$d("<ConfirmEndSession>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/session/PointsRow.svelte generated by Svelte v3.9.2 */

    const file$K = "admin/src/components/session/PointsRow.svelte";

    function create_fragment$Q(ctx) {
    	var li, t0, span0, t1_value = ctx.student.englishName || ctx.student.chineseName + "", t1, t2, span1, t3, t4, current;

    	var iconbutton0 = new IconButton({
    		props: { name: "plus-square", color: "#55FF66" },
    		$$inline: true
    	});
    	iconbutton0.$on("click", ctx.click_handler);

    	var iconbutton1 = new IconButton({
    		props: {
    		name: "minus-square",
    		color: "#FF3344",
    		disabled: ctx.pointsTally < 1
    	},
    		$$inline: true
    	});
    	iconbutton1.$on("click", ctx.click_handler_1);

    	return {
    		c: function create() {
    			li = element("li");
    			iconbutton0.$$.fragment.c();
    			t0 = space();
    			span0 = element("span");
    			t1 = text(t1_value);
    			t2 = space();
    			span1 = element("span");
    			t3 = text(ctx.pointsTally);
    			t4 = space();
    			iconbutton1.$$.fragment.c();
    			attr(span0, "class", "name svelte-ht5lal");
    			add_location(span0, file$K, 38, 2, 733);
    			attr(span1, "class", "points svelte-ht5lal");
    			add_location(span1, file$K, 39, 2, 806);
    			attr(li, "class", "svelte-ht5lal");
    			add_location(li, file$K, 36, 0, 645);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, li, anchor);
    			mount_component(iconbutton0, li, null);
    			append(li, t0);
    			append(li, span0);
    			append(span0, t1);
    			append(li, t2);
    			append(li, span1);
    			append(span1, t3);
    			append(li, t4);
    			mount_component(iconbutton1, li, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if ((!current || changed.student) && t1_value !== (t1_value = ctx.student.englishName || ctx.student.chineseName + "")) {
    				set_data(t1, t1_value);
    			}

    			if (!current || changed.pointsTally) {
    				set_data(t3, ctx.pointsTally);
    			}

    			var iconbutton1_changes = {};
    			if (changed.pointsTally) iconbutton1_changes.disabled = ctx.pointsTally < 1;
    			iconbutton1.$set(iconbutton1_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(iconbutton0.$$.fragment, local);

    			transition_in(iconbutton1.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(iconbutton0.$$.fragment, local);
    			transition_out(iconbutton1.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(li);
    			}

    			destroy_component(iconbutton0);

    			destroy_component(iconbutton1);
    		}
    	};
    }

    function instance$P($$self, $$props, $$invalidate) {
    	let $points;

    	validate_store(points, 'points');
    	component_subscribe($$self, points, $$value => { $points = $$value; $$invalidate('$points', $points); });

    	
      let { student, sessionId } = $$props;

      const addPoint = value => {
        points.add(value, student.id, sessionId);
      };

    	const writable_props = ['student', 'sessionId'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<PointsRow> was created with unknown prop '${key}'`);
    	});

    	function click_handler() {
    		return addPoint(1);
    	}

    	function click_handler_1() {
    		return addPoint(-1);
    	}

    	$$self.$set = $$props => {
    		if ('student' in $$props) $$invalidate('student', student = $$props.student);
    		if ('sessionId' in $$props) $$invalidate('sessionId', sessionId = $$props.sessionId);
    	};

    	let pointsTally;

    	$$self.$$.update = ($$dirty = { $points: 1, student: 1 }) => {
    		if ($$dirty.$points || $$dirty.student) { $$invalidate('pointsTally', pointsTally = $points
            ? $points.reduce((sum, point) => {
              if (point.student.id !== student.id) return sum
              return sum + point.value
            }, 0)
            : 0); }
    	};

    	return {
    		student,
    		sessionId,
    		addPoint,
    		pointsTally,
    		click_handler,
    		click_handler_1
    	};
    }

    class PointsRow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$P, create_fragment$Q, safe_not_equal, ["student", "sessionId"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.student === undefined && !('student' in props)) {
    			console.warn("<PointsRow> was created without expected prop 'student'");
    		}
    		if (ctx.sessionId === undefined && !('sessionId' in props)) {
    			console.warn("<PointsRow> was created without expected prop 'sessionId'");
    		}
    	}

    	get student() {
    		throw new Error("<PointsRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set student(value) {
    		throw new Error("<PointsRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sessionId() {
    		throw new Error("<PointsRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sessionId(value) {
    		throw new Error("<PointsRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/session/PointsPanel.svelte generated by Svelte v3.9.2 */

    const file$L = "admin/src/components/session/PointsPanel.svelte";

    function get_each_context$f(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.student = list[i];
    	return child_ctx;
    }

    // (18:4) {#if student.attendance && student.attendance.status !== "Absent"}
    function create_if_block$t(ctx) {
    	var current;

    	var pointsrow = new PointsRow({
    		props: {
    		student: ctx.student,
    		sessionId: ctx.sessionId
    	},
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			pointsrow.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(pointsrow, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var pointsrow_changes = {};
    			if (changed.$sessionStudents) pointsrow_changes.student = ctx.student;
    			if (changed.sessionId) pointsrow_changes.sessionId = ctx.sessionId;
    			pointsrow.$set(pointsrow_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointsrow.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(pointsrow.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(pointsrow, detaching);
    		}
    	};
    }

    // (17:4) {#each $sessionStudents as student (student.id)}
    function create_each_block$f(key_1, ctx) {
    	var first, if_block_anchor, current;

    	var if_block = (ctx.student.attendance && ctx.student.attendance.status !== "Absent") && create_if_block$t(ctx);

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			first = empty();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			this.first = first;
    		},

    		m: function mount(target, anchor) {
    			insert(target, first, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.student.attendance && ctx.student.attendance.status !== "Absent") {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$t(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(first);
    			}

    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function create_fragment$R(ctx) {
    	var section, h3, t_1, ul, each_blocks = [], each_1_lookup = new Map(), current;

    	var each_value = ctx.$sessionStudents;

    	const get_key = ctx => ctx.student.id;

    	for (var i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$f(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$f(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			section = element("section");
    			h3 = element("h3");
    			h3.textContent = "Points";
    			t_1 = space();
    			ul = element("ul");

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();
    			attr(h3, "class", "title is-4");
    			add_location(h3, file$L, 14, 2, 213);
    			add_location(ul, file$L, 15, 2, 250);
    			attr(section, "class", "points svelte-xj6mxc");
    			add_location(section, file$L, 13, 0, 186);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, section, anchor);
    			append(section, h3);
    			append(section, t_1);
    			append(section, ul);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(ul, null);

    			current = true;
    		},

    		p: function update(changed, ctx) {
    			const each_value = ctx.$sessionStudents;

    			group_outros();
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$f, null, get_each_context$f);
    			check_outros();
    		},

    		i: function intro(local) {
    			if (current) return;
    			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

    			current = true;
    		},

    		o: function outro(local) {
    			for (i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(section);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d();
    		}
    	};
    }

    function instance$Q($$self, $$props, $$invalidate) {
    	let $sessionStudents;

    	validate_store(sessionStudents, 'sessionStudents');
    	component_subscribe($$self, sessionStudents, $$value => { $sessionStudents = $$value; $$invalidate('$sessionStudents', $sessionStudents); });

    	

      let { sessionId } = $$props;

    	const writable_props = ['sessionId'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<PointsPanel> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('sessionId' in $$props) $$invalidate('sessionId', sessionId = $$props.sessionId);
    	};

    	return { sessionId, $sessionStudents };
    }

    class PointsPanel extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Q, create_fragment$R, safe_not_equal, ["sessionId"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.sessionId === undefined && !('sessionId' in props)) {
    			console.warn("<PointsPanel> was created without expected prop 'sessionId'");
    		}
    	}

    	get sessionId() {
    		throw new Error("<PointsPanel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sessionId(value) {
    		throw new Error("<PointsPanel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/session/StartedSession.svelte generated by Svelte v3.9.2 */

    const file$M = "admin/src/components/session/StartedSession.svelte";

    function get_each_context$g(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.student = list[i];
    	return child_ctx;
    }

    // (42:0) {#if $pointsLog && $pointsLog.length}
    function create_if_block_3$3(ctx) {
    	var button, i, t0, t1_value = ctx.$pointsLog[0].value + "", t1, t2, t3_value = ctx.$pointsLog[0].value - 1 && 's' || '' + "", t3, t4, t5_value = ctx.$pointsLog[0].student.englishName || ctx.$pointsLog[0].student.chineseName + "", t5, dispose;

    	return {
    		c: function create() {
    			button = element("button");
    			i = element("i");
    			t0 = text("\n    Undo ");
    			t1 = text(t1_value);
    			t2 = text(" point");
    			t3 = text(t3_value);
    			t4 = text(" for ");
    			t5 = text(t5_value);
    			attr(i, "class", "fas fa-undo");
    			add_location(i, file$M, 43, 4, 1241);
    			attr(button, "class", "button is-white");
    			add_location(button, file$M, 42, 2, 1157);
    			dispose = listen(button, "click", ctx.click_handler);
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);
    			append(button, i);
    			append(button, t0);
    			append(button, t1);
    			append(button, t2);
    			append(button, t3);
    			append(button, t4);
    			append(button, t5);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.$pointsLog) && t1_value !== (t1_value = ctx.$pointsLog[0].value + "")) {
    				set_data(t1, t1_value);
    			}

    			if ((changed.$pointsLog) && t3_value !== (t3_value = ctx.$pointsLog[0].value - 1 && 's' || '' + "")) {
    				set_data(t3, t3_value);
    			}

    			if ((changed.$pointsLog) && t5_value !== (t5_value = ctx.$pointsLog[0].student.englishName || ctx.$pointsLog[0].student.chineseName + "")) {
    				set_data(t5, t5_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(button);
    			}

    			dispose();
    		}
    	};
    }

    // (49:0) {#if $sessionStudents}
    function create_if_block_1$f(ctx) {
    	var t, if_block_anchor, current;

    	var pointspanel = new PointsPanel({
    		props: { sessionId: ctx.$session.id },
    		$$inline: true
    	});

    	var if_block = (ctx.absentStudents && ctx.absentStudents.length) && create_if_block_2$7(ctx);

    	return {
    		c: function create() {
    			pointspanel.$$.fragment.c();
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			mount_component(pointspanel, target, anchor);
    			insert(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var pointspanel_changes = {};
    			if (changed.$session) pointspanel_changes.sessionId = ctx.$session.id;
    			pointspanel.$set(pointspanel_changes);

    			if (ctx.absentStudents && ctx.absentStudents.length) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block_2$7(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(pointspanel.$$.fragment, local);

    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(pointspanel.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(pointspanel, detaching);

    			if (detaching) {
    				detach(t);
    			}

    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    // (52:2) {#if absentStudents && absentStudents.length}
    function create_if_block_2$7(ctx) {
    	var section, h3, t_1, each_blocks = [], each_1_lookup = new Map(), current;

    	var each_value = ctx.absentStudents;

    	const get_key = ctx => ctx.student.id;

    	for (var i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$g(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$g(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			section = element("section");
    			h3 = element("h3");
    			h3.textContent = "Absent";
    			t_1 = space();

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();
    			attr(h3, "class", "title is-4");
    			add_location(h3, file$M, 53, 4, 1585);
    			attr(section, "class", "absent svelte-1kn2bdy");
    			add_location(section, file$M, 52, 2, 1556);
    		},

    		m: function mount(target, anchor) {
    			insert(target, section, anchor);
    			append(section, h3);
    			append(section, t_1);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(section, null);

    			current = true;
    		},

    		p: function update(changed, ctx) {
    			const each_value = ctx.absentStudents;

    			group_outros();
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, section, outro_and_destroy_block, create_each_block$g, null, get_each_context$g);
    			check_outros();
    		},

    		i: function intro(local) {
    			if (current) return;
    			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

    			current = true;
    		},

    		o: function outro(local) {
    			for (i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(section);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d();
    		}
    	};
    }

    // (55:4) {#each absentStudents as student (student.id)}
    function create_each_block$g(key_1, ctx) {
    	var first, current;

    	var attendancerow = new AttendanceRow({
    		props: {
    		student: ctx.student,
    		sessionId: ctx.$session.id,
    		started: "true"
    	},
    		$$inline: true
    	});

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			first = empty();
    			attendancerow.$$.fragment.c();
    			this.first = first;
    		},

    		m: function mount(target, anchor) {
    			insert(target, first, anchor);
    			mount_component(attendancerow, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var attendancerow_changes = {};
    			if (changed.absentStudents) attendancerow_changes.student = ctx.student;
    			if (changed.$session) attendancerow_changes.sessionId = ctx.$session.id;
    			attendancerow.$set(attendancerow_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(attendancerow.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(attendancerow.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(first);
    			}

    			destroy_component(attendancerow, detaching);
    		}
    	};
    }

    // (68:4) {#if showEndModal}
    function create_if_block$u(ctx) {
    	var updating_open, current;

    	function confirmendsession_open_binding(value) {
    		ctx.confirmendsession_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let confirmendsession_props = {};
    	if (ctx.showEndModal !== void 0) {
    		confirmendsession_props.open = ctx.showEndModal;
    	}
    	var confirmendsession = new ConfirmEndSession({
    		props: confirmendsession_props,
    		$$inline: true
    	});

    	binding_callbacks.push(() => bind(confirmendsession, 'open', confirmendsession_open_binding));

    	return {
    		c: function create() {
    			confirmendsession.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(confirmendsession, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var confirmendsession_changes = {};
    			if (!updating_open && changed.showEndModal) {
    				confirmendsession_changes.open = ctx.showEndModal;
    			}
    			confirmendsession.$set(confirmendsession_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(confirmendsession.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(confirmendsession.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(confirmendsession, detaching);
    		}
    	};
    }

    // (67:0) <Modal bind:open={showEndModal}>
    function create_default_slot$a(ctx) {
    	var if_block_anchor, current;

    	var if_block = (ctx.showEndModal) && create_if_block$u(ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.showEndModal) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$u(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function create_fragment$S(ctx) {
    	var t0, p, span0, t1, t2, t3, br, t4, span1, t5, t6, t7, t8, t9, button, i, t10, t11, updating_open, current, dispose;

    	var if_block0 = (ctx.$pointsLog && ctx.$pointsLog.length) && create_if_block_3$3(ctx);

    	var if_block1 = (ctx.$sessionStudents) && create_if_block_1$f(ctx);

    	function modal_open_binding(value) {
    		ctx.modal_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let modal_props = {
    		$$slots: { default: [create_default_slot$a] },
    		$$scope: { ctx }
    	};
    	if (ctx.showEndModal !== void 0) {
    		modal_props.open = ctx.showEndModal;
    	}
    	var modal = new Modal({ props: modal_props, $$inline: true });

    	binding_callbacks.push(() => bind(modal, 'open', modal_open_binding));

    	return {
    		c: function create() {
    			t0 = space();
    			p = element("p");
    			span0 = element("span");
    			t1 = text("Started: ");
    			t2 = text(ctx.startedAt);
    			t3 = space();
    			br = element("br");
    			t4 = space();
    			span1 = element("span");
    			t5 = text("Scheduled End: ");
    			t6 = text(ctx.endsAt);
    			t7 = space();
    			if (if_block0) if_block0.c();
    			t8 = space();
    			if (if_block1) if_block1.c();
    			t9 = space();
    			button = element("button");
    			i = element("i");
    			t10 = text("\n  End class");
    			t11 = space();
    			modal.$$.fragment.c();
    			document.title = "Started Session";
    			attr(span0, "class", "start");
    			add_location(span0, file$M, 37, 2, 960);
    			add_location(br, file$M, 38, 2, 1010);
    			attr(span1, "class", "end svelte-1kn2bdy");
    			toggle_class(span1, "late", ctx.$session.endsAt < ctx.$time.toJSON());
    			add_location(span1, file$M, 39, 2, 1017);
    			attr(p, "class", "subtitle");
    			add_location(p, file$M, 36, 0, 937);
    			attr(i, "class", "fas fa-hourglass-end");
    			add_location(i, file$M, 62, 2, 1866);
    			attr(button, "class", "button is-primary end svelte-1kn2bdy");
    			add_location(button, file$M, 61, 0, 1784);
    			dispose = listen(button, "click", ctx.click_handler_1);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t0, anchor);
    			insert(target, p, anchor);
    			append(p, span0);
    			append(span0, t1);
    			append(span0, t2);
    			append(p, t3);
    			append(p, br);
    			append(p, t4);
    			append(p, span1);
    			append(span1, t5);
    			append(span1, t6);
    			insert(target, t7, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert(target, t8, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert(target, t9, anchor);
    			insert(target, button, anchor);
    			append(button, i);
    			append(button, t10);
    			insert(target, t11, anchor);
    			mount_component(modal, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (!current || changed.startedAt) {
    				set_data(t2, ctx.startedAt);
    			}

    			if (!current || changed.endsAt) {
    				set_data(t6, ctx.endsAt);
    			}

    			if ((changed.$session || changed.$time)) {
    				toggle_class(span1, "late", ctx.$session.endsAt < ctx.$time.toJSON());
    			}

    			if (ctx.$pointsLog && ctx.$pointsLog.length) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    				} else {
    					if_block0 = create_if_block_3$3(ctx);
    					if_block0.c();
    					if_block0.m(t8.parentNode, t8);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (ctx.$sessionStudents) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    					transition_in(if_block1, 1);
    				} else {
    					if_block1 = create_if_block_1$f(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t9.parentNode, t9);
    				}
    			} else if (if_block1) {
    				group_outros();
    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});
    				check_outros();
    			}

    			var modal_changes = {};
    			if (changed.$$scope || changed.showEndModal) modal_changes.$$scope = { changed, ctx };
    			if (!updating_open && changed.showEndModal) {
    				modal_changes.open = ctx.showEndModal;
    			}
    			modal.$set(modal_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);

    			transition_in(modal.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block1);
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t0);
    				detach(p);
    				detach(t7);
    			}

    			if (if_block0) if_block0.d(detaching);

    			if (detaching) {
    				detach(t8);
    			}

    			if (if_block1) if_block1.d(detaching);

    			if (detaching) {
    				detach(t9);
    				detach(button);
    				detach(t11);
    			}

    			destroy_component(modal, detaching);

    			dispose();
    		}
    	};
    }

    function instance$R($$self, $$props, $$invalidate) {
    	let $session, $sessionStudents, $time, $pointsLog;

    	validate_store(session, 'session');
    	component_subscribe($$self, session, $$value => { $session = $$value; $$invalidate('$session', $session); });
    	validate_store(sessionStudents, 'sessionStudents');
    	component_subscribe($$self, sessionStudents, $$value => { $sessionStudents = $$value; $$invalidate('$sessionStudents', $sessionStudents); });
    	validate_store(time, 'time');
    	component_subscribe($$self, time, $$value => { $time = $$value; $$invalidate('$time', $time); });
    	validate_store(pointsLog, 'pointsLog');
    	component_subscribe($$self, pointsLog, $$value => { $pointsLog = $$value; $$invalidate('$pointsLog', $pointsLog); });

    	

      let showEndModal = false;

    	function click_handler() {
    		return points.undo($pointsLog[0].id);
    	}

    	function click_handler_1() { showEndModal = true; $$invalidate('showEndModal', showEndModal); }

    	function confirmendsession_open_binding(value) {
    		showEndModal = value;
    		$$invalidate('showEndModal', showEndModal);
    	}

    	function modal_open_binding(value) {
    		showEndModal = value;
    		$$invalidate('showEndModal', showEndModal);
    	}

    	let startedAt, endsAt, absentStudents;

    	$$self.$$.update = ($$dirty = { $session: 1, $sessionStudents: 1 }) => {
    		if ($$dirty.$session) { $$invalidate('startedAt', startedAt = formatDistance$1(new Date($session.startedAt), new Date(), { addSuffix: true })); }
    		if ($$dirty.$session) { $$invalidate('endsAt', endsAt = formatDistance$1(new Date($session.endsAt), new Date(), { addSuffix: true })); }
    		if ($$dirty.$sessionStudents) { $$invalidate('absentStudents', absentStudents = $sessionStudents && $sessionStudents.filter(student => {
            return student.attendance && student.attendance.status === 'Absent'
          })); }
    	};

    	return {
    		showEndModal,
    		startedAt,
    		$session,
    		endsAt,
    		absentStudents,
    		$sessionStudents,
    		$time,
    		$pointsLog,
    		click_handler,
    		click_handler_1,
    		confirmendsession_open_binding,
    		modal_open_binding
    	};
    }

    class StartedSession extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$R, create_fragment$S, safe_not_equal, []);
    	}
    }

    /* admin/src/components/session/ResultsRow.svelte generated by Svelte v3.9.2 */

    const file$N = "admin/src/components/session/ResultsRow.svelte";

    // (15:2) {#if result.status !== "Absent"}
    function create_if_block_1$g(ctx) {
    	var span, i, t0, t1;

    	return {
    		c: function create() {
    			span = element("span");
    			i = element("i");
    			t0 = text("×");
    			t1 = text(ctx.pointsTally);
    			attr(i, "class", "fas fa-star");
    			add_location(i, file$N, 15, 22, 270);
    			attr(span, "class", "stars");
    			add_location(span, file$N, 15, 2, 250);
    		},

    		m: function mount(target, anchor) {
    			insert(target, span, anchor);
    			append(span, i);
    			append(span, t0);
    			append(span, t1);
    		},

    		p: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(span);
    			}
    		}
    	};
    }

    // (22:4) {#if result.status !== "Present"}
    function create_if_block$v(ctx) {
    	var t_value = ctx.result.status + "", t;

    	return {
    		c: function create() {
    			t = text(t_value);
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.result) && t_value !== (t_value = ctx.result.status + "")) {
    				set_data(t, t_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    function create_fragment$T(ctx) {
    	var li, t0, span0, t1_value = ctx.result.student.englishName || ctx.result.student.chineseName + "", t1, t2, span1;

    	var if_block0 = (ctx.result.status !== "Absent") && create_if_block_1$g(ctx);

    	var if_block1 = (ctx.result.status !== "Present") && create_if_block$v(ctx);

    	return {
    		c: function create() {
    			li = element("li");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			span0 = element("span");
    			t1 = text(t1_value);
    			t2 = space();
    			span1 = element("span");
    			if (if_block1) if_block1.c();
    			attr(span0, "class", "name");
    			add_location(span0, file$N, 18, 2, 336);
    			attr(span1, "class", "status svelte-1r4n15n");
    			add_location(span1, file$N, 20, 2, 424);
    			attr(li, "class", "svelte-1r4n15n");
    			toggle_class(li, "absent", ctx.result.status==="Absent");
    			add_location(li, file$N, 13, 0, 167);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, li, anchor);
    			if (if_block0) if_block0.m(li, null);
    			append(li, t0);
    			append(li, span0);
    			append(span0, t1);
    			append(li, t2);
    			append(li, span1);
    			if (if_block1) if_block1.m(span1, null);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.result.status !== "Absent") {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    				} else {
    					if_block0 = create_if_block_1$g(ctx);
    					if_block0.c();
    					if_block0.m(li, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if ((changed.result) && t1_value !== (t1_value = ctx.result.student.englishName || ctx.result.student.chineseName + "")) {
    				set_data(t1, t1_value);
    			}

    			if (ctx.result.status !== "Present") {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    				} else {
    					if_block1 = create_if_block$v(ctx);
    					if_block1.c();
    					if_block1.m(span1, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (changed.result) {
    				toggle_class(li, "absent", ctx.result.status==="Absent");
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(li);
    			}

    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};
    }

    function instance$S($$self, $$props, $$invalidate) {
    	let { result = {} } = $$props;

      const pointsTally = ('0' + result.pointsTally).slice(-2);

    	const writable_props = ['result'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<ResultsRow> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('result' in $$props) $$invalidate('result', result = $$props.result);
    	};

    	return { result, pointsTally };
    }

    class ResultsRow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$S, create_fragment$T, safe_not_equal, ["result"]);
    	}

    	get result() {
    		throw new Error("<ResultsRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set result(value) {
    		throw new Error("<ResultsRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/session/EditTimesForm.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$e } = globals;

    const file$O = "admin/src/components/session/EditTimesForm.svelte";

    function create_fragment$U(ctx) {
    	var h2, t1, t2, form_1, updating_value, t3, updating_value_1, t4, updating_value_2, t5, updating_value_3, t6, div, button, t8, input4, current, dispose;

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	function input0_value_binding(value) {
    		ctx.input0_value_binding.call(null, value);
    		updating_value = true;
    		add_flush_callback(() => updating_value = false);
    	}

    	let input0_props = {
    		label: "Scheduled start",
    		type: "datetime-local",
    		required: true
    	};
    	if (ctx.startsAt !== void 0) {
    		input0_props.value = ctx.startsAt;
    	}
    	var input0 = new Input({ props: input0_props, $$inline: true });

    	binding_callbacks.push(() => bind(input0, 'value', input0_value_binding));

    	function input1_value_binding(value_1) {
    		ctx.input1_value_binding.call(null, value_1);
    		updating_value_1 = true;
    		add_flush_callback(() => updating_value_1 = false);
    	}

    	let input1_props = {
    		label: "Actual start",
    		type: "datetime-local",
    		required: true
    	};
    	if (ctx.startedAt !== void 0) {
    		input1_props.value = ctx.startedAt;
    	}
    	var input1 = new Input({ props: input1_props, $$inline: true });

    	binding_callbacks.push(() => bind(input1, 'value', input1_value_binding));

    	function input2_value_binding(value_2) {
    		ctx.input2_value_binding.call(null, value_2);
    		updating_value_2 = true;
    		add_flush_callback(() => updating_value_2 = false);
    	}

    	let input2_props = {
    		label: "Scheduled end",
    		type: "datetime-local",
    		required: true
    	};
    	if (ctx.endsAt !== void 0) {
    		input2_props.value = ctx.endsAt;
    	}
    	var input2 = new Input({ props: input2_props, $$inline: true });

    	binding_callbacks.push(() => bind(input2, 'value', input2_value_binding));

    	function input3_value_binding(value_3) {
    		ctx.input3_value_binding.call(null, value_3);
    		updating_value_3 = true;
    		add_flush_callback(() => updating_value_3 = false);
    	}

    	let input3_props = {
    		label: "Actual end",
    		type: "datetime-local",
    		required: true
    	};
    	if (ctx.endedAt !== void 0) {
    		input3_props.value = ctx.endedAt;
    	}
    	var input3 = new Input({ props: input3_props, $$inline: true });

    	binding_callbacks.push(() => bind(input3, 'value', input3_value_binding));

    	return {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "Edit session times";
    			t1 = space();
    			error.$$.fragment.c();
    			t2 = space();
    			form_1 = element("form");
    			input0.$$.fragment.c();
    			t3 = space();
    			input1.$$.fragment.c();
    			t4 = space();
    			input2.$$.fragment.c();
    			t5 = space();
    			input3.$$.fragment.c();
    			t6 = space();
    			div = element("div");
    			button = element("button");
    			button.textContent = "Save";
    			t8 = space();
    			input4 = element("input");
    			attr(h2, "class", "title");
    			add_location(h2, file$O, 30, 0, 710);
    			attr(button, "class", "button is-primary");
    			attr(button, "type", "submit");
    			add_location(button, file$O, 39, 4, 1228);
    			attr(input4, "class", "button");
    			attr(input4, "type", "reset");
    			input4.value = "Cancel";
    			add_location(input4, file$O, 40, 4, 1317);
    			attr(div, "class", "buttons");
    			add_location(div, file$O, 38, 2, 1202);
    			form_1.noValidate = true;
    			add_location(form_1, file$O, 32, 0, 771);

    			dispose = [
    				listen(form_1, "submit", prevent_default(ctx.handleSubmit)),
    				listen(form_1, "reset", ctx.reset_handler)
    			];
    		},

    		l: function claim(nodes) {
    			throw new Error_1$e("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, h2, anchor);
    			insert(target, t1, anchor);
    			mount_component(error, target, anchor);
    			insert(target, t2, anchor);
    			insert(target, form_1, anchor);
    			mount_component(input0, form_1, null);
    			append(form_1, t3);
    			mount_component(input1, form_1, null);
    			append(form_1, t4);
    			mount_component(input2, form_1, null);
    			append(form_1, t5);
    			mount_component(input3, form_1, null);
    			append(form_1, t6);
    			append(form_1, div);
    			append(div, button);
    			ctx.button_binding(button);
    			append(div, t8);
    			append(div, input4);
    			ctx.form_1_binding(form_1);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);

    			var input0_changes = {};
    			if (!updating_value && changed.startsAt) {
    				input0_changes.value = ctx.startsAt;
    			}
    			input0.$set(input0_changes);

    			var input1_changes = {};
    			if (!updating_value_1 && changed.startedAt) {
    				input1_changes.value = ctx.startedAt;
    			}
    			input1.$set(input1_changes);

    			var input2_changes = {};
    			if (!updating_value_2 && changed.endsAt) {
    				input2_changes.value = ctx.endsAt;
    			}
    			input2.$set(input2_changes);

    			var input3_changes = {};
    			if (!updating_value_3 && changed.endedAt) {
    				input3_changes.value = ctx.endedAt;
    			}
    			input3.$set(input3_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);

    			transition_in(input0.$$.fragment, local);

    			transition_in(input1.$$.fragment, local);

    			transition_in(input2.$$.fragment, local);

    			transition_in(input3.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			transition_out(input0.$$.fragment, local);
    			transition_out(input1.$$.fragment, local);
    			transition_out(input2.$$.fragment, local);
    			transition_out(input3.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h2);
    				detach(t1);
    			}

    			destroy_component(error, detaching);

    			if (detaching) {
    				detach(t2);
    				detach(form_1);
    			}

    			destroy_component(input0);

    			destroy_component(input1);

    			destroy_component(input2);

    			destroy_component(input3);

    			ctx.button_binding(null);
    			ctx.form_1_binding(null);
    			run_all(dispose);
    		}
    	};
    }

    function instance$T($$self, $$props, $$invalidate) {
    	

      const dispatch = createEventDispatcher();

      let { errors, loading = false } = $$props;
      let form;
      let saveButton;
      let { startsAt = '', endsAt = '', startedAt = '', endedAt = '' } = $$props;

      const handleSubmit = () => {
        const isValid = form.checkValidity();
        if (!isValid) {
          notifications.add({
            text: 'Please fix form errors first.',
            type: 'danger'
          });
          return
        }
        dispatch('submit', { startsAt, endsAt, startedAt, endedAt });
      };

    	const writable_props = ['errors', 'loading', 'startsAt', 'endsAt', 'startedAt', 'endedAt'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<EditTimesForm> was created with unknown prop '${key}'`);
    	});

    	function reset_handler(event) {
    		bubble($$self, event);
    	}

    	function input0_value_binding(value) {
    		startsAt = value;
    		$$invalidate('startsAt', startsAt);
    	}

    	function input1_value_binding(value_1) {
    		startedAt = value_1;
    		$$invalidate('startedAt', startedAt);
    	}

    	function input2_value_binding(value_2) {
    		endsAt = value_2;
    		$$invalidate('endsAt', endsAt);
    	}

    	function input3_value_binding(value_3) {
    		endedAt = value_3;
    		$$invalidate('endedAt', endedAt);
    	}

    	function button_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('saveButton', saveButton = $$value);
    		});
    	}

    	function form_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('form', form = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ('errors' in $$props) $$invalidate('errors', errors = $$props.errors);
    		if ('loading' in $$props) $$invalidate('loading', loading = $$props.loading);
    		if ('startsAt' in $$props) $$invalidate('startsAt', startsAt = $$props.startsAt);
    		if ('endsAt' in $$props) $$invalidate('endsAt', endsAt = $$props.endsAt);
    		if ('startedAt' in $$props) $$invalidate('startedAt', startedAt = $$props.startedAt);
    		if ('endedAt' in $$props) $$invalidate('endedAt', endedAt = $$props.endedAt);
    	};

    	return {
    		errors,
    		loading,
    		form,
    		saveButton,
    		startsAt,
    		endsAt,
    		startedAt,
    		endedAt,
    		handleSubmit,
    		reset_handler,
    		input0_value_binding,
    		input1_value_binding,
    		input2_value_binding,
    		input3_value_binding,
    		button_binding,
    		form_1_binding
    	};
    }

    class EditTimesForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$T, create_fragment$U, safe_not_equal, ["errors", "loading", "startsAt", "endsAt", "startedAt", "endedAt"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.errors === undefined && !('errors' in props)) {
    			console.warn("<EditTimesForm> was created without expected prop 'errors'");
    		}
    	}

    	get errors() {
    		throw new Error_1$e("<EditTimesForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set errors(value) {
    		throw new Error_1$e("<EditTimesForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loading() {
    		throw new Error_1$e("<EditTimesForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loading(value) {
    		throw new Error_1$e("<EditTimesForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get startsAt() {
    		throw new Error_1$e("<EditTimesForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set startsAt(value) {
    		throw new Error_1$e("<EditTimesForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get endsAt() {
    		throw new Error_1$e("<EditTimesForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set endsAt(value) {
    		throw new Error_1$e("<EditTimesForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get startedAt() {
    		throw new Error_1$e("<EditTimesForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set startedAt(value) {
    		throw new Error_1$e("<EditTimesForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get endedAt() {
    		throw new Error_1$e("<EditTimesForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set endedAt(value) {
    		throw new Error_1$e("<EditTimesForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/session/EditTimes.svelte generated by Svelte v3.9.2 */

    const file$P = "admin/src/components/session/EditTimes.svelte";

    // (48:0) <Modal bind:open>
    function create_default_slot$b(ctx) {
    	var current;

    	var edittimesform = new EditTimesForm({
    		props: {
    		startsAt: ctx.localTime(ctx.$session.startsAt),
    		endsAt: ctx.localTime(ctx.$session.endsAt),
    		startedAt: ctx.localTime(ctx.$session.startedAt),
    		endedAt: ctx.localTime(ctx.$session.endedAt),
    		loading: ctx.loading,
    		errors: ctx.errors
    	},
    		$$inline: true
    	});
    	edittimesform.$on("submit", ctx.save);
    	edittimesform.$on("reset", ctx.reset);

    	return {
    		c: function create() {
    			edittimesform.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(edittimesform, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var edittimesform_changes = {};
    			if (changed.localTime || changed.$session) edittimesform_changes.startsAt = ctx.localTime(ctx.$session.startsAt);
    			if (changed.localTime || changed.$session) edittimesform_changes.endsAt = ctx.localTime(ctx.$session.endsAt);
    			if (changed.localTime || changed.$session) edittimesform_changes.startedAt = ctx.localTime(ctx.$session.startedAt);
    			if (changed.localTime || changed.$session) edittimesform_changes.endedAt = ctx.localTime(ctx.$session.endedAt);
    			if (changed.loading) edittimesform_changes.loading = ctx.loading;
    			if (changed.errors) edittimesform_changes.errors = ctx.errors;
    			edittimesform.$set(edittimesform_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(edittimesform.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(edittimesform.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(edittimesform, detaching);
    		}
    	};
    }

    function create_fragment$V(ctx) {
    	var button, t_1, updating_open, current, dispose;

    	function modal_open_binding(value) {
    		ctx.modal_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let modal_props = {
    		$$slots: { default: [create_default_slot$b] },
    		$$scope: { ctx }
    	};
    	if (ctx.open !== void 0) {
    		modal_props.open = ctx.open;
    	}
    	var modal = new Modal({ props: modal_props, $$inline: true });

    	binding_callbacks.push(() => bind(modal, 'open', modal_open_binding));

    	return {
    		c: function create() {
    			button = element("button");
    			button.textContent = "edit times";
    			t_1 = space();
    			modal.$$.fragment.c();
    			attr(button, "class", "button svelte-1ih8yvt");
    			add_location(button, file$P, 45, 0, 1335);
    			dispose = listen(button, "click", ctx.click_handler);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);
    			insert(target, t_1, anchor);
    			mount_component(modal, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var modal_changes = {};
    			if (changed.$$scope || changed.$session || changed.loading || changed.errors) modal_changes.$$scope = { changed, ctx };
    			if (!updating_open && changed.open) {
    				modal_changes.open = ctx.open;
    			}
    			modal.$set(modal_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(button);
    				detach(t_1);
    			}

    			destroy_component(modal, detaching);

    			dispose();
    		}
    	};
    }

    function instance$U($$self, $$props, $$invalidate) {
    	let $session;

    	validate_store(session, 'session');
    	component_subscribe($$self, session, $$value => { $session = $$value; $$invalidate('$session', $session); });

    	

      let open = false;
      let errors = '';
      let loading = false;

      const reset = () => {
        $$invalidate('open', open = false);
        $$invalidate('errors', errors = '');
      };

      const save = async ({ detail }) => {
        $$invalidate('loading', loading = true);
        detail.startsAt = new Date(detail.startsAt).toISOString();
        detail.endsAt = new Date(detail.endsAt).toISOString();
        detail.startedAt = new Date(detail.startedAt).toISOString();
        detail.endedAt = new Date(detail.endedAt).toISOString();
        try {
          const updatedSession = await sessions.patch($session.id, detail);
          const date = formatRelative$1(new Date(detail.startsAt), new Date(), { addSuffix: true });
          notifications.add({ text: `Updated session to ${date} with ${updatedSession.group.name} class`, type: 'success' });
          reset();
        } catch (error) {
          $$invalidate('errors', errors = error);
          notifications.add({ text: "Couldn't save changes to session", type: 'danger' });
        } finally {
          $$invalidate('loading', loading = false);
        }
      };

      const localTime = (time) => format(new Date(time), "yyyy-MM-dd'T'HH:mm");

    	function click_handler() { open = true; $$invalidate('open', open); }

    	function modal_open_binding(value) {
    		open = value;
    		$$invalidate('open', open);
    	}

    	return {
    		open,
    		errors,
    		loading,
    		reset,
    		save,
    		localTime,
    		$session,
    		click_handler,
    		modal_open_binding
    	};
    }

    class EditTimes extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$U, create_fragment$V, safe_not_equal, []);
    	}
    }

    /* admin/src/components/session/AddLessonToSession.svelte generated by Svelte v3.9.2 */

    function create_fragment$W(ctx) {
    	var updating_lessonId, current;

    	function lessonselect_lessonId_binding(value) {
    		ctx.lessonselect_lessonId_binding.call(null, value);
    		updating_lessonId = true;
    		add_flush_callback(() => updating_lessonId = false);
    	}

    	let lessonselect_props = {};
    	if (ctx.lessonId !== void 0) {
    		lessonselect_props.lessonId = ctx.lessonId;
    	}
    	var lessonselect = new LessonSelect({
    		props: lessonselect_props,
    		$$inline: true
    	});

    	binding_callbacks.push(() => bind(lessonselect, 'lessonId', lessonselect_lessonId_binding));

    	return {
    		c: function create() {
    			lessonselect.$$.fragment.c();
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			mount_component(lessonselect, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var lessonselect_changes = {};
    			if (!updating_lessonId && changed.lessonId) {
    				lessonselect_changes.lessonId = ctx.lessonId;
    			}
    			lessonselect.$set(lessonselect_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(lessonselect.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(lessonselect.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(lessonselect, detaching);
    		}
    	};
    }

    function instance$V($$self, $$props, $$invalidate) {
    	

      let lessonId;
      let { id } = $$props;

      const add = async () => {
        if (!lessonId) return
        const result = await request(ADD_LESSON_TO_SESSION, { id, lessonId });
      };

    	const writable_props = ['id'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<AddLessonToSession> was created with unknown prop '${key}'`);
    	});

    	function lessonselect_lessonId_binding(value) {
    		lessonId = value;
    		$$invalidate('lessonId', lessonId);
    	}

    	$$self.$set = $$props => {
    		if ('id' in $$props) $$invalidate('id', id = $$props.id);
    	};

    	let added;

    	$$self.$$.update = ($$dirty = { lessonId: 1 }) => {
    		if ($$dirty.lessonId) { added = add(); }
    	};

    	return {
    		lessonId,
    		id,
    		lessonselect_lessonId_binding
    	};
    }

    class AddLessonToSession extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$V, create_fragment$W, safe_not_equal, ["id"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.id === undefined && !('id' in props)) {
    			console.warn("<AddLessonToSession> was created without expected prop 'id'");
    		}
    	}

    	get id() {
    		throw new Error("<AddLessonToSession>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<AddLessonToSession>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const CREATE_REPORT = /* GraphQL */ `
 mutation CreateReport($classSessionId: ID!) {
   createReport(classSessionId: $classSessionId) {
     id
   }
 }`;

    /* admin/src/components/report/CreateReport.svelte generated by Svelte v3.9.2 */

    const file$Q = "admin/src/components/report/CreateReport.svelte";

    function create_fragment$X(ctx) {
    	var button, dispose;

    	return {
    		c: function create_1() {
    			button = element("button");
    			button.textContent = "Create report";
    			attr(button, "class", "button svelte-1ih8yvt");
    			add_location(button, file$Q, 18, 0, 323);
    			dispose = listen(button, "click", ctx.create);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);
    		},

    		p: noop,
    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(button);
    			}

    			dispose();
    		}
    	};
    }

    function instance$W($$self, $$props, $$invalidate) {
    	

      let { classSessionId } = $$props;

      const create = async () => {
        // create a report from lesson
        await request(CREATE_REPORT, { classSessionId });
      };

    	const writable_props = ['classSessionId'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<CreateReport> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('classSessionId' in $$props) $$invalidate('classSessionId', classSessionId = $$props.classSessionId);
    	};

    	return { classSessionId, create };
    }

    class CreateReport extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$W, create_fragment$X, safe_not_equal, ["classSessionId"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.classSessionId === undefined && !('classSessionId' in props)) {
    			console.warn("<CreateReport> was created without expected prop 'classSessionId'");
    		}
    	}

    	get classSessionId() {
    		throw new Error("<CreateReport>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classSessionId(value) {
    		throw new Error("<CreateReport>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var marked = createCommonjsModule(function (module, exports) {
    (function(root) {

    /**
     * Block-Level Grammar
     */

    var block = {
      newline: /^\n+/,
      code: /^( {4}[^\n]+\n*)+/,
      fences: /^ {0,3}(`{3,}|~{3,})([^`~\n]*)\n(?:|([\s\S]*?)\n)(?: {0,3}\1[~`]* *(?:\n+|$)|$)/,
      hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,
      heading: /^ {0,3}(#{1,6}) +([^\n]*?)(?: +#+)? *(?:\n+|$)/,
      blockquote: /^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,
      list: /^( {0,3})(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
      html: '^ {0,3}(?:' // optional indentation
        + '<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)' // (1)
        + '|comment[^\\n]*(\\n+|$)' // (2)
        + '|<\\?[\\s\\S]*?\\?>\\n*' // (3)
        + '|<![A-Z][\\s\\S]*?>\\n*' // (4)
        + '|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>\\n*' // (5)
        + '|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)' // (6)
        + '|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) open tag
        + '|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:\\n{2,}|$)' // (7) closing tag
        + ')',
      def: /^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,
      nptable: noop,
      table: noop,
      lheading: /^([^\n]+)\n {0,3}(=+|-+) *(?:\n+|$)/,
      // regex template, placeholders will be replaced according to different paragraph
      // interruption rules of commonmark and the original markdown spec:
      _paragraph: /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html)[^\n]+)*)/,
      text: /^[^\n]+/
    };

    block._label = /(?!\s*\])(?:\\[\[\]]|[^\[\]])+/;
    block._title = /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/;
    block.def = edit(block.def)
      .replace('label', block._label)
      .replace('title', block._title)
      .getRegex();

    block.bullet = /(?:[*+-]|\d{1,9}\.)/;
    block.item = /^( *)(bull) ?[^\n]*(?:\n(?!\1bull ?)[^\n]*)*/;
    block.item = edit(block.item, 'gm')
      .replace(/bull/g, block.bullet)
      .getRegex();

    block.list = edit(block.list)
      .replace(/bull/g, block.bullet)
      .replace('hr', '\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))')
      .replace('def', '\\n+(?=' + block.def.source + ')')
      .getRegex();

    block._tag = 'address|article|aside|base|basefont|blockquote|body|caption'
      + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'
      + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'
      + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'
      + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr'
      + '|track|ul';
    block._comment = /<!--(?!-?>)[\s\S]*?-->/;
    block.html = edit(block.html, 'i')
      .replace('comment', block._comment)
      .replace('tag', block._tag)
      .replace('attribute', / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/)
      .getRegex();

    block.paragraph = edit(block._paragraph)
      .replace('hr', block.hr)
      .replace('heading', ' {0,3}#{1,6} +')
      .replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs
      .replace('blockquote', ' {0,3}>')
      .replace('fences', ' {0,3}(?:`{3,}|~{3,})[^`\\n]*\\n')
      .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt
      .replace('html', '</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|!--)')
      .replace('tag', block._tag) // pars can be interrupted by type (6) html blocks
      .getRegex();

    block.blockquote = edit(block.blockquote)
      .replace('paragraph', block.paragraph)
      .getRegex();

    /**
     * Normal Block Grammar
     */

    block.normal = merge({}, block);

    /**
     * GFM Block Grammar
     */

    block.gfm = merge({}, block.normal, {
      nptable: /^ *([^|\n ].*\|.*)\n *([-:]+ *\|[-| :]*)(?:\n((?:.*[^>\n ].*(?:\n|$))*)\n*|$)/,
      table: /^ *\|(.+)\n *\|?( *[-:]+[-| :]*)(?:\n((?: *[^>\n ].*(?:\n|$))*)\n*|$)/
    });

    /**
     * Pedantic grammar (original John Gruber's loose markdown specification)
     */

    block.pedantic = merge({}, block.normal, {
      html: edit(
        '^ *(?:comment *(?:\\n|\\s*$)'
        + '|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)' // closed tag
        + '|<tag(?:"[^"]*"|\'[^\']*\'|\\s[^\'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))')
        .replace('comment', block._comment)
        .replace(/tag/g, '(?!(?:'
          + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'
          + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'
          + '\\b)\\w+(?!:|[^\\w\\s@]*@)\\b')
        .getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^ *(#{1,6}) *([^\n]+?) *(?:#+ *)?(?:\n+|$)/,
      fences: noop, // fences not supported
      paragraph: edit(block.normal._paragraph)
        .replace('hr', block.hr)
        .replace('heading', ' *#{1,6} *[^\n]')
        .replace('lheading', block.lheading)
        .replace('blockquote', ' {0,3}>')
        .replace('|fences', '')
        .replace('|list', '')
        .replace('|html', '')
        .getRegex()
    });

    /**
     * Block Lexer
     */

    function Lexer(options) {
      this.tokens = [];
      this.tokens.links = Object.create(null);
      this.options = options || marked.defaults;
      this.rules = block.normal;

      if (this.options.pedantic) {
        this.rules = block.pedantic;
      } else if (this.options.gfm) {
        this.rules = block.gfm;
      }
    }

    /**
     * Expose Block Rules
     */

    Lexer.rules = block;

    /**
     * Static Lex Method
     */

    Lexer.lex = function(src, options) {
      var lexer = new Lexer(options);
      return lexer.lex(src);
    };

    /**
     * Preprocessing
     */

    Lexer.prototype.lex = function(src) {
      src = src
        .replace(/\r\n|\r/g, '\n')
        .replace(/\t/g, '    ')
        .replace(/\u00a0/g, ' ')
        .replace(/\u2424/g, '\n');

      return this.token(src, true);
    };

    /**
     * Lexing
     */

    Lexer.prototype.token = function(src, top) {
      src = src.replace(/^ +$/gm, '');
      var next,
          loose,
          cap,
          bull,
          b,
          item,
          listStart,
          listItems,
          t,
          space,
          i,
          tag,
          l,
          isordered,
          istask,
          ischecked;

      while (src) {
        // newline
        if (cap = this.rules.newline.exec(src)) {
          src = src.substring(cap[0].length);
          if (cap[0].length > 1) {
            this.tokens.push({
              type: 'space'
            });
          }
        }

        // code
        if (cap = this.rules.code.exec(src)) {
          var lastToken = this.tokens[this.tokens.length - 1];
          src = src.substring(cap[0].length);
          // An indented code block cannot interrupt a paragraph.
          if (lastToken && lastToken.type === 'paragraph') {
            lastToken.text += '\n' + cap[0].trimRight();
          } else {
            cap = cap[0].replace(/^ {4}/gm, '');
            this.tokens.push({
              type: 'code',
              codeBlockStyle: 'indented',
              text: !this.options.pedantic
                ? rtrim(cap, '\n')
                : cap
            });
          }
          continue;
        }

        // fences
        if (cap = this.rules.fences.exec(src)) {
          src = src.substring(cap[0].length);
          this.tokens.push({
            type: 'code',
            lang: cap[2] ? cap[2].trim() : cap[2],
            text: cap[3] || ''
          });
          continue;
        }

        // heading
        if (cap = this.rules.heading.exec(src)) {
          src = src.substring(cap[0].length);
          this.tokens.push({
            type: 'heading',
            depth: cap[1].length,
            text: cap[2]
          });
          continue;
        }

        // table no leading pipe (gfm)
        if (cap = this.rules.nptable.exec(src)) {
          item = {
            type: 'table',
            header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
            align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
            cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
          };

          if (item.header.length === item.align.length) {
            src = src.substring(cap[0].length);

            for (i = 0; i < item.align.length; i++) {
              if (/^ *-+: *$/.test(item.align[i])) {
                item.align[i] = 'right';
              } else if (/^ *:-+: *$/.test(item.align[i])) {
                item.align[i] = 'center';
              } else if (/^ *:-+ *$/.test(item.align[i])) {
                item.align[i] = 'left';
              } else {
                item.align[i] = null;
              }
            }

            for (i = 0; i < item.cells.length; i++) {
              item.cells[i] = splitCells(item.cells[i], item.header.length);
            }

            this.tokens.push(item);

            continue;
          }
        }

        // hr
        if (cap = this.rules.hr.exec(src)) {
          src = src.substring(cap[0].length);
          this.tokens.push({
            type: 'hr'
          });
          continue;
        }

        // blockquote
        if (cap = this.rules.blockquote.exec(src)) {
          src = src.substring(cap[0].length);

          this.tokens.push({
            type: 'blockquote_start'
          });

          cap = cap[0].replace(/^ *> ?/gm, '');

          // Pass `top` to keep the current
          // "toplevel" state. This is exactly
          // how markdown.pl works.
          this.token(cap, top);

          this.tokens.push({
            type: 'blockquote_end'
          });

          continue;
        }

        // list
        if (cap = this.rules.list.exec(src)) {
          src = src.substring(cap[0].length);
          bull = cap[2];
          isordered = bull.length > 1;

          listStart = {
            type: 'list_start',
            ordered: isordered,
            start: isordered ? +bull : '',
            loose: false
          };

          this.tokens.push(listStart);

          // Get each top-level item.
          cap = cap[0].match(this.rules.item);

          listItems = [];
          next = false;
          l = cap.length;
          i = 0;

          for (; i < l; i++) {
            item = cap[i];

            // Remove the list item's bullet
            // so it is seen as the next token.
            space = item.length;
            item = item.replace(/^ *([*+-]|\d+\.) */, '');

            // Outdent whatever the
            // list item contains. Hacky.
            if (~item.indexOf('\n ')) {
              space -= item.length;
              item = !this.options.pedantic
                ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
                : item.replace(/^ {1,4}/gm, '');
            }

            // Determine whether the next list item belongs here.
            // Backpedal if it does not belong in this list.
            if (i !== l - 1) {
              b = block.bullet.exec(cap[i + 1])[0];
              if (bull.length > 1 ? b.length === 1
                : (b.length > 1 || (this.options.smartLists && b !== bull))) {
                src = cap.slice(i + 1).join('\n') + src;
                i = l - 1;
              }
            }

            // Determine whether item is loose or not.
            // Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
            // for discount behavior.
            loose = next || /\n\n(?!\s*$)/.test(item);
            if (i !== l - 1) {
              next = item.charAt(item.length - 1) === '\n';
              if (!loose) loose = next;
            }

            if (loose) {
              listStart.loose = true;
            }

            // Check for task list items
            istask = /^\[[ xX]\] /.test(item);
            ischecked = undefined;
            if (istask) {
              ischecked = item[1] !== ' ';
              item = item.replace(/^\[[ xX]\] +/, '');
            }

            t = {
              type: 'list_item_start',
              task: istask,
              checked: ischecked,
              loose: loose
            };

            listItems.push(t);
            this.tokens.push(t);

            // Recurse.
            this.token(item, false);

            this.tokens.push({
              type: 'list_item_end'
            });
          }

          if (listStart.loose) {
            l = listItems.length;
            i = 0;
            for (; i < l; i++) {
              listItems[i].loose = true;
            }
          }

          this.tokens.push({
            type: 'list_end'
          });

          continue;
        }

        // html
        if (cap = this.rules.html.exec(src)) {
          src = src.substring(cap[0].length);
          this.tokens.push({
            type: this.options.sanitize
              ? 'paragraph'
              : 'html',
            pre: !this.options.sanitizer
              && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
            text: this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0]
          });
          continue;
        }

        // def
        if (top && (cap = this.rules.def.exec(src))) {
          src = src.substring(cap[0].length);
          if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);
          tag = cap[1].toLowerCase().replace(/\s+/g, ' ');
          if (!this.tokens.links[tag]) {
            this.tokens.links[tag] = {
              href: cap[2],
              title: cap[3]
            };
          }
          continue;
        }

        // table (gfm)
        if (cap = this.rules.table.exec(src)) {
          item = {
            type: 'table',
            header: splitCells(cap[1].replace(/^ *| *\| *$/g, '')),
            align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
            cells: cap[3] ? cap[3].replace(/\n$/, '').split('\n') : []
          };

          if (item.header.length === item.align.length) {
            src = src.substring(cap[0].length);

            for (i = 0; i < item.align.length; i++) {
              if (/^ *-+: *$/.test(item.align[i])) {
                item.align[i] = 'right';
              } else if (/^ *:-+: *$/.test(item.align[i])) {
                item.align[i] = 'center';
              } else if (/^ *:-+ *$/.test(item.align[i])) {
                item.align[i] = 'left';
              } else {
                item.align[i] = null;
              }
            }

            for (i = 0; i < item.cells.length; i++) {
              item.cells[i] = splitCells(
                item.cells[i].replace(/^ *\| *| *\| *$/g, ''),
                item.header.length);
            }

            this.tokens.push(item);

            continue;
          }
        }

        // lheading
        if (cap = this.rules.lheading.exec(src)) {
          src = src.substring(cap[0].length);
          this.tokens.push({
            type: 'heading',
            depth: cap[2].charAt(0) === '=' ? 1 : 2,
            text: cap[1]
          });
          continue;
        }

        // top-level paragraph
        if (top && (cap = this.rules.paragraph.exec(src))) {
          src = src.substring(cap[0].length);
          this.tokens.push({
            type: 'paragraph',
            text: cap[1].charAt(cap[1].length - 1) === '\n'
              ? cap[1].slice(0, -1)
              : cap[1]
          });
          continue;
        }

        // text
        if (cap = this.rules.text.exec(src)) {
          // Top-level should never reach here.
          src = src.substring(cap[0].length);
          this.tokens.push({
            type: 'text',
            text: cap[0]
          });
          continue;
        }

        if (src) {
          throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
        }
      }

      return this.tokens;
    };

    /**
     * Inline-Level Grammar
     */

    var inline = {
      escape: /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,
      autolink: /^<(scheme:[^\s\x00-\x1f<>]*|email)>/,
      url: noop,
      tag: '^comment'
        + '|^</[a-zA-Z][\\w:-]*\\s*>' // self-closing tag
        + '|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>' // open tag
        + '|^<\\?[\\s\\S]*?\\?>' // processing instruction, e.g. <?php ?>
        + '|^<![a-zA-Z]+\\s[\\s\\S]*?>' // declaration, e.g. <!DOCTYPE html>
        + '|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>', // CDATA section
      link: /^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/,
      reflink: /^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,
      nolink: /^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,
      strong: /^__([^\s_])__(?!_)|^\*\*([^\s*])\*\*(?!\*)|^__([^\s][\s\S]*?[^\s])__(?!_)|^\*\*([^\s][\s\S]*?[^\s])\*\*(?!\*)/,
      em: /^_([^\s_])_(?!_)|^\*([^\s*<\[])\*(?!\*)|^_([^\s<][\s\S]*?[^\s_])_(?!_|[^\spunctuation])|^_([^\s_<][\s\S]*?[^\s])_(?!_|[^\spunctuation])|^\*([^\s<"][\s\S]*?[^\s\*])\*(?!\*|[^\spunctuation])|^\*([^\s*"<\[][\s\S]*?[^\s])\*(?!\*)/,
      code: /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,
      br: /^( {2,}|\\)\n(?!\s*$)/,
      del: noop,
      text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*]|\b_|$)|[^ ](?= {2,}\n))|(?= {2,}\n))/
    };

    // list of punctuation marks from common mark spec
    // without ` and ] to workaround Rule 17 (inline code blocks/links)
    inline._punctuation = '!"#$%&\'()*+,\\-./:;<=>?@\\[^_{|}~';
    inline.em = edit(inline.em).replace(/punctuation/g, inline._punctuation).getRegex();

    inline._escapes = /\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/g;

    inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;
    inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;
    inline.autolink = edit(inline.autolink)
      .replace('scheme', inline._scheme)
      .replace('email', inline._email)
      .getRegex();

    inline._attribute = /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/;

    inline.tag = edit(inline.tag)
      .replace('comment', block._comment)
      .replace('attribute', inline._attribute)
      .getRegex();

    inline._label = /(?:\[[^\[\]]*\]|\\.|`[^`]*`|[^\[\]\\`])*?/;
    inline._href = /<(?:\\[<>]?|[^\s<>\\])*>|[^\s\x00-\x1f]*/;
    inline._title = /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/;

    inline.link = edit(inline.link)
      .replace('label', inline._label)
      .replace('href', inline._href)
      .replace('title', inline._title)
      .getRegex();

    inline.reflink = edit(inline.reflink)
      .replace('label', inline._label)
      .getRegex();

    /**
     * Normal Inline Grammar
     */

    inline.normal = merge({}, inline);

    /**
     * Pedantic Inline Grammar
     */

    inline.pedantic = merge({}, inline.normal, {
      strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
      em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/,
      link: edit(/^!?\[(label)\]\((.*?)\)/)
        .replace('label', inline._label)
        .getRegex(),
      reflink: edit(/^!?\[(label)\]\s*\[([^\]]*)\]/)
        .replace('label', inline._label)
        .getRegex()
    });

    /**
     * GFM Inline Grammar
     */

    inline.gfm = merge({}, inline.normal, {
      escape: edit(inline.escape).replace('])', '~|])').getRegex(),
      _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
      url: /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
      _backpedal: /(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,
      del: /^~+(?=\S)([\s\S]*?\S)~+/,
      text: /^(`+|[^`])(?:[\s\S]*?(?:(?=[\\<!\[`*~]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))|(?= {2,}\n|[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@))/
    });

    inline.gfm.url = edit(inline.gfm.url, 'i')
      .replace('email', inline.gfm._extended_email)
      .getRegex();
    /**
     * GFM + Line Breaks Inline Grammar
     */

    inline.breaks = merge({}, inline.gfm, {
      br: edit(inline.br).replace('{2,}', '*').getRegex(),
      text: edit(inline.gfm.text)
        .replace('\\b_', '\\b_| {2,}\\n')
        .replace(/\{2,\}/g, '*')
        .getRegex()
    });

    /**
     * Inline Lexer & Compiler
     */

    function InlineLexer(links, options) {
      this.options = options || marked.defaults;
      this.links = links;
      this.rules = inline.normal;
      this.renderer = this.options.renderer || new Renderer();
      this.renderer.options = this.options;

      if (!this.links) {
        throw new Error('Tokens array requires a `links` property.');
      }

      if (this.options.pedantic) {
        this.rules = inline.pedantic;
      } else if (this.options.gfm) {
        if (this.options.breaks) {
          this.rules = inline.breaks;
        } else {
          this.rules = inline.gfm;
        }
      }
    }

    /**
     * Expose Inline Rules
     */

    InlineLexer.rules = inline;

    /**
     * Static Lexing/Compiling Method
     */

    InlineLexer.output = function(src, links, options) {
      var inline = new InlineLexer(links, options);
      return inline.output(src);
    };

    /**
     * Lexing/Compiling
     */

    InlineLexer.prototype.output = function(src) {
      var out = '',
          link,
          text,
          href,
          title,
          cap,
          prevCapZero;

      while (src) {
        // escape
        if (cap = this.rules.escape.exec(src)) {
          src = src.substring(cap[0].length);
          out += escape(cap[1]);
          continue;
        }

        // tag
        if (cap = this.rules.tag.exec(src)) {
          if (!this.inLink && /^<a /i.test(cap[0])) {
            this.inLink = true;
          } else if (this.inLink && /^<\/a>/i.test(cap[0])) {
            this.inLink = false;
          }
          if (!this.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.inRawBlock = true;
          } else if (this.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(cap[0])) {
            this.inRawBlock = false;
          }

          src = src.substring(cap[0].length);
          out += this.options.sanitize
            ? this.options.sanitizer
              ? this.options.sanitizer(cap[0])
              : escape(cap[0])
            : cap[0];
          continue;
        }

        // link
        if (cap = this.rules.link.exec(src)) {
          var lastParenIndex = findClosingBracket(cap[2], '()');
          if (lastParenIndex > -1) {
            var linkLen = 4 + cap[1].length + lastParenIndex;
            cap[2] = cap[2].substring(0, lastParenIndex);
            cap[0] = cap[0].substring(0, linkLen).trim();
            cap[3] = '';
          }
          src = src.substring(cap[0].length);
          this.inLink = true;
          href = cap[2];
          if (this.options.pedantic) {
            link = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(href);

            if (link) {
              href = link[1];
              title = link[3];
            } else {
              title = '';
            }
          } else {
            title = cap[3] ? cap[3].slice(1, -1) : '';
          }
          href = href.trim().replace(/^<([\s\S]*)>$/, '$1');
          out += this.outputLink(cap, {
            href: InlineLexer.escapes(href),
            title: InlineLexer.escapes(title)
          });
          this.inLink = false;
          continue;
        }

        // reflink, nolink
        if ((cap = this.rules.reflink.exec(src))
            || (cap = this.rules.nolink.exec(src))) {
          src = src.substring(cap[0].length);
          link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
          link = this.links[link.toLowerCase()];
          if (!link || !link.href) {
            out += cap[0].charAt(0);
            src = cap[0].substring(1) + src;
            continue;
          }
          this.inLink = true;
          out += this.outputLink(cap, link);
          this.inLink = false;
          continue;
        }

        // strong
        if (cap = this.rules.strong.exec(src)) {
          src = src.substring(cap[0].length);
          out += this.renderer.strong(this.output(cap[4] || cap[3] || cap[2] || cap[1]));
          continue;
        }

        // em
        if (cap = this.rules.em.exec(src)) {
          src = src.substring(cap[0].length);
          out += this.renderer.em(this.output(cap[6] || cap[5] || cap[4] || cap[3] || cap[2] || cap[1]));
          continue;
        }

        // code
        if (cap = this.rules.code.exec(src)) {
          src = src.substring(cap[0].length);
          out += this.renderer.codespan(escape(cap[2].trim(), true));
          continue;
        }

        // br
        if (cap = this.rules.br.exec(src)) {
          src = src.substring(cap[0].length);
          out += this.renderer.br();
          continue;
        }

        // del (gfm)
        if (cap = this.rules.del.exec(src)) {
          src = src.substring(cap[0].length);
          out += this.renderer.del(this.output(cap[1]));
          continue;
        }

        // autolink
        if (cap = this.rules.autolink.exec(src)) {
          src = src.substring(cap[0].length);
          if (cap[2] === '@') {
            text = escape(this.mangle(cap[1]));
            href = 'mailto:' + text;
          } else {
            text = escape(cap[1]);
            href = text;
          }
          out += this.renderer.link(href, null, text);
          continue;
        }

        // url (gfm)
        if (!this.inLink && (cap = this.rules.url.exec(src))) {
          if (cap[2] === '@') {
            text = escape(cap[0]);
            href = 'mailto:' + text;
          } else {
            // do extended autolink path validation
            do {
              prevCapZero = cap[0];
              cap[0] = this.rules._backpedal.exec(cap[0])[0];
            } while (prevCapZero !== cap[0]);
            text = escape(cap[0]);
            if (cap[1] === 'www.') {
              href = 'http://' + text;
            } else {
              href = text;
            }
          }
          src = src.substring(cap[0].length);
          out += this.renderer.link(href, null, text);
          continue;
        }

        // text
        if (cap = this.rules.text.exec(src)) {
          src = src.substring(cap[0].length);
          if (this.inRawBlock) {
            out += this.renderer.text(this.options.sanitize ? (this.options.sanitizer ? this.options.sanitizer(cap[0]) : escape(cap[0])) : cap[0]);
          } else {
            out += this.renderer.text(escape(this.smartypants(cap[0])));
          }
          continue;
        }

        if (src) {
          throw new Error('Infinite loop on byte: ' + src.charCodeAt(0));
        }
      }

      return out;
    };

    InlineLexer.escapes = function(text) {
      return text ? text.replace(InlineLexer.rules._escapes, '$1') : text;
    };

    /**
     * Compile Link
     */

    InlineLexer.prototype.outputLink = function(cap, link) {
      var href = link.href,
          title = link.title ? escape(link.title) : null;

      return cap[0].charAt(0) !== '!'
        ? this.renderer.link(href, title, this.output(cap[1]))
        : this.renderer.image(href, title, escape(cap[1]));
    };

    /**
     * Smartypants Transformations
     */

    InlineLexer.prototype.smartypants = function(text) {
      if (!this.options.smartypants) return text;
      return text
        // em-dashes
        .replace(/---/g, '\u2014')
        // en-dashes
        .replace(/--/g, '\u2013')
        // opening singles
        .replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
        // closing singles & apostrophes
        .replace(/'/g, '\u2019')
        // opening doubles
        .replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
        // closing doubles
        .replace(/"/g, '\u201d')
        // ellipses
        .replace(/\.{3}/g, '\u2026');
    };

    /**
     * Mangle Links
     */

    InlineLexer.prototype.mangle = function(text) {
      if (!this.options.mangle) return text;
      var out = '',
          l = text.length,
          i = 0,
          ch;

      for (; i < l; i++) {
        ch = text.charCodeAt(i);
        if (Math.random() > 0.5) {
          ch = 'x' + ch.toString(16);
        }
        out += '&#' + ch + ';';
      }

      return out;
    };

    /**
     * Renderer
     */

    function Renderer(options) {
      this.options = options || marked.defaults;
    }

    Renderer.prototype.code = function(code, infostring, escaped) {
      var lang = (infostring || '').match(/\S*/)[0];
      if (this.options.highlight) {
        var out = this.options.highlight(code, lang);
        if (out != null && out !== code) {
          escaped = true;
          code = out;
        }
      }

      if (!lang) {
        return '<pre><code>'
          + (escaped ? code : escape(code, true))
          + '</code></pre>';
      }

      return '<pre><code class="'
        + this.options.langPrefix
        + escape(lang, true)
        + '">'
        + (escaped ? code : escape(code, true))
        + '</code></pre>\n';
    };

    Renderer.prototype.blockquote = function(quote) {
      return '<blockquote>\n' + quote + '</blockquote>\n';
    };

    Renderer.prototype.html = function(html) {
      return html;
    };

    Renderer.prototype.heading = function(text, level, raw, slugger) {
      if (this.options.headerIds) {
        return '<h'
          + level
          + ' id="'
          + this.options.headerPrefix
          + slugger.slug(raw)
          + '">'
          + text
          + '</h'
          + level
          + '>\n';
      }
      // ignore IDs
      return '<h' + level + '>' + text + '</h' + level + '>\n';
    };

    Renderer.prototype.hr = function() {
      return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
    };

    Renderer.prototype.list = function(body, ordered, start) {
      var type = ordered ? 'ol' : 'ul',
          startatt = (ordered && start !== 1) ? (' start="' + start + '"') : '';
      return '<' + type + startatt + '>\n' + body + '</' + type + '>\n';
    };

    Renderer.prototype.listitem = function(text) {
      return '<li>' + text + '</li>\n';
    };

    Renderer.prototype.checkbox = function(checked) {
      return '<input '
        + (checked ? 'checked="" ' : '')
        + 'disabled="" type="checkbox"'
        + (this.options.xhtml ? ' /' : '')
        + '> ';
    };

    Renderer.prototype.paragraph = function(text) {
      return '<p>' + text + '</p>\n';
    };

    Renderer.prototype.table = function(header, body) {
      if (body) body = '<tbody>' + body + '</tbody>';

      return '<table>\n'
        + '<thead>\n'
        + header
        + '</thead>\n'
        + body
        + '</table>\n';
    };

    Renderer.prototype.tablerow = function(content) {
      return '<tr>\n' + content + '</tr>\n';
    };

    Renderer.prototype.tablecell = function(content, flags) {
      var type = flags.header ? 'th' : 'td';
      var tag = flags.align
        ? '<' + type + ' align="' + flags.align + '">'
        : '<' + type + '>';
      return tag + content + '</' + type + '>\n';
    };

    // span level renderer
    Renderer.prototype.strong = function(text) {
      return '<strong>' + text + '</strong>';
    };

    Renderer.prototype.em = function(text) {
      return '<em>' + text + '</em>';
    };

    Renderer.prototype.codespan = function(text) {
      return '<code>' + text + '</code>';
    };

    Renderer.prototype.br = function() {
      return this.options.xhtml ? '<br/>' : '<br>';
    };

    Renderer.prototype.del = function(text) {
      return '<del>' + text + '</del>';
    };

    Renderer.prototype.link = function(href, title, text) {
      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
      if (href === null) {
        return text;
      }
      var out = '<a href="' + escape(href) + '"';
      if (title) {
        out += ' title="' + title + '"';
      }
      out += '>' + text + '</a>';
      return out;
    };

    Renderer.prototype.image = function(href, title, text) {
      href = cleanUrl(this.options.sanitize, this.options.baseUrl, href);
      if (href === null) {
        return text;
      }

      var out = '<img src="' + href + '" alt="' + text + '"';
      if (title) {
        out += ' title="' + title + '"';
      }
      out += this.options.xhtml ? '/>' : '>';
      return out;
    };

    Renderer.prototype.text = function(text) {
      return text;
    };

    /**
     * TextRenderer
     * returns only the textual part of the token
     */

    function TextRenderer() {}

    // no need for block level renderers

    TextRenderer.prototype.strong =
    TextRenderer.prototype.em =
    TextRenderer.prototype.codespan =
    TextRenderer.prototype.del =
    TextRenderer.prototype.text = function(text) {
      return text;
    };

    TextRenderer.prototype.link =
    TextRenderer.prototype.image = function(href, title, text) {
      return '' + text;
    };

    TextRenderer.prototype.br = function() {
      return '';
    };

    /**
     * Parsing & Compiling
     */

    function Parser(options) {
      this.tokens = [];
      this.token = null;
      this.options = options || marked.defaults;
      this.options.renderer = this.options.renderer || new Renderer();
      this.renderer = this.options.renderer;
      this.renderer.options = this.options;
      this.slugger = new Slugger();
    }

    /**
     * Static Parse Method
     */

    Parser.parse = function(src, options) {
      var parser = new Parser(options);
      return parser.parse(src);
    };

    /**
     * Parse Loop
     */

    Parser.prototype.parse = function(src) {
      this.inline = new InlineLexer(src.links, this.options);
      // use an InlineLexer with a TextRenderer to extract pure text
      this.inlineText = new InlineLexer(
        src.links,
        merge({}, this.options, { renderer: new TextRenderer() })
      );
      this.tokens = src.reverse();

      var out = '';
      while (this.next()) {
        out += this.tok();
      }

      return out;
    };

    /**
     * Next Token
     */

    Parser.prototype.next = function() {
      this.token = this.tokens.pop();
      return this.token;
    };

    /**
     * Preview Next Token
     */

    Parser.prototype.peek = function() {
      return this.tokens[this.tokens.length - 1] || 0;
    };

    /**
     * Parse Text Tokens
     */

    Parser.prototype.parseText = function() {
      var body = this.token.text;

      while (this.peek().type === 'text') {
        body += '\n' + this.next().text;
      }

      return this.inline.output(body);
    };

    /**
     * Parse Current Token
     */

    Parser.prototype.tok = function() {
      switch (this.token.type) {
        case 'space': {
          return '';
        }
        case 'hr': {
          return this.renderer.hr();
        }
        case 'heading': {
          return this.renderer.heading(
            this.inline.output(this.token.text),
            this.token.depth,
            unescape(this.inlineText.output(this.token.text)),
            this.slugger);
        }
        case 'code': {
          return this.renderer.code(this.token.text,
            this.token.lang,
            this.token.escaped);
        }
        case 'table': {
          var header = '',
              body = '',
              i,
              row,
              cell,
              j;

          // header
          cell = '';
          for (i = 0; i < this.token.header.length; i++) {
            cell += this.renderer.tablecell(
              this.inline.output(this.token.header[i]),
              { header: true, align: this.token.align[i] }
            );
          }
          header += this.renderer.tablerow(cell);

          for (i = 0; i < this.token.cells.length; i++) {
            row = this.token.cells[i];

            cell = '';
            for (j = 0; j < row.length; j++) {
              cell += this.renderer.tablecell(
                this.inline.output(row[j]),
                { header: false, align: this.token.align[j] }
              );
            }

            body += this.renderer.tablerow(cell);
          }
          return this.renderer.table(header, body);
        }
        case 'blockquote_start': {
          body = '';

          while (this.next().type !== 'blockquote_end') {
            body += this.tok();
          }

          return this.renderer.blockquote(body);
        }
        case 'list_start': {
          body = '';
          var ordered = this.token.ordered,
              start = this.token.start;

          while (this.next().type !== 'list_end') {
            body += this.tok();
          }

          return this.renderer.list(body, ordered, start);
        }
        case 'list_item_start': {
          body = '';
          var loose = this.token.loose;
          var checked = this.token.checked;
          var task = this.token.task;

          if (this.token.task) {
            body += this.renderer.checkbox(checked);
          }

          while (this.next().type !== 'list_item_end') {
            body += !loose && this.token.type === 'text'
              ? this.parseText()
              : this.tok();
          }
          return this.renderer.listitem(body, task, checked);
        }
        case 'html': {
          // TODO parse inline content if parameter markdown=1
          return this.renderer.html(this.token.text);
        }
        case 'paragraph': {
          return this.renderer.paragraph(this.inline.output(this.token.text));
        }
        case 'text': {
          return this.renderer.paragraph(this.parseText());
        }
        default: {
          var errMsg = 'Token with "' + this.token.type + '" type was not found.';
          if (this.options.silent) {
            console.log(errMsg);
          } else {
            throw new Error(errMsg);
          }
        }
      }
    };

    /**
     * Slugger generates header id
     */

    function Slugger() {
      this.seen = {};
    }

    /**
     * Convert string to unique id
     */

    Slugger.prototype.slug = function(value) {
      var slug = value
        .toLowerCase()
        .trim()
        .replace(/[\u2000-\u206F\u2E00-\u2E7F\\'!"#$%&()*+,./:;<=>?@[\]^`{|}~]/g, '')
        .replace(/\s/g, '-');

      if (this.seen.hasOwnProperty(slug)) {
        var originalSlug = slug;
        do {
          this.seen[originalSlug]++;
          slug = originalSlug + '-' + this.seen[originalSlug];
        } while (this.seen.hasOwnProperty(slug));
      }
      this.seen[slug] = 0;

      return slug;
    };

    /**
     * Helpers
     */

    function escape(html, encode) {
      if (encode) {
        if (escape.escapeTest.test(html)) {
          return html.replace(escape.escapeReplace, function(ch) { return escape.replacements[ch]; });
        }
      } else {
        if (escape.escapeTestNoEncode.test(html)) {
          return html.replace(escape.escapeReplaceNoEncode, function(ch) { return escape.replacements[ch]; });
        }
      }

      return html;
    }

    escape.escapeTest = /[&<>"']/;
    escape.escapeReplace = /[&<>"']/g;
    escape.replacements = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    };

    escape.escapeTestNoEncode = /[<>"']|&(?!#?\w+;)/;
    escape.escapeReplaceNoEncode = /[<>"']|&(?!#?\w+;)/g;

    function unescape(html) {
      // explicitly match decimal, hex, and named HTML entities
      return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, function(_, n) {
        n = n.toLowerCase();
        if (n === 'colon') return ':';
        if (n.charAt(0) === '#') {
          return n.charAt(1) === 'x'
            ? String.fromCharCode(parseInt(n.substring(2), 16))
            : String.fromCharCode(+n.substring(1));
        }
        return '';
      });
    }

    function edit(regex, opt) {
      regex = regex.source || regex;
      opt = opt || '';
      return {
        replace: function(name, val) {
          val = val.source || val;
          val = val.replace(/(^|[^\[])\^/g, '$1');
          regex = regex.replace(name, val);
          return this;
        },
        getRegex: function() {
          return new RegExp(regex, opt);
        }
      };
    }

    function cleanUrl(sanitize, base, href) {
      if (sanitize) {
        try {
          var prot = decodeURIComponent(unescape(href))
            .replace(/[^\w:]/g, '')
            .toLowerCase();
        } catch (e) {
          return null;
        }
        if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
          return null;
        }
      }
      if (base && !originIndependentUrl.test(href)) {
        href = resolveUrl(base, href);
      }
      try {
        href = encodeURI(href).replace(/%25/g, '%');
      } catch (e) {
        return null;
      }
      return href;
    }

    function resolveUrl(base, href) {
      if (!baseUrls[' ' + base]) {
        // we can ignore everything in base after the last slash of its path component,
        // but we might need to add _that_
        // https://tools.ietf.org/html/rfc3986#section-3
        if (/^[^:]+:\/*[^/]*$/.test(base)) {
          baseUrls[' ' + base] = base + '/';
        } else {
          baseUrls[' ' + base] = rtrim(base, '/', true);
        }
      }
      base = baseUrls[' ' + base];

      if (href.slice(0, 2) === '//') {
        return base.replace(/:[\s\S]*/, ':') + href;
      } else if (href.charAt(0) === '/') {
        return base.replace(/(:\/*[^/]*)[\s\S]*/, '$1') + href;
      } else {
        return base + href;
      }
    }
    var baseUrls = {};
    var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;

    function noop() {}
    noop.exec = noop;

    function merge(obj) {
      var i = 1,
          target,
          key;

      for (; i < arguments.length; i++) {
        target = arguments[i];
        for (key in target) {
          if (Object.prototype.hasOwnProperty.call(target, key)) {
            obj[key] = target[key];
          }
        }
      }

      return obj;
    }

    function splitCells(tableRow, count) {
      // ensure that every cell-delimiting pipe has a space
      // before it to distinguish it from an escaped pipe
      var row = tableRow.replace(/\|/g, function(match, offset, str) {
            var escaped = false,
                curr = offset;
            while (--curr >= 0 && str[curr] === '\\') escaped = !escaped;
            if (escaped) {
              // odd number of slashes means | is escaped
              // so we leave it alone
              return '|';
            } else {
              // add space before unescaped |
              return ' |';
            }
          }),
          cells = row.split(/ \|/),
          i = 0;

      if (cells.length > count) {
        cells.splice(count);
      } else {
        while (cells.length < count) cells.push('');
      }

      for (; i < cells.length; i++) {
        // leading or trailing whitespace is ignored per the gfm spec
        cells[i] = cells[i].trim().replace(/\\\|/g, '|');
      }
      return cells;
    }

    // Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
    // /c*$/ is vulnerable to REDOS.
    // invert: Remove suffix of non-c chars instead. Default falsey.
    function rtrim(str, c, invert) {
      if (str.length === 0) {
        return '';
      }

      // Length of suffix matching the invert condition.
      var suffLen = 0;

      // Step left until we fail to match the invert condition.
      while (suffLen < str.length) {
        var currChar = str.charAt(str.length - suffLen - 1);
        if (currChar === c && !invert) {
          suffLen++;
        } else if (currChar !== c && invert) {
          suffLen++;
        } else {
          break;
        }
      }

      return str.substr(0, str.length - suffLen);
    }

    function findClosingBracket(str, b) {
      if (str.indexOf(b[1]) === -1) {
        return -1;
      }
      var level = 0;
      for (var i = 0; i < str.length; i++) {
        if (str[i] === '\\') {
          i++;
        } else if (str[i] === b[0]) {
          level++;
        } else if (str[i] === b[1]) {
          level--;
          if (level < 0) {
            return i;
          }
        }
      }
      return -1;
    }

    function checkSanitizeDeprecation(opt) {
      if (opt && opt.sanitize && !opt.silent) {
        console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');
      }
    }

    /**
     * Marked
     */

    function marked(src, opt, callback) {
      // throw error in case of non string input
      if (typeof src === 'undefined' || src === null) {
        throw new Error('marked(): input parameter is undefined or null');
      }
      if (typeof src !== 'string') {
        throw new Error('marked(): input parameter is of type '
          + Object.prototype.toString.call(src) + ', string expected');
      }

      if (callback || typeof opt === 'function') {
        if (!callback) {
          callback = opt;
          opt = null;
        }

        opt = merge({}, marked.defaults, opt || {});
        checkSanitizeDeprecation(opt);

        var highlight = opt.highlight,
            tokens,
            pending,
            i = 0;

        try {
          tokens = Lexer.lex(src, opt);
        } catch (e) {
          return callback(e);
        }

        pending = tokens.length;

        var done = function(err) {
          if (err) {
            opt.highlight = highlight;
            return callback(err);
          }

          var out;

          try {
            out = Parser.parse(tokens, opt);
          } catch (e) {
            err = e;
          }

          opt.highlight = highlight;

          return err
            ? callback(err)
            : callback(null, out);
        };

        if (!highlight || highlight.length < 3) {
          return done();
        }

        delete opt.highlight;

        if (!pending) return done();

        for (; i < tokens.length; i++) {
          (function(token) {
            if (token.type !== 'code') {
              return --pending || done();
            }
            return highlight(token.text, token.lang, function(err, code) {
              if (err) return done(err);
              if (code == null || code === token.text) {
                return --pending || done();
              }
              token.text = code;
              token.escaped = true;
              --pending || done();
            });
          })(tokens[i]);
        }

        return;
      }
      try {
        if (opt) opt = merge({}, marked.defaults, opt);
        checkSanitizeDeprecation(opt);
        return Parser.parse(Lexer.lex(src, opt), opt);
      } catch (e) {
        e.message += '\nPlease report this to https://github.com/markedjs/marked.';
        if ((opt || marked.defaults).silent) {
          return '<p>An error occurred:</p><pre>'
            + escape(e.message + '', true)
            + '</pre>';
        }
        throw e;
      }
    }

    /**
     * Options
     */

    marked.options =
    marked.setOptions = function(opt) {
      merge(marked.defaults, opt);
      return marked;
    };

    marked.getDefaults = function() {
      return {
        baseUrl: null,
        breaks: false,
        gfm: true,
        headerIds: true,
        headerPrefix: '',
        highlight: null,
        langPrefix: 'language-',
        mangle: true,
        pedantic: false,
        renderer: new Renderer(),
        sanitize: false,
        sanitizer: null,
        silent: false,
        smartLists: false,
        smartypants: false,
        xhtml: false
      };
    };

    marked.defaults = marked.getDefaults();

    /**
     * Expose
     */

    marked.Parser = Parser;
    marked.parser = Parser.parse;

    marked.Renderer = Renderer;
    marked.TextRenderer = TextRenderer;

    marked.Lexer = Lexer;
    marked.lexer = Lexer.lex;

    marked.InlineLexer = InlineLexer;
    marked.inlineLexer = InlineLexer.output;

    marked.Slugger = Slugger;

    marked.parse = marked;

    {
      module.exports = marked;
    }
    })();
    });

    /* admin/src/components/report/EditableTextarea.svelte generated by Svelte v3.9.2 */

    const file$R = "admin/src/components/report/EditableTextarea.svelte";

    // (74:2) {:else}
    function create_else_block_1$2(ctx) {
    	var button, i, t, dispose;

    	return {
    		c: function create() {
    			button = element("button");
    			i = element("i");
    			t = text("Edit");
    			attr(i, "class", "fas fa-edit");
    			add_location(i, file$R, 75, 4, 1634);
    			attr(button, "class", "button");
    			add_location(button, file$R, 74, 2, 1582);
    			dispose = listen(button, "click", ctx.toggleEdit);
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);
    			append(button, i);
    			append(button, t);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(button);
    			}

    			dispose();
    		}
    	};
    }

    // (70:2) {#if edit}
    function create_if_block_2$8(ctx) {
    	var button, i, t, dispose;

    	return {
    		c: function create() {
    			button = element("button");
    			i = element("i");
    			t = text("Preview");
    			attr(i, "class", "fas fa-eye");
    			add_location(i, file$R, 71, 4, 1524);
    			attr(button, "class", "button");
    			add_location(button, file$R, 70, 2, 1472);
    			dispose = listen(button, "click", ctx.toggleEdit);
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);
    			append(button, i);
    			append(button, t);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(button);
    			}

    			dispose();
    		}
    	};
    }

    // (78:8) {#if text !== original}
    function create_if_block_1$h(ctx) {
    	var button0, i0, t0, t1, button1, i1, t2, dispose;

    	return {
    		c: function create() {
    			button0 = element("button");
    			i0 = element("i");
    			t0 = text("Discard changes");
    			t1 = space();
    			button1 = element("button");
    			i1 = element("i");
    			t2 = text("Save changes");
    			attr(i0, "class", "fas fa-history");
    			add_location(i0, file$R, 79, 4, 1778);
    			attr(button0, "class", "button is-danger");
    			add_location(button0, file$R, 78, 2, 1712);
    			attr(i1, "class", "fas fa-save");
    			add_location(i1, file$R, 86, 4, 1939);
    			attr(button1, "class", "button is-primary");
    			toggle_class(button1, "is-loading", ctx.loading);
    			add_location(button1, file$R, 81, 2, 1838);

    			dispose = [
    				listen(button0, "click", ctx.discardChanges),
    				listen(button1, "click", ctx.save)
    			];
    		},

    		m: function mount(target, anchor) {
    			insert(target, button0, anchor);
    			append(button0, i0);
    			append(button0, t0);
    			insert(target, t1, anchor);
    			insert(target, button1, anchor);
    			append(button1, i1);
    			append(button1, t2);
    		},

    		p: function update(changed, ctx) {
    			if (changed.loading) {
    				toggle_class(button1, "is-loading", ctx.loading);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(button0);
    				detach(t1);
    				detach(button1);
    			}

    			run_all(dispose);
    		}
    	};
    }

    // (99:0) {:else}
    function create_else_block$f(ctx) {
    	var html_tag, raw_value = marked(ctx.text, { breaks: true }) + "";

    	return {
    		c: function create() {
    			html_tag = new HtmlTag(raw_value, null);
    		},

    		m: function mount(target, anchor) {
    			html_tag.m(target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.text) && raw_value !== (raw_value = marked(ctx.text, { breaks: true }) + "")) {
    				html_tag.p(raw_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				html_tag.d();
    			}
    		}
    	};
    }

    // (92:0) {#if edit}
    function create_if_block$w(ctx) {
    	var textarea, dispose;

    	return {
    		c: function create() {
    			textarea = element("textarea");
    			attr(textarea, "class", "textarea svelte-18mnnh3");
    			add_location(textarea, file$R, 92, 0, 2018);

    			dispose = [
    				listen(textarea, "input", ctx.textarea_input_handler),
    				listen(textarea, "input", ctx.inputHandler)
    			];
    		},

    		m: function mount(target, anchor) {
    			insert(target, textarea, anchor);

    			set_input_value(textarea, ctx.text);

    			ctx.textarea_binding(textarea);
    		},

    		p: function update(changed, ctx) {
    			if (changed.text) set_input_value(textarea, ctx.text);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(textarea);
    			}

    			ctx.textarea_binding(null);
    			run_all(dispose);
    		}
    	};
    }

    function create_fragment$Y(ctx) {
    	var div, t0, t1, if_block2_anchor;

    	function select_block_type(changed, ctx) {
    		if (ctx.edit) return create_if_block_2$8;
    		return create_else_block_1$2;
    	}

    	var current_block_type = select_block_type(null, ctx);
    	var if_block0 = current_block_type(ctx);

    	var if_block1 = (ctx.text !== ctx.original) && create_if_block_1$h(ctx);

    	function select_block_type_1(changed, ctx) {
    		if (ctx.edit) return create_if_block$w;
    		return create_else_block$f;
    	}

    	var current_block_type_1 = select_block_type_1(null, ctx);
    	var if_block2 = current_block_type_1(ctx);

    	return {
    		c: function create() {
    			div = element("div");
    			if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if_block2.c();
    			if_block2_anchor = empty();
    			attr(div, "class", "buttons");
    			add_location(div, file$R, 68, 0, 1435);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			if_block0.m(div, null);
    			append(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			insert(target, t1, anchor);
    			if_block2.m(target, anchor);
    			insert(target, if_block2_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type !== (current_block_type = select_block_type(changed, ctx))) {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);
    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(div, t0);
    				}
    			}

    			if (ctx.text !== ctx.original) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    				} else {
    					if_block1 = create_if_block_1$h(ctx);
    					if_block1.c();
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (current_block_type_1 === (current_block_type_1 = select_block_type_1(changed, ctx)) && if_block2) {
    				if_block2.p(changed, ctx);
    			} else {
    				if_block2.d(1);
    				if_block2 = current_block_type_1(ctx);
    				if (if_block2) {
    					if_block2.c();
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			if_block0.d();
    			if (if_block1) if_block1.d();

    			if (detaching) {
    				detach(t1);
    			}

    			if_block2.d(detaching);

    			if (detaching) {
    				detach(if_block2_anchor);
    			}
    		}
    	};
    }

    function instance$X($$self, $$props, $$invalidate) {
    	let $session;

    	validate_store(session, 'session');
    	component_subscribe($$self, session, $$value => { $session = $$value; $$invalidate('$session', $session); });

    	

      let { text = '', key = '' } = $$props;

      let original = text && text.slice(0);
      let input;
      let edit = true;
      let alreadySet = false;
      let loading = false;
      let errors = '';

      const inputHandler = event => {
        input.style.height = 'auto'; $$invalidate('input', input);
        input.style.height = input.scrollHeight + 'px'; $$invalidate('input', input);
      };

      const save = async () => {
        $$invalidate('loading', loading = true);
        const input = { report: { update: { [key]: text } } };
        try {
          await sessions.patch($session.id, input);
          notifications.add({ text: 'Successfuly saved changes', type: 'success' });
          errors = '';
          $$invalidate('original', original = text.slice(0));
        } catch (error) {
          errors = error;
          notifications.add({ text: "Couldn't save changes", type: 'danger' });
        } finally {
          $$invalidate('loading', loading = false);
        }
      };

      const toggleEdit = () => {
        $$invalidate('edit', edit = !edit);
        if (edit) $$invalidate('alreadySet', alreadySet = false);
      };

      const discardChanges = () => {
        $$invalidate('text', text = original.slice(0));
      };

    	const writable_props = ['text', 'key'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<EditableTextarea> was created with unknown prop '${key}'`);
    	});

    	function textarea_input_handler() {
    		text = this.value;
    		$$invalidate('text', text);
    	}

    	function textarea_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('input', input = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ('text' in $$props) $$invalidate('text', text = $$props.text);
    		if ('key' in $$props) $$invalidate('key', key = $$props.key);
    	};

    	$$self.$$.update = ($$dirty = { alreadySet: 1, input: 1 }) => {
    		if ($$dirty.alreadySet || $$dirty.input) { if (!alreadySet && input) {
            inputHandler();
            $$invalidate('alreadySet', alreadySet = true);
          } }
    	};

    	return {
    		text,
    		key,
    		original,
    		input,
    		edit,
    		loading,
    		inputHandler,
    		save,
    		toggleEdit,
    		discardChanges,
    		textarea_input_handler,
    		textarea_binding
    	};
    }

    class EditableTextarea extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$X, create_fragment$Y, safe_not_equal, ["text", "key"]);
    	}

    	get text() {
    		throw new Error("<EditableTextarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<EditableTextarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get key() {
    		throw new Error("<EditableTextarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set key(value) {
    		throw new Error("<EditableTextarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/report/RemoveWordButton.svelte generated by Svelte v3.9.2 */
    const { console: console_1$2 } = globals;

    const file$S = "admin/src/components/report/RemoveWordButton.svelte";

    function create_fragment$Z(ctx) {
    	var button, dispose;

    	return {
    		c: function create() {
    			button = element("button");
    			attr(button, "class", "delete");
    			add_location(button, file$S, 18, 0, 480);
    			dispose = listen(button, "click", ctx.remove);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);
    		},

    		p: noop,
    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(button);
    			}

    			dispose();
    		}
    	};
    }

    function instance$Y($$self, $$props, $$invalidate) {
    	

      let { wordId, classSessionId } = $$props;

      const remove = async () => {
        const input = { report: { update: { words: { disconnect: { id: wordId } } } } };
        try {
          await sessions.patch(classSessionId, input);
          notifications.add({ text: 'Removed word from report', type: 'success' });
        } catch (error) {
          console.error(error);
        }
      };

    	const writable_props = ['wordId', 'classSessionId'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console_1$2.warn(`<RemoveWordButton> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('wordId' in $$props) $$invalidate('wordId', wordId = $$props.wordId);
    		if ('classSessionId' in $$props) $$invalidate('classSessionId', classSessionId = $$props.classSessionId);
    	};

    	return { wordId, classSessionId, remove };
    }

    class RemoveWordButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Y, create_fragment$Z, safe_not_equal, ["wordId", "classSessionId"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.wordId === undefined && !('wordId' in props)) {
    			console_1$2.warn("<RemoveWordButton> was created without expected prop 'wordId'");
    		}
    		if (ctx.classSessionId === undefined && !('classSessionId' in props)) {
    			console_1$2.warn("<RemoveWordButton> was created without expected prop 'classSessionId'");
    		}
    	}

    	get wordId() {
    		throw new Error("<RemoveWordButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set wordId(value) {
    		throw new Error("<RemoveWordButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classSessionId() {
    		throw new Error("<RemoveWordButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classSessionId(value) {
    		throw new Error("<RemoveWordButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const WordFields = /* GraphQL */ `
  fragment WordFields on Word {
    id
    english
    chinese
    audio
    lessons {
      id
      name
    }
    tags {
      id
      name
    }
  }`;

    const WORDS = /* GraphQL */ `
 query Words ($orderBy: WordOrderByInput, $where: WordWhereInput){
   words (orderBy: $orderBy, where:$where){
     ...WordFields
   }
 }
 ${WordFields}`;

    const WORD = /* GraphQL */ `
query Word ($id: ID!){
  word (id: $id){
    ...WordFields
  }
}
${WordFields}`;

    const CREATE_WORD = /* GraphQL */ `
 mutation CreateWord ($input: WordCreateInput!){
   createWord (input: $input) {
     ...WordFields
   }
 }
 ${WordFields}`;

    const UPDATE_WORD = /* GraphQL */ `
mutation UpdateWord ($input: WordUpdateInput!, $id: ID!){
  updateWord (input: $input, id:$id) {
    ...WordFields
  }
}
${WordFields}`;

    const DELETE_WORD = /* GraphQL */ `
mutation DeleteWord ($id: ID!){
  deleteWord (id:$id) {
    id
  }
}`;

    const createWordsStore = () => {
      const { subscribe, set, update } = writable();

      return {
        subscribe,
        get: async (options = {}) => {
          const response = await request(WORDS, {
            orderBy: options.orderBy,
            where: options.where
          });
          set(response.words);
        },
        create: async (input) => {
          const response = await request(CREATE_WORD, { input });
          update(previous => !previous ? [response.createWord]
            : [...previous, response.createWord]);
        },
        remove: async id => {
          await request(DELETE_WORD, { id });
          update(previous => previous && previous.filter(w => w.id !== id));
          word.update(previous => (previous && previous.id === id) ? null : previous);
        },
        patch: async ({ input, id }) => {
          const response = await request(UPDATE_WORD, { id, input });
          update(previous => !previous ? [response.updateWord] : previous.map(w => {
            if (w.id !== id) return w
            return response.updateWord
          }));
          word.update(previous => {
            if (previous && previous.id === id) {
              return response.updateWord
            }
            return previous
          });
        }
      }
    };

    const words = createWordsStore();

    const createWordStore = () => {
      const { subscribe, set, update } = writable();

      return {
        subscribe,
        update,
        patch: words.patch,
        get: async (id) => {
          const response = await request(WORD, { id });
          if (response.word === null) push(`/not-found/word/${id}`);
          set(response.word);
        }
      }
    };

    const word = createWordStore();

    /* admin/src/components/report/AddWordRow.svelte generated by Svelte v3.9.2 */
    const { console: console_1$3 } = globals;

    const file$T = "admin/src/components/report/AddWordRow.svelte";

    function create_fragment$_(ctx) {
    	var li, label, i, i_class_value, t0, t1_value = ctx.word.english + "", t1, t2, t3_value = ctx.word.chinese + "", t3, t4, dispose;

    	return {
    		c: function create() {
    			li = element("li");
    			label = element("label");
    			i = element("i");
    			t0 = space();
    			t1 = text(t1_value);
    			t2 = text(" (");
    			t3 = text(t3_value);
    			t4 = text(")");
    			attr(i, "class", i_class_value = "fas fa-" + (ctx.isAdded ? 'check-' : '') + "square status" + " svelte-12hcy12");
    			add_location(i, file$T, 39, 4, 917);
    			attr(label, "class", "checkbox");
    			add_location(label, file$T, 38, 2, 888);
    			attr(li, "class", "svelte-12hcy12");
    			add_location(li, file$T, 37, 0, 863);
    			dispose = listen(li, "click", ctx.toggle);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, li, anchor);
    			append(li, label);
    			append(label, i);
    			append(label, t0);
    			append(label, t1);
    			append(label, t2);
    			append(label, t3);
    			append(label, t4);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.isAdded) && i_class_value !== (i_class_value = "fas fa-" + (ctx.isAdded ? 'check-' : '') + "square status" + " svelte-12hcy12")) {
    				attr(i, "class", i_class_value);
    			}

    			if ((changed.word) && t1_value !== (t1_value = ctx.word.english + "")) {
    				set_data(t1, t1_value);
    			}

    			if ((changed.word) && t3_value !== (t3_value = ctx.word.chinese + "")) {
    				set_data(t3, t3_value);
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(li);
    			}

    			dispose();
    		}
    	};
    }

    function instance$Z($$self, $$props, $$invalidate) {
    	let $session;

    	validate_store(session, 'session');
    	component_subscribe($$self, session, $$value => { $session = $$value; $$invalidate('$session', $session); });

    	

      let { word } = $$props;

      const toggle = async () => {
        const input = { report: { update: {} } };
        let text = 'Removed word session vocabulary';
        if (isAdded) {
          input.report.update.words = { disconnect: { id: word.id } };
        } else {
          text = 'Added word to session vocabulary';
          input.report.update.words = { connect: { id: word.id } };
        }
        try {
          await sessions.patch($session.id, input);
          notifications.add({ text, type: 'success' });
        } catch (error) {
          console.error(error);
        }
      };

    	const writable_props = ['word'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console_1$3.warn(`<AddWordRow> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('word' in $$props) $$invalidate('word', word = $$props.word);
    	};

    	let isAdded;

    	$$self.$$.update = ($$dirty = { $session: 1, word: 1 }) => {
    		if ($$dirty.$session || $$dirty.word) { $$invalidate('isAdded', isAdded = !!$session.report.words.find(w => w.id === word.id)); }
    	};

    	return { word, toggle, isAdded };
    }

    class AddWordRow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Z, create_fragment$_, safe_not_equal, ["word"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.word === undefined && !('word' in props)) {
    			console_1$3.warn("<AddWordRow> was created without expected prop 'word'");
    		}
    	}

    	get word() {
    		throw new Error("<AddWordRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set word(value) {
    		throw new Error("<AddWordRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/report/AddWordToReport.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$f } = globals;

    const file$U = "admin/src/components/report/AddWordToReport.svelte";

    function get_each_context$h(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.word = list[i];
    	return child_ctx;
    }

    // (42:4) {#if $words }
    function create_if_block$x(ctx) {
    	var p, t0_value = ctx.$words.length + "", t0, t1, t2, each_blocks = [], each_1_lookup = new Map(), each_1_anchor, current;

    	var each_value = ctx.$words;

    	const get_key = ctx => ctx.word.id;

    	for (var i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$h(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$h(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = text(" matches:");
    			t2 = space();

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();

    			each_1_anchor = empty();
    			add_location(p, file$U, 42, 8, 842);
    		},

    		m: function mount(target, anchor) {
    			insert(target, p, anchor);
    			append(p, t0);
    			append(p, t1);
    			insert(target, t2, anchor);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(target, anchor);

    			insert(target, each_1_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if ((!current || changed.$words) && t0_value !== (t0_value = ctx.$words.length + "")) {
    				set_data(t0, t0_value);
    			}

    			const each_value = ctx.$words;

    			group_outros();
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$h, each_1_anchor, get_each_context$h);
    			check_outros();
    		},

    		i: function intro(local) {
    			if (current) return;
    			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

    			current = true;
    		},

    		o: function outro(local) {
    			for (i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(p);
    				detach(t2);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d(detaching);

    			if (detaching) {
    				detach(each_1_anchor);
    			}
    		}
    	};
    }

    // (44:8) {#each $words as word (word.id)}
    function create_each_block$h(key_1, ctx) {
    	var first, current;

    	var addwordrow = new AddWordRow({
    		props: { word: ctx.word },
    		$$inline: true
    	});

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			first = empty();
    			addwordrow.$$.fragment.c();
    			this.first = first;
    		},

    		m: function mount(target, anchor) {
    			insert(target, first, anchor);
    			mount_component(addwordrow, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var addwordrow_changes = {};
    			if (changed.$words) addwordrow_changes.word = ctx.word;
    			addwordrow.$set(addwordrow_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(addwordrow.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(addwordrow.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(first);
    			}

    			destroy_component(addwordrow, detaching);
    		}
    	};
    }

    // (33:0) <Modal bind:open>
    function create_default_slot$c(ctx) {
    	var h2, t1, t2, t3, div0, t4, div1, button, current, dispose;

    	var filteritems = new FilterItems({
    		props: {
    		store: words,
    		searchParams: ['english', 'chinese' ]
    	},
    		$$inline: true
    	});

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	var if_block = (ctx.$words) && create_if_block$x(ctx);

    	return {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "Add word to session vocabulary";
    			t1 = space();
    			filteritems.$$.fragment.c();
    			t2 = space();
    			error.$$.fragment.c();
    			t3 = space();
    			div0 = element("div");
    			if (if_block) if_block.c();
    			t4 = space();
    			div1 = element("div");
    			button = element("button");
    			button.textContent = "Exit";
    			attr(h2, "class", "title is-4");
    			add_location(h2, file$U, 34, 2, 638);
    			attr(div0, "class", "results");
    			add_location(div0, file$U, 40, 2, 794);
    			attr(button, "class", "button");
    			add_location(button, file$U, 50, 8, 1031);
    			attr(div1, "class", "buttons svelte-1yabmim");
    			add_location(div1, file$U, 49, 6, 1001);
    			dispose = listen(button, "click", ctx.click_handler_1);
    		},

    		m: function mount(target, anchor) {
    			insert(target, h2, anchor);
    			insert(target, t1, anchor);
    			mount_component(filteritems, target, anchor);
    			insert(target, t2, anchor);
    			mount_component(error, target, anchor);
    			insert(target, t3, anchor);
    			insert(target, div0, anchor);
    			if (if_block) if_block.m(div0, null);
    			insert(target, t4, anchor);
    			insert(target, div1, anchor);
    			append(div1, button);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var filteritems_changes = {};
    			if (changed.words) filteritems_changes.store = words;
    			filteritems.$set(filteritems_changes);

    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);

    			if (ctx.$words) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$x(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div0, null);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(filteritems.$$.fragment, local);

    			transition_in(error.$$.fragment, local);

    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(filteritems.$$.fragment, local);
    			transition_out(error.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h2);
    				detach(t1);
    			}

    			destroy_component(filteritems, detaching);

    			if (detaching) {
    				detach(t2);
    			}

    			destroy_component(error, detaching);

    			if (detaching) {
    				detach(t3);
    				detach(div0);
    			}

    			if (if_block) if_block.d();

    			if (detaching) {
    				detach(t4);
    				detach(div1);
    			}

    			dispose();
    		}
    	};
    }

    function create_fragment$$(ctx) {
    	var button, i, t0, t1, updating_open, current, dispose;

    	function modal_open_binding(value) {
    		ctx.modal_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let modal_props = {
    		$$slots: { default: [create_default_slot$c] },
    		$$scope: { ctx }
    	};
    	if (ctx.open !== void 0) {
    		modal_props.open = ctx.open;
    	}
    	var modal = new Modal({ props: modal_props, $$inline: true });

    	binding_callbacks.push(() => bind(modal, 'open', modal_open_binding));

    	return {
    		c: function create() {
    			button = element("button");
    			i = element("i");
    			t0 = text("add words");
    			t1 = space();
    			modal.$$.fragment.c();
    			attr(i, "class", "fas fa-plus");
    			add_location(i, file$U, 30, 59, 570);
    			attr(button, "class", "button add svelte-1yabmim");
    			add_location(button, file$U, 30, 0, 511);
    			dispose = listen(button, "click", ctx.click_handler);
    		},

    		l: function claim(nodes) {
    			throw new Error_1$f("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);
    			append(button, i);
    			append(button, t0);
    			insert(target, t1, anchor);
    			mount_component(modal, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var modal_changes = {};
    			if (changed.$$scope || changed.$words || changed.errors) modal_changes.$$scope = { changed, ctx };
    			if (!updating_open && changed.open) {
    				modal_changes.open = ctx.open;
    			}
    			modal.$set(modal_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(button);
    				detach(t1);
    			}

    			destroy_component(modal, detaching);

    			dispose();
    		}
    	};
    }

    function instance$_($$self, $$props, $$invalidate) {
    	let $words;

    	validate_store(words, 'words');
    	component_subscribe($$self, words, $$value => { $words = $$value; $$invalidate('$words', $words); });

    	

      let open = false;
      let errors = '';

      onMount(async () => {
        try {
          await words.get();
        } catch (error) {
          $$invalidate('errors', errors = error);
        }
      });

    	function click_handler() { open = true; $$invalidate('open', open); }

    	function click_handler_1() { open = false; $$invalidate('open', open); }

    	function modal_open_binding(value) {
    		open = value;
    		$$invalidate('open', open);
    	}

    	return {
    		open,
    		errors,
    		$words,
    		click_handler,
    		click_handler_1,
    		modal_open_binding
    	};
    }

    class AddWordToReport extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$_, create_fragment$$, safe_not_equal, []);
    	}
    }

    /* admin/src/components/report/RemoveMaterialButton.svelte generated by Svelte v3.9.2 */
    const { console: console_1$4 } = globals;

    const file$V = "admin/src/components/report/RemoveMaterialButton.svelte";

    function create_fragment$10(ctx) {
    	var button, dispose;

    	return {
    		c: function create() {
    			button = element("button");
    			attr(button, "class", "delete");
    			add_location(button, file$V, 18, 0, 504);
    			dispose = listen(button, "click", ctx.remove);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);
    		},

    		p: noop,
    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(button);
    			}

    			dispose();
    		}
    	};
    }

    function instance$$($$self, $$props, $$invalidate) {
    	

      let { materialId, classSessionId } = $$props;

      const remove = async () => {
        const input = { report: { update: { materials: { disconnect: { id: materialId } } } } };
        try {
          await sessions.patch(classSessionId, input);
          notifications.add({ text: 'Removed material from session report', type: 'success' });
        } catch (error) {
          console.error(error);
        }
      };

    	const writable_props = ['materialId', 'classSessionId'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console_1$4.warn(`<RemoveMaterialButton> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('materialId' in $$props) $$invalidate('materialId', materialId = $$props.materialId);
    		if ('classSessionId' in $$props) $$invalidate('classSessionId', classSessionId = $$props.classSessionId);
    	};

    	return { materialId, classSessionId, remove };
    }

    class RemoveMaterialButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$$, create_fragment$10, safe_not_equal, ["materialId", "classSessionId"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.materialId === undefined && !('materialId' in props)) {
    			console_1$4.warn("<RemoveMaterialButton> was created without expected prop 'materialId'");
    		}
    		if (ctx.classSessionId === undefined && !('classSessionId' in props)) {
    			console_1$4.warn("<RemoveMaterialButton> was created without expected prop 'classSessionId'");
    		}
    	}

    	get materialId() {
    		throw new Error("<RemoveMaterialButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set materialId(value) {
    		throw new Error("<RemoveMaterialButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classSessionId() {
    		throw new Error("<RemoveMaterialButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classSessionId(value) {
    		throw new Error("<RemoveMaterialButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const MaterialFields = /* GraphQL */`
  fragment MaterialFields on Material {
    id
    type
    url
    title
    notes
    imageUrl
    tags {
       id
       name
    }
  }`;

    const MATERIALS = /* GraphQL */ `
  query Materials($orderBy: MaterialOrderByInput, $where: MaterialWhereInput) {
    materials (orderBy: $orderBy, where:$where) {
      ...MaterialFields
    }
  }
  ${MaterialFields}`;

    const MATERIAL = /* GraphQL */ `
  query Material($id: ID!){
    material(id: $id) {
      ...MaterialFields
    }
  }
  ${MaterialFields}`;

    const CREATE_MATERIAL = /* GraphQL */ `
 mutation CreateMaterial($input: MaterialCreateInput!) {
   createMaterial(input: $input) {
     ...MaterialFields
   }
 }
 ${MaterialFields}`;

    const UPDATE_MATERIAL = /* GraphQL */ `
mutation UpdateMaterial($input: MaterialUpdateInput!, $id:ID!) {
  updateMaterial(input: $input, id: $id) {
    ...MaterialFields
  }
}
${MaterialFields}`;

    const DELETE_MATERIAL = /* GraphQL */ `
mutation DeleteMaterial($id:ID!) {
  deleteMaterial(id: $id) {
    id
  }
}`;

    const createMaterialsStore = () => {
      const { subscribe, set, update } = writable();

      return {
        subscribe,
        update,
        get: async (options = {}) => {
          const { orderBy, where } = options;
          const response = await request(MATERIALS, { orderBy, where });
          set(response.materials);
        },
        create: async (input) => {
          const response = await request(CREATE_MATERIAL, { input });
          update(previous => !previous ? [response.createMaterial]
            : [...previous, response.createMaterial]);
        },
        remove: async id => {
          await request(DELETE_MATERIAL, { id });
          update(previous => previous && previous.filter(m => m.id !== id));
          material.update(previous => (previous && previous.id === id) ? null : previous);
        },
        patch: async ({ input, id }) => {
          const response = await request(UPDATE_MATERIAL, { id, input });
          update(previous => !previous ? [response.updateMaterial] : previous.map(m => {
            if (m.id !== id) return m
            return response.updateMaterial
          }));
          material.update(previous => {
            if (previous && previous.id === id) {
              return response.updateMaterial
            }
            return previous
          });
        }
      }
    };

    const materials = createMaterialsStore();

    const createMaterialStore = () => {
      const { subscribe, set, update } = writable();

      return {
        subscribe,
        update,
        patch: materials.patch,
        get: async (id) => {
          const response = await request(MATERIAL, { id });
          set(response.material);
        }
      }
    };

    const material = createMaterialStore();

    /* admin/src/components/report/AddMaterialRow.svelte generated by Svelte v3.9.2 */
    const { console: console_1$5 } = globals;

    const file$W = "admin/src/components/report/AddMaterialRow.svelte";

    function create_fragment$11(ctx) {
    	var li, label, i, i_class_value, t0, t1_value = ctx.material.title + "", t1, t2, t3_value = ctx.material.type + "", t3, dispose;

    	return {
    		c: function create() {
    			li = element("li");
    			label = element("label");
    			i = element("i");
    			t0 = space();
    			t1 = text(t1_value);
    			t2 = text(" - ");
    			t3 = text(t3_value);
    			attr(i, "class", i_class_value = "fas fa-" + (ctx.isAdded ? 'check-' : '') + "square status" + " svelte-12hcy12");
    			add_location(i, file$W, 40, 4, 935);
    			attr(label, "class", "checkbox");
    			add_location(label, file$W, 39, 2, 906);
    			attr(li, "class", "svelte-12hcy12");
    			add_location(li, file$W, 38, 0, 881);
    			dispose = listen(li, "click", ctx.toggle);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, li, anchor);
    			append(li, label);
    			append(label, i);
    			append(label, t0);
    			append(label, t1);
    			append(label, t2);
    			append(label, t3);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.isAdded) && i_class_value !== (i_class_value = "fas fa-" + (ctx.isAdded ? 'check-' : '') + "square status" + " svelte-12hcy12")) {
    				attr(i, "class", i_class_value);
    			}

    			if ((changed.material) && t1_value !== (t1_value = ctx.material.title + "")) {
    				set_data(t1, t1_value);
    			}

    			if ((changed.material) && t3_value !== (t3_value = ctx.material.type + "")) {
    				set_data(t3, t3_value);
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(li);
    			}

    			dispose();
    		}
    	};
    }

    function instance$10($$self, $$props, $$invalidate) {
    	let $session;

    	validate_store(session, 'session');
    	component_subscribe($$self, session, $$value => { $session = $$value; $$invalidate('$session', $session); });

    	

      let { material } = $$props;

      const toggle = async () => {
        const input = { report: { update: {} } };
        let text = 'Removed material from report';
        if (isAdded) {
          input.report.update.materials = { disconnect: { id: material.id } };
        } else {
          text = 'Added material to report';
          input.report.update.materials = { connect: { id: material.id } };
        }
        try {
          await sessions.patch($session.id, input);
          notifications.add({ text, type: 'success' });
        } catch (error) {
          console.error(error);
        }
      };

    	const writable_props = ['material'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console_1$5.warn(`<AddMaterialRow> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('material' in $$props) $$invalidate('material', material = $$props.material);
    	};

    	let isAdded;

    	$$self.$$.update = ($$dirty = { $session: 1, material: 1 }) => {
    		if ($$dirty.$session || $$dirty.material) { $$invalidate('isAdded', isAdded = !!$session.report.materials.find(m => m.id === material.id)); }
    	};

    	return { material, toggle, isAdded };
    }

    class AddMaterialRow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$10, create_fragment$11, safe_not_equal, ["material"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.material === undefined && !('material' in props)) {
    			console_1$5.warn("<AddMaterialRow> was created without expected prop 'material'");
    		}
    	}

    	get material() {
    		throw new Error("<AddMaterialRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set material(value) {
    		throw new Error("<AddMaterialRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/report/AddMaterialToReport.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$g } = globals;

    const file$X = "admin/src/components/report/AddMaterialToReport.svelte";

    function get_each_context$i(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.material = list[i];
    	return child_ctx;
    }

    // (41:4) {#if $materials }
    function create_if_block$y(ctx) {
    	var p, t0_value = ctx.$materials.length + "", t0, t1, t2, each_blocks = [], each_1_lookup = new Map(), each_1_anchor, current;

    	var each_value = ctx.$materials;

    	const get_key = ctx => ctx.material.id;

    	for (var i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$i(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$i(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = text(" matches:");
    			t2 = space();

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();

    			each_1_anchor = empty();
    			add_location(p, file$X, 41, 6, 853);
    		},

    		m: function mount(target, anchor) {
    			insert(target, p, anchor);
    			append(p, t0);
    			append(p, t1);
    			insert(target, t2, anchor);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(target, anchor);

    			insert(target, each_1_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if ((!current || changed.$materials) && t0_value !== (t0_value = ctx.$materials.length + "")) {
    				set_data(t0, t0_value);
    			}

    			const each_value = ctx.$materials;

    			group_outros();
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$i, each_1_anchor, get_each_context$i);
    			check_outros();
    		},

    		i: function intro(local) {
    			if (current) return;
    			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

    			current = true;
    		},

    		o: function outro(local) {
    			for (i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(p);
    				detach(t2);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d(detaching);

    			if (detaching) {
    				detach(each_1_anchor);
    			}
    		}
    	};
    }

    // (43:6) {#each $materials as material (material.id)}
    function create_each_block$i(key_1, ctx) {
    	var first, current;

    	var addmaterialrow = new AddMaterialRow({
    		props: { material: ctx.material },
    		$$inline: true
    	});

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			first = empty();
    			addmaterialrow.$$.fragment.c();
    			this.first = first;
    		},

    		m: function mount(target, anchor) {
    			insert(target, first, anchor);
    			mount_component(addmaterialrow, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var addmaterialrow_changes = {};
    			if (changed.$materials) addmaterialrow_changes.material = ctx.material;
    			addmaterialrow.$set(addmaterialrow_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(addmaterialrow.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(addmaterialrow.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(first);
    			}

    			destroy_component(addmaterialrow, detaching);
    		}
    	};
    }

    // (33:0) <Modal bind:open>
    function create_default_slot$d(ctx) {
    	var h2, t1, t2, t3, div0, t4, div1, button, current, dispose;

    	var filteritems = new FilterItems({
    		props: {
    		store: materials,
    		searchParams: "title"
    	},
    		$$inline: true
    	});

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	var if_block = (ctx.$materials) && create_if_block$y(ctx);

    	return {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "Add material to session report";
    			t1 = space();
    			filteritems.$$.fragment.c();
    			t2 = space();
    			error.$$.fragment.c();
    			t3 = space();
    			div0 = element("div");
    			if (if_block) if_block.c();
    			t4 = space();
    			div1 = element("div");
    			button = element("button");
    			button.textContent = "Exit";
    			attr(h2, "class", "title is-4");
    			add_location(h2, file$X, 34, 2, 662);
    			attr(div0, "class", "results");
    			add_location(div0, file$X, 39, 2, 803);
    			attr(button, "class", "button");
    			add_location(button, file$X, 49, 6, 1050);
    			attr(div1, "class", "buttons svelte-1yabmim");
    			add_location(div1, file$X, 48, 4, 1022);
    			dispose = listen(button, "click", ctx.click_handler_1);
    		},

    		m: function mount(target, anchor) {
    			insert(target, h2, anchor);
    			insert(target, t1, anchor);
    			mount_component(filteritems, target, anchor);
    			insert(target, t2, anchor);
    			mount_component(error, target, anchor);
    			insert(target, t3, anchor);
    			insert(target, div0, anchor);
    			if (if_block) if_block.m(div0, null);
    			insert(target, t4, anchor);
    			insert(target, div1, anchor);
    			append(div1, button);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var filteritems_changes = {};
    			if (changed.materials) filteritems_changes.store = materials;
    			filteritems.$set(filteritems_changes);

    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);

    			if (ctx.$materials) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$y(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div0, null);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(filteritems.$$.fragment, local);

    			transition_in(error.$$.fragment, local);

    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(filteritems.$$.fragment, local);
    			transition_out(error.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h2);
    				detach(t1);
    			}

    			destroy_component(filteritems, detaching);

    			if (detaching) {
    				detach(t2);
    			}

    			destroy_component(error, detaching);

    			if (detaching) {
    				detach(t3);
    				detach(div0);
    			}

    			if (if_block) if_block.d();

    			if (detaching) {
    				detach(t4);
    				detach(div1);
    			}

    			dispose();
    		}
    	};
    }

    function create_fragment$12(ctx) {
    	var button, i, t0, t1, updating_open, current, dispose;

    	function modal_open_binding(value) {
    		ctx.modal_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let modal_props = {
    		$$slots: { default: [create_default_slot$d] },
    		$$scope: { ctx }
    	};
    	if (ctx.open !== void 0) {
    		modal_props.open = ctx.open;
    	}
    	var modal = new Modal({ props: modal_props, $$inline: true });

    	binding_callbacks.push(() => bind(modal, 'open', modal_open_binding));

    	return {
    		c: function create() {
    			button = element("button");
    			i = element("i");
    			t0 = text("add material");
    			t1 = space();
    			modal.$$.fragment.c();
    			attr(i, "class", "fas fa-plus");
    			add_location(i, file$X, 30, 60, 591);
    			attr(button, "class", "button add svelte-1yabmim");
    			add_location(button, file$X, 30, 0, 531);
    			dispose = listen(button, "click", ctx.click_handler);
    		},

    		l: function claim(nodes) {
    			throw new Error_1$g("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);
    			append(button, i);
    			append(button, t0);
    			insert(target, t1, anchor);
    			mount_component(modal, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var modal_changes = {};
    			if (changed.$$scope || changed.$materials || changed.errors) modal_changes.$$scope = { changed, ctx };
    			if (!updating_open && changed.open) {
    				modal_changes.open = ctx.open;
    			}
    			modal.$set(modal_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(button);
    				detach(t1);
    			}

    			destroy_component(modal, detaching);

    			dispose();
    		}
    	};
    }

    function instance$11($$self, $$props, $$invalidate) {
    	let $materials;

    	validate_store(materials, 'materials');
    	component_subscribe($$self, materials, $$value => { $materials = $$value; $$invalidate('$materials', $materials); });

    	

      let open = false;
      let errors = '';

      onMount(async () => {
        try {
          await materials.get();
        } catch (error) {
          $$invalidate('errors', errors = error);
        }
      });

    	function click_handler() { open = true; $$invalidate('open', open); }

    	function click_handler_1() { open = false; $$invalidate('open', open); }

    	function modal_open_binding(value) {
    		open = value;
    		$$invalidate('open', open);
    	}

    	return {
    		open,
    		errors,
    		$materials,
    		click_handler,
    		click_handler_1,
    		modal_open_binding
    	};
    }

    class AddMaterialToReport extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$11, create_fragment$12, safe_not_equal, []);
    	}
    }

    /* admin/src/components/report/ReportDetails.svelte generated by Svelte v3.9.2 */

    const file$Y = "admin/src/components/report/ReportDetails.svelte";

    function get_each_context$j(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.material = list[i];
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.word = list[i];
    	return child_ctx;
    }

    // (52:2) {#if report.words && report.words.length > 0}
    function create_if_block_1$i(ctx) {
    	var ul, each_blocks = [], each_1_lookup = new Map(), current;

    	var each_value_1 = ctx.report.words;

    	const get_key = ctx => ctx.word.id;

    	for (var i = 0; i < each_value_1.length; i += 1) {
    		let child_ctx = get_each_context_1$2(ctx, each_value_1, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_1$2(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			ul = element("ul");

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();
    			attr(ul, "class", "words-list");
    			add_location(ul, file$Y, 52, 4, 1296);
    		},

    		m: function mount(target, anchor) {
    			insert(target, ul, anchor);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(ul, null);

    			current = true;
    		},

    		p: function update(changed, ctx) {
    			const each_value_1 = ctx.report.words;

    			group_outros();
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value_1, each_1_lookup, ul, outro_and_destroy_block, create_each_block_1$2, null, get_each_context_1$2);
    			check_outros();
    		},

    		i: function intro(local) {
    			if (current) return;
    			for (var i = 0; i < each_value_1.length; i += 1) transition_in(each_blocks[i]);

    			current = true;
    		},

    		o: function outro(local) {
    			for (i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(ul);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d();
    		}
    	};
    }

    // (57:10) {#if word.chinese}
    function create_if_block_2$9(ctx) {
    	var t0, t1_value = ctx.word.chinese + "", t1, t2;

    	return {
    		c: function create() {
    			t0 = text("(");
    			t1 = text(t1_value);
    			t2 = text(")");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t0, anchor);
    			insert(target, t1, anchor);
    			insert(target, t2, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.report) && t1_value !== (t1_value = ctx.word.chinese + "")) {
    				set_data(t1, t1_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t0);
    				detach(t1);
    				detach(t2);
    			}
    		}
    	};
    }

    // (54:6) {#each report.words as word (word.id)}
    function create_each_block_1$2(key_1, ctx) {
    	var li, a, t0_value = ctx.word.english + "", t0, t1, a_href_value, t2, t3, current;

    	var if_block = (ctx.word.chinese) && create_if_block_2$9(ctx);

    	var removewordbutton = new RemoveWordButton({
    		props: {
    		wordId: ctx.word.id,
    		classSessionId: ctx.classSessionId
    	},
    		$$inline: true
    	});

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			li = element("li");
    			a = element("a");
    			t0 = text(t0_value);
    			t1 = space();
    			if (if_block) if_block.c();
    			t2 = space();
    			removewordbutton.$$.fragment.c();
    			t3 = space();
    			attr(a, "href", a_href_value = "#/word/" + ctx.word.id);
    			add_location(a, file$Y, 55, 8, 1384);
    			add_location(li, file$Y, 54, 6, 1371);
    			this.first = li;
    		},

    		m: function mount(target, anchor) {
    			insert(target, li, anchor);
    			append(li, a);
    			append(a, t0);
    			append(a, t1);
    			if (if_block) if_block.m(a, null);
    			append(li, t2);
    			mount_component(removewordbutton, li, null);
    			append(li, t3);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if ((!current || changed.report) && t0_value !== (t0_value = ctx.word.english + "")) {
    				set_data(t0, t0_value);
    			}

    			if (ctx.word.chinese) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_2$9(ctx);
    					if_block.c();
    					if_block.m(a, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if ((!current || changed.report) && a_href_value !== (a_href_value = "#/word/" + ctx.word.id)) {
    				attr(a, "href", a_href_value);
    			}

    			var removewordbutton_changes = {};
    			if (changed.report) removewordbutton_changes.wordId = ctx.word.id;
    			if (changed.classSessionId) removewordbutton_changes.classSessionId = ctx.classSessionId;
    			removewordbutton.$set(removewordbutton_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(removewordbutton.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(removewordbutton.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(li);
    			}

    			if (if_block) if_block.d();

    			destroy_component(removewordbutton);
    		}
    	};
    }

    // (71:2) {#if report.materials && report.materials.length > 0}
    function create_if_block$z(ctx) {
    	var ul, each_blocks = [], each_1_lookup = new Map(), current;

    	var each_value = ctx.report.materials;

    	const get_key = ctx => ctx.material.id;

    	for (var i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$j(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$j(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			ul = element("ul");

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();
    			attr(ul, "class", "materials-list");
    			add_location(ul, file$Y, 71, 2, 1768);
    		},

    		m: function mount(target, anchor) {
    			insert(target, ul, anchor);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(ul, null);

    			current = true;
    		},

    		p: function update(changed, ctx) {
    			const each_value = ctx.report.materials;

    			group_outros();
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$j, null, get_each_context$j);
    			check_outros();
    		},

    		i: function intro(local) {
    			if (current) return;
    			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

    			current = true;
    		},

    		o: function outro(local) {
    			for (i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(ul);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d();
    		}
    	};
    }

    // (73:4) {#each report.materials as material (material.id)}
    function create_each_block$j(key_1, ctx) {
    	var li, a, t0_value = ctx.material.title + "", t0, a_href_value, t1, t2_value = ctx.material.type + "", t2, t3, t4, current;

    	var removematerialbutton = new RemoveMaterialButton({
    		props: {
    		materialId: ctx.material.id,
    		classSessionId: ctx.classSessionId
    	},
    		$$inline: true
    	});

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			li = element("li");
    			a = element("a");
    			t0 = text(t0_value);
    			t1 = text("\n         - ");
    			t2 = text(t2_value);
    			t3 = space();
    			removematerialbutton.$$.fragment.c();
    			t4 = space();
    			attr(a, "href", a_href_value = "#/material/" + ctx.material.id);
    			add_location(a, file$Y, 74, 8, 1870);
    			add_location(li, file$Y, 73, 6, 1857);
    			this.first = li;
    		},

    		m: function mount(target, anchor) {
    			insert(target, li, anchor);
    			append(li, a);
    			append(a, t0);
    			append(li, t1);
    			append(li, t2);
    			append(li, t3);
    			mount_component(removematerialbutton, li, null);
    			append(li, t4);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if ((!current || changed.report) && t0_value !== (t0_value = ctx.material.title + "")) {
    				set_data(t0, t0_value);
    			}

    			if ((!current || changed.report) && a_href_value !== (a_href_value = "#/material/" + ctx.material.id)) {
    				attr(a, "href", a_href_value);
    			}

    			if ((!current || changed.report) && t2_value !== (t2_value = ctx.material.type + "")) {
    				set_data(t2, t2_value);
    			}

    			var removematerialbutton_changes = {};
    			if (changed.report) removematerialbutton_changes.materialId = ctx.material.id;
    			if (changed.classSessionId) removematerialbutton_changes.classSessionId = ctx.classSessionId;
    			removematerialbutton.$set(removematerialbutton_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(removematerialbutton.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(removematerialbutton.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(li);
    			}

    			destroy_component(removematerialbutton);
    		}
    	};
    }

    function create_fragment$13(ctx) {
    	var section0, h30, t1, t2, section1, h31, t4, t5, section2, h32, t7, t8, section3, h33, t10, t11, section4, h34, t13, t14, section5, h35, t16, t17, t18, section6, h36, t20, t21, current;

    	var editabletextarea0 = new EditableTextarea({
    		props: { text: ctx.report.summaryEN, key: "summaryEN" },
    		$$inline: true
    	});

    	var editabletextarea1 = new EditableTextarea({
    		props: { text: ctx.report.homeworkEN, key: "homeworkEN" },
    		$$inline: true
    	});

    	var editabletextarea2 = new EditableTextarea({
    		props: { text: ctx.report.summaryZH, key: "summaryZH" },
    		$$inline: true
    	});

    	var editabletextarea3 = new EditableTextarea({
    		props: { text: ctx.report.homeworkZH, key: "homeworkZH" },
    		$$inline: true
    	});

    	var editabletextarea4 = new EditableTextarea({
    		props: { text: ctx.report.performance, key: "performance" },
    		$$inline: true
    	});

    	var if_block0 = (ctx.report.words && ctx.report.words.length > 0) && create_if_block_1$i(ctx);

    	var addwordtoreport = new AddWordToReport({ $$inline: true });

    	var if_block1 = (ctx.report.materials && ctx.report.materials.length > 0) && create_if_block$z(ctx);

    	var addmaterialtoreport = new AddMaterialToReport({ $$inline: true });

    	return {
    		c: function create() {
    			section0 = element("section");
    			h30 = element("h3");
    			h30.textContent = "Summary (English)";
    			t1 = space();
    			editabletextarea0.$$.fragment.c();
    			t2 = space();
    			section1 = element("section");
    			h31 = element("h3");
    			h31.textContent = "Homework (English)";
    			t4 = space();
    			editabletextarea1.$$.fragment.c();
    			t5 = space();
    			section2 = element("section");
    			h32 = element("h3");
    			h32.textContent = "Summary (Chinese)";
    			t7 = space();
    			editabletextarea2.$$.fragment.c();
    			t8 = space();
    			section3 = element("section");
    			h33 = element("h3");
    			h33.textContent = "Homework (Chinese)";
    			t10 = space();
    			editabletextarea3.$$.fragment.c();
    			t11 = space();
    			section4 = element("section");
    			h34 = element("h3");
    			h34.textContent = "Performance";
    			t13 = space();
    			editabletextarea4.$$.fragment.c();
    			t14 = space();
    			section5 = element("section");
    			h35 = element("h3");
    			h35.textContent = "Vocabulary";
    			t16 = space();
    			if (if_block0) if_block0.c();
    			t17 = space();
    			addwordtoreport.$$.fragment.c();
    			t18 = space();
    			section6 = element("section");
    			h36 = element("h3");
    			h36.textContent = "Materials";
    			t20 = space();
    			if (if_block1) if_block1.c();
    			t21 = space();
    			addmaterialtoreport.$$.fragment.c();
    			attr(h30, "class", "title is-5 svelte-l1zkq1");
    			add_location(h30, file$Y, 25, 2, 536);
    			attr(section0, "class", "svelte-l1zkq1");
    			add_location(section0, file$Y, 24, 0, 524);
    			attr(h31, "class", "title is-5 svelte-l1zkq1");
    			add_location(h31, file$Y, 30, 2, 669);
    			attr(section1, "class", "svelte-l1zkq1");
    			add_location(section1, file$Y, 29, 0, 657);
    			attr(h32, "class", "title is-5 svelte-l1zkq1");
    			add_location(h32, file$Y, 35, 2, 805);
    			attr(section2, "class", "svelte-l1zkq1");
    			add_location(section2, file$Y, 34, 0, 793);
    			attr(h33, "class", "title is-5 svelte-l1zkq1");
    			add_location(h33, file$Y, 40, 2, 938);
    			attr(section3, "class", "svelte-l1zkq1");
    			add_location(section3, file$Y, 39, 0, 926);
    			attr(h34, "class", "title is-5 svelte-l1zkq1");
    			add_location(h34, file$Y, 45, 2, 1074);
    			attr(section4, "class", "svelte-l1zkq1");
    			add_location(section4, file$Y, 44, 0, 1062);
    			attr(h35, "class", "title is-5 svelte-l1zkq1");
    			add_location(h35, file$Y, 50, 2, 1205);
    			attr(section5, "class", "svelte-l1zkq1");
    			add_location(section5, file$Y, 49, 0, 1193);
    			attr(h36, "class", "title is-5 svelte-l1zkq1");
    			add_location(h36, file$Y, 69, 2, 1672);
    			attr(section6, "class", "svelte-l1zkq1");
    			add_location(section6, file$Y, 68, 0, 1660);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, section0, anchor);
    			append(section0, h30);
    			append(section0, t1);
    			mount_component(editabletextarea0, section0, null);
    			insert(target, t2, anchor);
    			insert(target, section1, anchor);
    			append(section1, h31);
    			append(section1, t4);
    			mount_component(editabletextarea1, section1, null);
    			insert(target, t5, anchor);
    			insert(target, section2, anchor);
    			append(section2, h32);
    			append(section2, t7);
    			mount_component(editabletextarea2, section2, null);
    			insert(target, t8, anchor);
    			insert(target, section3, anchor);
    			append(section3, h33);
    			append(section3, t10);
    			mount_component(editabletextarea3, section3, null);
    			insert(target, t11, anchor);
    			insert(target, section4, anchor);
    			append(section4, h34);
    			append(section4, t13);
    			mount_component(editabletextarea4, section4, null);
    			insert(target, t14, anchor);
    			insert(target, section5, anchor);
    			append(section5, h35);
    			append(section5, t16);
    			if (if_block0) if_block0.m(section5, null);
    			append(section5, t17);
    			mount_component(addwordtoreport, section5, null);
    			insert(target, t18, anchor);
    			insert(target, section6, anchor);
    			append(section6, h36);
    			append(section6, t20);
    			if (if_block1) if_block1.m(section6, null);
    			append(section6, t21);
    			mount_component(addmaterialtoreport, section6, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var editabletextarea0_changes = {};
    			if (changed.report) editabletextarea0_changes.text = ctx.report.summaryEN;
    			editabletextarea0.$set(editabletextarea0_changes);

    			var editabletextarea1_changes = {};
    			if (changed.report) editabletextarea1_changes.text = ctx.report.homeworkEN;
    			editabletextarea1.$set(editabletextarea1_changes);

    			var editabletextarea2_changes = {};
    			if (changed.report) editabletextarea2_changes.text = ctx.report.summaryZH;
    			editabletextarea2.$set(editabletextarea2_changes);

    			var editabletextarea3_changes = {};
    			if (changed.report) editabletextarea3_changes.text = ctx.report.homeworkZH;
    			editabletextarea3.$set(editabletextarea3_changes);

    			var editabletextarea4_changes = {};
    			if (changed.report) editabletextarea4_changes.text = ctx.report.performance;
    			editabletextarea4.$set(editabletextarea4_changes);

    			if (ctx.report.words && ctx.report.words.length > 0) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    					transition_in(if_block0, 1);
    				} else {
    					if_block0 = create_if_block_1$i(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(section5, t17);
    				}
    			} else if (if_block0) {
    				group_outros();
    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});
    				check_outros();
    			}

    			if (ctx.report.materials && ctx.report.materials.length > 0) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    					transition_in(if_block1, 1);
    				} else {
    					if_block1 = create_if_block$z(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(section6, t21);
    				}
    			} else if (if_block1) {
    				group_outros();
    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(editabletextarea0.$$.fragment, local);

    			transition_in(editabletextarea1.$$.fragment, local);

    			transition_in(editabletextarea2.$$.fragment, local);

    			transition_in(editabletextarea3.$$.fragment, local);

    			transition_in(editabletextarea4.$$.fragment, local);

    			transition_in(if_block0);

    			transition_in(addwordtoreport.$$.fragment, local);

    			transition_in(if_block1);

    			transition_in(addmaterialtoreport.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(editabletextarea0.$$.fragment, local);
    			transition_out(editabletextarea1.$$.fragment, local);
    			transition_out(editabletextarea2.$$.fragment, local);
    			transition_out(editabletextarea3.$$.fragment, local);
    			transition_out(editabletextarea4.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(addwordtoreport.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(addmaterialtoreport.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(section0);
    			}

    			destroy_component(editabletextarea0);

    			if (detaching) {
    				detach(t2);
    				detach(section1);
    			}

    			destroy_component(editabletextarea1);

    			if (detaching) {
    				detach(t5);
    				detach(section2);
    			}

    			destroy_component(editabletextarea2);

    			if (detaching) {
    				detach(t8);
    				detach(section3);
    			}

    			destroy_component(editabletextarea3);

    			if (detaching) {
    				detach(t11);
    				detach(section4);
    			}

    			destroy_component(editabletextarea4);

    			if (detaching) {
    				detach(t14);
    				detach(section5);
    			}

    			if (if_block0) if_block0.d();

    			destroy_component(addwordtoreport);

    			if (detaching) {
    				detach(t18);
    				detach(section6);
    			}

    			if (if_block1) if_block1.d();

    			destroy_component(addmaterialtoreport);
    		}
    	};
    }

    function instance$12($$self, $$props, $$invalidate) {
    	

      let { report, classSessionId } = $$props;

    	const writable_props = ['report', 'classSessionId'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<ReportDetails> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('report' in $$props) $$invalidate('report', report = $$props.report);
    		if ('classSessionId' in $$props) $$invalidate('classSessionId', classSessionId = $$props.classSessionId);
    	};

    	return { report, classSessionId };
    }

    class ReportDetails extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$12, create_fragment$13, safe_not_equal, ["report", "classSessionId"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.report === undefined && !('report' in props)) {
    			console.warn("<ReportDetails> was created without expected prop 'report'");
    		}
    		if (ctx.classSessionId === undefined && !('classSessionId' in props)) {
    			console.warn("<ReportDetails> was created without expected prop 'classSessionId'");
    		}
    	}

    	get report() {
    		throw new Error("<ReportDetails>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set report(value) {
    		throw new Error("<ReportDetails>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get classSessionId() {
    		throw new Error("<ReportDetails>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classSessionId(value) {
    		throw new Error("<ReportDetails>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/report/PublishReportButton.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$h } = globals;

    const file$Z = "admin/src/components/report/PublishReportButton.svelte";

    // (36:39) 
    function create_if_block_1$j(ctx) {
    	var button, i, t, dispose;

    	return {
    		c: function create() {
    			button = element("button");
    			i = element("i");
    			t = text("\n    Publish report");
    			attr(i, "class", "fas fa-paper-plane");
    			add_location(i, file$Z, 38, 4, 1207);
    			attr(button, "class", "button is-primary");
    			toggle_class(button, "is-loading", ctx.loading);
    			add_location(button, file$Z, 36, 2, 1099);
    			dispose = listen(button, "click", ctx.click_handler_1);
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);
    			append(button, i);
    			append(button, t);
    		},

    		p: function update(changed, ctx) {
    			if (changed.loading) {
    				toggle_class(button, "is-loading", ctx.loading);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(button);
    			}

    			dispose();
    		}
    	};
    }

    // (30:0) {#if $session && $session.report.published}
    function create_if_block$A(ctx) {
    	var button, i, t, dispose;

    	return {
    		c: function create() {
    			button = element("button");
    			i = element("i");
    			t = text("\n    Unpublish report");
    			attr(i, "class", "fas fa-eye-slash");
    			add_location(i, file$Z, 32, 4, 991);
    			attr(button, "class", "button is-primary");
    			toggle_class(button, "is-loading", ctx.loading);
    			add_location(button, file$Z, 30, 2, 882);
    			dispose = listen(button, "click", ctx.click_handler);
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);
    			append(button, i);
    			append(button, t);
    		},

    		p: function update(changed, ctx) {
    			if (changed.loading) {
    				toggle_class(button, "is-loading", ctx.loading);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(button);
    			}

    			dispose();
    		}
    	};
    }

    function create_fragment$14(ctx) {
    	var t, if_block_anchor, current;

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	function select_block_type(changed, ctx) {
    		if (ctx.$session && ctx.$session.report.published) return create_if_block$A;
    		if (!ctx.$session.report.published) return create_if_block_1$j;
    	}

    	var current_block_type = select_block_type(null, ctx);
    	var if_block = current_block_type && current_block_type(ctx);

    	return {
    		c: function create() {
    			error.$$.fragment.c();
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},

    		l: function claim(nodes) {
    			throw new Error_1$h("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			mount_component(error, target, anchor);
    			insert(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);

    			if (current_block_type === (current_block_type = select_block_type(changed, ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(ctx);
    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(error, detaching);

    			if (detaching) {
    				detach(t);
    			}

    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function instance$13($$self, $$props, $$invalidate) {
    	let $session;

    	validate_store(session, 'session');
    	component_subscribe($$self, session, $$value => { $session = $$value; $$invalidate('$session', $session); });

    	

      let errors = '';
      let loading = false;
      let { classSessionId } = $$props;

      const togglePublish = async (value) => {
        $$invalidate('loading', loading = true);
        const verb = value ? 'publish' : 'unpublish';
        const input = { report: { update: { published: value } } };
        try {
          await sessions.patch(classSessionId, input);
          notifications.add({ text: `${verb.charAt(0).toUpperCase() + verb.slice(1)}ed session report`, type: 'success' });
          $$invalidate('errors', errors = '');
        } catch (error) {
          $$invalidate('errors', errors = error);
          notifications.add({ text: `Couldn't ${verb} session report`, type: 'danger' });
        } finally {
          $$invalidate('loading', loading = false);
        }
      };

    	const writable_props = ['classSessionId'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<PublishReportButton> was created with unknown prop '${key}'`);
    	});

    	function click_handler() {
    		return togglePublish(false);
    	}

    	function click_handler_1() {
    		return togglePublish(true);
    	}

    	$$self.$set = $$props => {
    		if ('classSessionId' in $$props) $$invalidate('classSessionId', classSessionId = $$props.classSessionId);
    	};

    	return {
    		errors,
    		loading,
    		classSessionId,
    		togglePublish,
    		$session,
    		click_handler,
    		click_handler_1
    	};
    }

    class PublishReportButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$13, create_fragment$14, safe_not_equal, ["classSessionId"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.classSessionId === undefined && !('classSessionId' in props)) {
    			console.warn("<PublishReportButton> was created without expected prop 'classSessionId'");
    		}
    	}

    	get classSessionId() {
    		throw new Error_1$h("<PublishReportButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set classSessionId(value) {
    		throw new Error_1$h("<PublishReportButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/report/Report.svelte generated by Svelte v3.9.2 */

    const file$_ = "admin/src/components/report/Report.svelte";

    // (21:4) {:else}
    function create_else_block$g(ctx) {
    	var t, current;

    	var publishreportbutton = new PublishReportButton({
    		props: { classSessionId: ctx.$session.id },
    		$$inline: true
    	});

    	var reportdetails = new ReportDetails({
    		props: {
    		report: ctx.$session.report,
    		classSessionId: ctx.$session.id
    	},
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			publishreportbutton.$$.fragment.c();
    			t = space();
    			reportdetails.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(publishreportbutton, target, anchor);
    			insert(target, t, anchor);
    			mount_component(reportdetails, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var publishreportbutton_changes = {};
    			if (changed.$session) publishreportbutton_changes.classSessionId = ctx.$session.id;
    			publishreportbutton.$set(publishreportbutton_changes);

    			var reportdetails_changes = {};
    			if (changed.$session) reportdetails_changes.report = ctx.$session.report;
    			if (changed.$session) reportdetails_changes.classSessionId = ctx.$session.id;
    			reportdetails.$set(reportdetails_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(publishreportbutton.$$.fragment, local);

    			transition_in(reportdetails.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(publishreportbutton.$$.fragment, local);
    			transition_out(reportdetails.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(publishreportbutton, detaching);

    			if (detaching) {
    				detach(t);
    			}

    			destroy_component(reportdetails, detaching);
    		}
    	};
    }

    // (18:43) 
    function create_if_block_1$k(ctx) {
    	var p, t_1, current;

    	var createreport = new CreateReport({
    		props: { classSessionId: ctx.$session.id },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			p = element("p");
    			p.textContent = "No report exists for this session.";
    			t_1 = space();
    			createreport.$$.fragment.c();
    			add_location(p, file$_, 18, 6, 492);
    		},

    		m: function mount(target, anchor) {
    			insert(target, p, anchor);
    			insert(target, t_1, anchor);
    			mount_component(createreport, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var createreport_changes = {};
    			if (changed.$session) createreport_changes.classSessionId = ctx.$session.id;
    			createreport.$set(createreport_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(createreport.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(createreport.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(p);
    				detach(t_1);
    			}

    			destroy_component(createreport, detaching);
    		}
    	};
    }

    // (16:2) {#if !$session.lesson}
    function create_if_block$B(ctx) {
    	var p;

    	return {
    		c: function create() {
    			p = element("p");
    			p.textContent = "A lesson must be added before a report can be created.";
    			add_location(p, file$_, 16, 6, 380);
    		},

    		m: function mount(target, anchor) {
    			insert(target, p, anchor);
    		},

    		p: noop,
    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(p);
    			}
    		}
    	};
    }

    function create_fragment$15(ctx) {
    	var section, h3, t_1, current_block_type_index, if_block, current;

    	var if_block_creators = [
    		create_if_block$B,
    		create_if_block_1$k,
    		create_else_block$g
    	];

    	var if_blocks = [];

    	function select_block_type(changed, ctx) {
    		if (!ctx.$session.lesson) return 0;
    		if (ctx.$session && !ctx.$session.report) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(null, ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	return {
    		c: function create() {
    			section = element("section");
    			h3 = element("h3");
    			h3.textContent = "Report";
    			t_1 = space();
    			if_block.c();
    			attr(h3, "class", "title is-4");
    			add_location(h3, file$_, 14, 2, 314);
    			attr(section, "class", "report svelte-xj6mxc");
    			add_location(section, file$_, 13, 0, 287);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, section, anchor);
    			append(section, h3);
    			append(section, t_1);
    			if_blocks[current_block_type_index].m(section, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(changed, ctx);
    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(changed, ctx);
    			} else {
    				group_outros();
    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});
    				check_outros();

    				if_block = if_blocks[current_block_type_index];
    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}
    				transition_in(if_block, 1);
    				if_block.m(section, null);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(section);
    			}

    			if_blocks[current_block_type_index].d();
    		}
    	};
    }

    function instance$14($$self, $$props, $$invalidate) {
    	let $session;

    	validate_store(session, 'session');
    	component_subscribe($$self, session, $$value => { $session = $$value; $$invalidate('$session', $session); });

    	return { $session };
    }

    class Report extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$14, create_fragment$15, safe_not_equal, []);
    	}
    }

    /* admin/src/components/session/EndedSession.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$i } = globals;

    const file$$ = "admin/src/components/session/EndedSession.svelte";

    function get_each_context$k(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.result = list[i];
    	return child_ctx;
    }

    // (39:0) <DL>
    function create_default_slot$e(ctx) {
    	var dt0, t1, dd0, t2_value = ctx.formatTime(ctx.$session.startsAt) + "", t2, t3, dt1, t5, dd1, t6_value = ctx.formatTime(ctx.$session.startedAt) + "", t6, t7, dt2, t9, dd2, t10_value = ctx.formatTime(ctx.$session.endsAt) + "", t10, t11, dt3, t13, dd3, t14_value = ctx.formatTime(ctx.$session.endedAt) + "", t14;

    	return {
    		c: function create() {
    			dt0 = element("dt");
    			dt0.textContent = "Schedule start:";
    			t1 = space();
    			dd0 = element("dd");
    			t2 = text(t2_value);
    			t3 = space();
    			dt1 = element("dt");
    			dt1.textContent = "Actual start:";
    			t5 = space();
    			dd1 = element("dd");
    			t6 = text(t6_value);
    			t7 = space();
    			dt2 = element("dt");
    			dt2.textContent = "Schedule end:";
    			t9 = space();
    			dd2 = element("dd");
    			t10 = text(t10_value);
    			t11 = space();
    			dt3 = element("dt");
    			dt3.textContent = "Actual end:";
    			t13 = space();
    			dd3 = element("dd");
    			t14 = text(t14_value);
    			add_location(dt0, file$$, 39, 2, 975);
    			add_location(dd0, file$$, 40, 2, 1002);
    			add_location(dt1, file$$, 42, 2, 1046);
    			add_location(dd1, file$$, 43, 2, 1071);
    			add_location(dt2, file$$, 45, 2, 1116);
    			add_location(dd2, file$$, 46, 2, 1141);
    			add_location(dt3, file$$, 48, 2, 1183);
    			add_location(dd3, file$$, 49, 2, 1206);
    		},

    		m: function mount(target, anchor) {
    			insert(target, dt0, anchor);
    			insert(target, t1, anchor);
    			insert(target, dd0, anchor);
    			append(dd0, t2);
    			insert(target, t3, anchor);
    			insert(target, dt1, anchor);
    			insert(target, t5, anchor);
    			insert(target, dd1, anchor);
    			append(dd1, t6);
    			insert(target, t7, anchor);
    			insert(target, dt2, anchor);
    			insert(target, t9, anchor);
    			insert(target, dd2, anchor);
    			append(dd2, t10);
    			insert(target, t11, anchor);
    			insert(target, dt3, anchor);
    			insert(target, t13, anchor);
    			insert(target, dd3, anchor);
    			append(dd3, t14);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.$session) && t2_value !== (t2_value = ctx.formatTime(ctx.$session.startsAt) + "")) {
    				set_data(t2, t2_value);
    			}

    			if ((changed.$session) && t6_value !== (t6_value = ctx.formatTime(ctx.$session.startedAt) + "")) {
    				set_data(t6, t6_value);
    			}

    			if ((changed.$session) && t10_value !== (t10_value = ctx.formatTime(ctx.$session.endsAt) + "")) {
    				set_data(t10, t10_value);
    			}

    			if ((changed.$session) && t14_value !== (t14_value = ctx.formatTime(ctx.$session.endedAt) + "")) {
    				set_data(t14, t14_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(dt0);
    				detach(t1);
    				detach(dd0);
    				detach(t3);
    				detach(dt1);
    				detach(t5);
    				detach(dd1);
    				detach(t7);
    				detach(dt2);
    				detach(t9);
    				detach(dd2);
    				detach(t11);
    				detach(dt3);
    				detach(t13);
    				detach(dd3);
    			}
    		}
    	};
    }

    // (66:0) {:catch errors}
    function create_catch_block$2(ctx) {
    	var current;

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			error.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(error, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var error_changes = {};
    			if (changed.getResults || changed.id) error_changes.errors = ctx.errors;
    			error.$set(error_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(error, detaching);
    		}
    	};
    }

    // (57:0) {:then results}
    function create_then_block$2(ctx) {
    	var section, h3, t_1, ul, each_blocks = [], each_1_lookup = new Map(), current;

    	var each_value = ctx.results;

    	const get_key = ctx => ctx.result.id;

    	for (var i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$k(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$k(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			section = element("section");
    			h3 = element("h3");
    			h3.textContent = "Results";
    			t_1 = space();
    			ul = element("ul");

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();
    			attr(h3, "class", "title is-4");
    			add_location(h3, file$$, 58, 4, 1368);
    			add_location(ul, file$$, 59, 4, 1408);
    			attr(section, "class", "results svelte-xj6mxc");
    			add_location(section, file$$, 57, 2, 1338);
    		},

    		m: function mount(target, anchor) {
    			insert(target, section, anchor);
    			append(section, h3);
    			append(section, t_1);
    			append(section, ul);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(ul, null);

    			current = true;
    		},

    		p: function update(changed, ctx) {
    			const each_value = ctx.results;

    			group_outros();
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$k, null, get_each_context$k);
    			check_outros();
    		},

    		i: function intro(local) {
    			if (current) return;
    			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

    			current = true;
    		},

    		o: function outro(local) {
    			for (i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(section);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d();
    		}
    	};
    }

    // (61:6) {#each results as result (result.id)}
    function create_each_block$k(key_1, ctx) {
    	var first, current;

    	var resultsrow = new ResultsRow({
    		props: { result: ctx.result },
    		$$inline: true
    	});

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			first = empty();
    			resultsrow.$$.fragment.c();
    			this.first = first;
    		},

    		m: function mount(target, anchor) {
    			insert(target, first, anchor);
    			mount_component(resultsrow, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var resultsrow_changes = {};
    			if (changed.getResults || changed.id) resultsrow_changes.result = ctx.result;
    			resultsrow.$set(resultsrow_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(resultsrow.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(resultsrow.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(first);
    			}

    			destroy_component(resultsrow, detaching);
    		}
    	};
    }

    // (55:23)    <Loading what="results"/> {:then results}
    function create_pending_block$2(ctx) {
    	var current;

    	var loading = new Loading({
    		props: { what: "results" },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			loading.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},

    		p: noop,

    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};
    }

    // (75:4) {:else}
    function create_else_block$h(ctx) {
    	var p, t_value = ctx.$session.lesson.name + "", t;

    	return {
    		c: function create() {
    			p = element("p");
    			t = text(t_value);
    			add_location(p, file$$, 75, 4, 1763);
    		},

    		m: function mount(target, anchor) {
    			insert(target, p, anchor);
    			append(p, t);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.$session) && t_value !== (t_value = ctx.$session.lesson.name + "")) {
    				set_data(t, t_value);
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(p);
    			}
    		}
    	};
    }

    // (72:2) {#if !$session.lesson}
    function create_if_block$C(ctx) {
    	var p, t_1, current;

    	var addlessontosession = new AddLessonToSession({
    		props: { id: ctx.$session.id },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			p = element("p");
    			p.textContent = "No lesson has been selected yet.";
    			t_1 = space();
    			addlessontosession.$$.fragment.c();
    			add_location(p, file$$, 72, 4, 1663);
    		},

    		m: function mount(target, anchor) {
    			insert(target, p, anchor);
    			insert(target, t_1, anchor);
    			mount_component(addlessontosession, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var addlessontosession_changes = {};
    			if (changed.$session) addlessontosession_changes.id = ctx.$session.id;
    			addlessontosession.$set(addlessontosession_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(addlessontosession.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(addlessontosession.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(p);
    				detach(t_1);
    			}

    			destroy_component(addlessontosession, detaching);
    		}
    	};
    }

    function create_fragment$16(ctx) {
    	var t0, p, t1, t2, t3, t4, t5, promise, t6, setion, h3, t8, current_block_type_index, if_block, t9, current;

    	var dl = new DL({
    		props: {
    		$$slots: { default: [create_default_slot$e] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});

    	var edittimes = new EditTimes({ $$inline: true });

    	let info = {
    		ctx,
    		current: null,
    		token: null,
    		pending: create_pending_block$2,
    		then: create_then_block$2,
    		catch: create_catch_block$2,
    		value: 'results',
    		error: 'errors',
    		blocks: [,,,]
    	};

    	handle_promise(promise = getResults(ctx.id), info);

    	var if_block_creators = [
    		create_if_block$C,
    		create_else_block$h
    	];

    	var if_blocks = [];

    	function select_block_type(changed, ctx) {
    		if (!ctx.$session.lesson) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(null, ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	var report = new Report({ $$inline: true });

    	return {
    		c: function create() {
    			t0 = space();
    			p = element("p");
    			t1 = text("Ended ");
    			t2 = text(ctx.endedDistance);
    			t3 = space();
    			dl.$$.fragment.c();
    			t4 = space();
    			edittimes.$$.fragment.c();
    			t5 = space();

    			info.block.c();

    			t6 = space();
    			setion = element("setion");
    			h3 = element("h3");
    			h3.textContent = "Lesson";
    			t8 = space();
    			if_block.c();
    			t9 = space();
    			report.$$.fragment.c();
    			document.title = "Ended Session";
    			attr(p, "class", "subtitle");
    			add_location(p, file$$, 36, 0, 921);
    			attr(h3, "class", "title is-4");
    			add_location(h3, file$$, 70, 2, 1599);
    			attr(setion, "class", "lesson");
    			add_location(setion, file$$, 69, 0, 1573);
    		},

    		l: function claim(nodes) {
    			throw new Error_1$i("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t0, anchor);
    			insert(target, p, anchor);
    			append(p, t1);
    			append(p, t2);
    			insert(target, t3, anchor);
    			mount_component(dl, target, anchor);
    			insert(target, t4, anchor);
    			mount_component(edittimes, target, anchor);
    			insert(target, t5, anchor);

    			info.block.m(target, info.anchor = anchor);
    			info.mount = () => t6.parentNode;
    			info.anchor = t6;

    			insert(target, t6, anchor);
    			insert(target, setion, anchor);
    			append(setion, h3);
    			append(setion, t8);
    			if_blocks[current_block_type_index].m(setion, null);
    			insert(target, t9, anchor);
    			mount_component(report, target, anchor);
    			current = true;
    		},

    		p: function update(changed, new_ctx) {
    			ctx = new_ctx;
    			if (!current || changed.endedDistance) {
    				set_data(t2, ctx.endedDistance);
    			}

    			var dl_changes = {};
    			if (changed.$$scope || changed.$session) dl_changes.$$scope = { changed, ctx };
    			dl.$set(dl_changes);

    			info.ctx = ctx;

    			if (('id' in changed) && promise !== (promise = getResults(ctx.id)) && handle_promise(promise, info)) ; else {
    				info.block.p(changed, assign(assign({}, ctx), info.resolved));
    			}

    			var previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(changed, ctx);
    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(changed, ctx);
    			} else {
    				group_outros();
    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});
    				check_outros();

    				if_block = if_blocks[current_block_type_index];
    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}
    				transition_in(if_block, 1);
    				if_block.m(setion, null);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(dl.$$.fragment, local);

    			transition_in(edittimes.$$.fragment, local);

    			transition_in(info.block);
    			transition_in(if_block);

    			transition_in(report.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(dl.$$.fragment, local);
    			transition_out(edittimes.$$.fragment, local);

    			for (let i = 0; i < 3; i += 1) {
    				const block = info.blocks[i];
    				transition_out(block);
    			}

    			transition_out(if_block);
    			transition_out(report.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t0);
    				detach(p);
    				detach(t3);
    			}

    			destroy_component(dl, detaching);

    			if (detaching) {
    				detach(t4);
    			}

    			destroy_component(edittimes, detaching);

    			if (detaching) {
    				detach(t5);
    			}

    			info.block.d(detaching);
    			info.token = null;
    			info = null;

    			if (detaching) {
    				detach(t6);
    				detach(setion);
    			}

    			if_blocks[current_block_type_index].d();

    			if (detaching) {
    				detach(t9);
    			}

    			destroy_component(report, detaching);
    		}
    	};
    }

    function instance$15($$self, $$props, $$invalidate) {
    	let $session, $time;

    	validate_store(session, 'session');
    	component_subscribe($$self, session, $$value => { $session = $$value; $$invalidate('$session', $session); });
    	validate_store(time, 'time');
    	component_subscribe($$self, time, $$value => { $time = $$value; $$invalidate('$time', $time); });

    	

      let { id } = $$props;

      const formatTime = (time) => {
        if (!time) return
        const dateTime = new Date(time);
        if (dateTime.getMinutes() === 0) {
          return format(dateTime, 'h b')
        }
        return format(dateTime, 'p')
      };

    	const writable_props = ['id'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<EndedSession> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('id' in $$props) $$invalidate('id', id = $$props.id);
    	};

    	let endedDistance;

    	$$self.$$.update = ($$dirty = { $session: 1, $time: 1 }) => {
    		if ($$dirty.$session || $$dirty.$time) { $$invalidate('endedDistance', endedDistance = formatDistance$1(new Date($session.endedAt), new Date($time), { addSuffix: true })); }
    	};

    	return { id, formatTime, endedDistance, $session };
    }

    class EndedSession extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$15, create_fragment$16, safe_not_equal, ["id"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.id === undefined && !('id' in props)) {
    			console.warn("<EndedSession> was created without expected prop 'id'");
    		}
    	}

    	get id() {
    		throw new Error_1$i("<EndedSession>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error_1$i("<EndedSession>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/session/Session.svelte generated by Svelte v3.9.2 */

    const file$10 = "admin/src/components/session/Session.svelte";

    // (34:0) {:else}
    function create_else_block$i(ctx) {
    	var current;

    	var loading = new Loading({
    		props: { what: "class session" },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			loading.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},

    		p: noop,

    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};
    }

    // (32:53) 
    function create_if_block_5$1(ctx) {
    	var current;

    	var notfound = new NotFound({ $$inline: true });

    	return {
    		c: function create() {
    			notfound.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(notfound, target, anchor);
    			current = true;
    		},

    		p: noop,

    		i: function intro(local) {
    			if (current) return;
    			transition_in(notfound.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(notfound.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(notfound, detaching);
    		}
    	};
    }

    // (20:0) {#if $session}
    function create_if_block$D(ctx) {
    	var h2, t0_value = ctx.$session.group.name + "", t0, t1, t2_value = ctx.$session.number + "", t2, t3, current_block_type_index, if_block, if_block_anchor, current;

    	var if_block_creators = [
    		create_if_block_1$l,
    		create_if_block_2$a,
    		create_if_block_3$4,
    		create_if_block_4$1
    	];

    	var if_blocks = [];

    	function select_block_type_1(changed, ctx) {
    		if (ctx.$session.stage === 'Inactive') return 0;
    		if (ctx.$session.stage === 'Active') return 1;
    		if (ctx.$session.stage === 'Started') return 2;
    		if (ctx.$session.stage === 'Ended') return 3;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type_1(null, ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	return {
    		c: function create() {
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = text(" class lesson ");
    			t2 = text(t2_value);
    			t3 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr(h2, "class", "title");
    			add_location(h2, file$10, 20, 2, 528);
    		},

    		m: function mount(target, anchor) {
    			insert(target, h2, anchor);
    			append(h2, t0);
    			append(h2, t1);
    			append(h2, t2);
    			insert(target, t3, anchor);
    			if (~current_block_type_index) if_blocks[current_block_type_index].m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if ((!current || changed.$session) && t0_value !== (t0_value = ctx.$session.group.name + "")) {
    				set_data(t0, t0_value);
    			}

    			if ((!current || changed.$session) && t2_value !== (t2_value = ctx.$session.number + "")) {
    				set_data(t2, t2_value);
    			}

    			var previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(changed, ctx);
    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) if_blocks[current_block_type_index].p(changed, ctx);
    			} else {
    				if (if_block) {
    					group_outros();
    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});
    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];
    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					}
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h2);
    				detach(t3);
    			}

    			if (~current_block_type_index) if_blocks[current_block_type_index].d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    // (28:39) 
    function create_if_block_4$1(ctx) {
    	var current;

    	var endedsession = new EndedSession({
    		props: { id: ctx.params.id },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			endedsession.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(endedsession, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var endedsession_changes = {};
    			if (changed.params) endedsession_changes.id = ctx.params.id;
    			endedsession.$set(endedsession_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(endedsession.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(endedsession.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(endedsession, detaching);
    		}
    	};
    }

    // (26:41) 
    function create_if_block_3$4(ctx) {
    	var current;

    	var startedsession = new StartedSession({ $$inline: true });

    	return {
    		c: function create() {
    			startedsession.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(startedsession, target, anchor);
    			current = true;
    		},

    		p: noop,

    		i: function intro(local) {
    			if (current) return;
    			transition_in(startedsession.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(startedsession.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(startedsession, detaching);
    		}
    	};
    }

    // (24:40) 
    function create_if_block_2$a(ctx) {
    	var current;

    	var activesession = new ActiveSession({ $$inline: true });

    	return {
    		c: function create() {
    			activesession.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(activesession, target, anchor);
    			current = true;
    		},

    		p: noop,

    		i: function intro(local) {
    			if (current) return;
    			transition_in(activesession.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(activesession.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(activesession, detaching);
    		}
    	};
    }

    // (22:2) {#if $session.stage === 'Inactive'}
    function create_if_block_1$l(ctx) {
    	var current;

    	var sessionactivator = new SessionActivator({
    		props: { id: ctx.params.id },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			sessionactivator.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(sessionactivator, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var sessionactivator_changes = {};
    			if (changed.params) sessionactivator_changes.id = ctx.params.id;
    			sessionactivator.$set(sessionactivator_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(sessionactivator.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(sessionactivator.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(sessionactivator, detaching);
    		}
    	};
    }

    function create_fragment$17(ctx) {
    	var current_block_type_index, if_block, if_block_anchor, current;

    	var if_block_creators = [
    		create_if_block$D,
    		create_if_block_5$1,
    		create_else_block$i
    	];

    	var if_blocks = [];

    	function select_block_type(changed, ctx) {
    		if (ctx.$session) return 0;
    		if (ctx.$session && ctx.$session.classSession === null) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(null, ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	return {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(changed, ctx);
    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(changed, ctx);
    			} else {
    				group_outros();
    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});
    				check_outros();

    				if_block = if_blocks[current_block_type_index];
    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}
    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function instance$16($$self, $$props, $$invalidate) {
    	let $session;

    	validate_store(session, 'session');
    	component_subscribe($$self, session, $$value => { $session = $$value; $$invalidate('$session', $session); });

    	

      let { params = {} } = $$props;

      sessionId.set(params.id);

      onDestroy(() => {
        sessionId.set(null);
      });

    	const writable_props = ['params'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Session> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('params' in $$props) $$invalidate('params', params = $$props.params);
    	};

    	return { params, $session };
    }

    class Session extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$16, create_fragment$17, safe_not_equal, ["params"]);
    	}

    	get params() {
    		throw new Error("<Session>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<Session>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/lessons/LessonList.svelte generated by Svelte v3.9.2 */

    const file$11 = "admin/src/components/lessons/LessonList.svelte";

    function get_each_context_1$3(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.tag = list[i];
    	return child_ctx;
    }

    function get_each_context$l(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.lesson = list[i];
    	return child_ctx;
    }

    // (22:2) {#if $lessons}
    function create_if_block$E(ctx) {
    	var p, t0_value = ctx.$lessons.length + "", t0, t1, t2, if_block_anchor;

    	var if_block = (ctx.$lessons.length > 0) && create_if_block_1$m(ctx);

    	return {
    		c: function create() {
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = text(" matching lessons found:");
    			t2 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			add_location(p, file$11, 22, 4, 274);
    		},

    		m: function mount(target, anchor) {
    			insert(target, p, anchor);
    			append(p, t0);
    			append(p, t1);
    			insert(target, t2, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.$lessons) && t0_value !== (t0_value = ctx.$lessons.length + "")) {
    				set_data(t0, t0_value);
    			}

    			if (ctx.$lessons.length > 0) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_1$m(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(p);
    				detach(t2);
    			}

    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    // (24:4) {#if $lessons.length > 0}
    function create_if_block_1$m(ctx) {
    	var each_blocks = [], each_1_lookup = new Map(), each_1_anchor;

    	var each_value = ctx.$lessons;

    	const get_key = ctx => ctx.lesson.id;

    	for (var i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$l(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$l(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();

    			each_1_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(target, anchor);

    			insert(target, each_1_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			const each_value = ctx.$lessons;
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$l, each_1_anchor, get_each_context$l);
    		},

    		d: function destroy(detaching) {
    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d(detaching);

    			if (detaching) {
    				detach(each_1_anchor);
    			}
    		}
    	};
    }

    // (27:8) {#if lesson.tags.length > 0}
    function create_if_block_2$b(ctx) {
    	var div, each_blocks = [], each_1_lookup = new Map();

    	var each_value_1 = ctx.lesson.tags;

    	const get_key = ctx => ctx.tag.id;

    	for (var i = 0; i < each_value_1.length; i += 1) {
    		let child_ctx = get_each_context_1$3(ctx, each_value_1, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_1$3(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			div = element("div");

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();
    			attr(div, "class", "tags svelte-4s8ccd");
    			add_location(div, file$11, 27, 8, 504);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(div, null);
    		},

    		p: function update(changed, ctx) {
    			const each_value_1 = ctx.lesson.tags;
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value_1, each_1_lookup, div, destroy_block, create_each_block_1$3, null, get_each_context_1$3);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d();
    		}
    	};
    }

    // (29:12) {#each lesson.tags as tag (tag.id)}
    function create_each_block_1$3(key_1, ctx) {
    	var span, t_value = ctx.tag.name + "", t;

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr(span, "class", "tag is-dark");
    			add_location(span, file$11, 29, 12, 583);
    			this.first = span;
    		},

    		m: function mount(target, anchor) {
    			insert(target, span, anchor);
    			append(span, t);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.$lessons) && t_value !== (t_value = ctx.tag.name + "")) {
    				set_data(t, t_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(span);
    			}
    		}
    	};
    }

    // (25:6) {#each $lessons as lesson (lesson.id)}
    function create_each_block$l(key_1, ctx) {
    	var li, a, t0_value = ctx.lesson.name + "", t0, a_href_value, t1, t2;

    	var if_block = (ctx.lesson.tags.length > 0) && create_if_block_2$b(ctx);

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			li = element("li");
    			a = element("a");
    			t0 = text(t0_value);
    			t1 = space();
    			if (if_block) if_block.c();
    			t2 = space();
    			attr(a, "href", a_href_value = "#/lesson/" + ctx.lesson.id);
    			add_location(a, file$11, 25, 12, 410);
    			attr(li, "class", "svelte-4s8ccd");
    			add_location(li, file$11, 25, 8, 406);
    			this.first = li;
    		},

    		m: function mount(target, anchor) {
    			insert(target, li, anchor);
    			append(li, a);
    			append(a, t0);
    			append(li, t1);
    			if (if_block) if_block.m(li, null);
    			append(li, t2);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.$lessons) && t0_value !== (t0_value = ctx.lesson.name + "")) {
    				set_data(t0, t0_value);
    			}

    			if ((changed.$lessons) && a_href_value !== (a_href_value = "#/lesson/" + ctx.lesson.id)) {
    				attr(a, "href", a_href_value);
    			}

    			if (ctx.lesson.tags.length > 0) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_2$b(ctx);
    					if_block.c();
    					if_block.m(li, t2);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(li);
    			}

    			if (if_block) if_block.d();
    		}
    	};
    }

    function create_fragment$18(ctx) {
    	var section;

    	var if_block = (ctx.$lessons) && create_if_block$E(ctx);

    	return {
    		c: function create() {
    			section = element("section");
    			if (if_block) if_block.c();
    			attr(section, "class", "lesson-list svelte-4s8ccd");
    			add_location(section, file$11, 20, 0, 223);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, section, anchor);
    			if (if_block) if_block.m(section, null);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.$lessons) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$E(ctx);
    					if_block.c();
    					if_block.m(section, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(section);
    			}

    			if (if_block) if_block.d();
    		}
    	};
    }

    function instance$17($$self, $$props, $$invalidate) {
    	let $lessons;

    	validate_store(lessons, 'lessons');
    	component_subscribe($$self, lessons, $$value => { $lessons = $$value; $$invalidate('$lessons', $lessons); });

    	return { $lessons };
    }

    class LessonList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$17, create_fragment$18, safe_not_equal, []);
    	}
    }

    /* admin/src/components/lessons/Lessons.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$j } = globals;

    const file$12 = "admin/src/components/lessons/Lessons.svelte";

    // (41:18) 
    function create_if_block_1$n(ctx) {
    	var current;

    	var loading = new Loading({
    		props: { what: "lessons" },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			loading.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};
    }

    // (39:0) {#if $lessons}
    function create_if_block$F(ctx) {
    	var current;

    	var lessonlist = new LessonList({ $$inline: true });

    	return {
    		c: function create() {
    			lessonlist.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(lessonlist, target, anchor);
    			current = true;
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(lessonlist.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(lessonlist.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(lessonlist, detaching);
    		}
    	};
    }

    function create_fragment$19(ctx) {
    	var t0, h1, t2, t3, a, i, t4, t5, t6, current_block_type_index, if_block, if_block_anchor, current;

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	var filteritems = new FilterItems({
    		props: { searchParams: "name", store: lessons },
    		$$inline: true
    	});

    	var if_block_creators = [
    		create_if_block$F,
    		create_if_block_1$n
    	];

    	var if_blocks = [];

    	function select_block_type(changed, ctx) {
    		if (ctx.$lessons) return 0;
    		if (!ctx.errors) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(null, ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	return {
    		c: function create() {
    			t0 = space();
    			h1 = element("h1");
    			h1.textContent = "Lessons";
    			t2 = space();
    			error.$$.fragment.c();
    			t3 = space();
    			a = element("a");
    			i = element("i");
    			t4 = text("Create new lesson");
    			t5 = space();
    			filteritems.$$.fragment.c();
    			t6 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			document.title = "Lessons";
    			attr(h1, "class", "title");
    			add_location(h1, file$12, 28, 0, 612);
    			attr(i, "class", "fas fa-plus");
    			add_location(i, file$12, 33, 2, 730);
    			attr(a, "href", "#/new-lesson");
    			attr(a, "class", "button is-primary create-lesson");
    			add_location(a, file$12, 32, 0, 664);
    		},

    		l: function claim(nodes) {
    			throw new Error_1$j("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t0, anchor);
    			insert(target, h1, anchor);
    			insert(target, t2, anchor);
    			mount_component(error, target, anchor);
    			insert(target, t3, anchor);
    			insert(target, a, anchor);
    			append(a, i);
    			append(a, t4);
    			insert(target, t5, anchor);
    			mount_component(filteritems, target, anchor);
    			insert(target, t6, anchor);
    			if (~current_block_type_index) if_blocks[current_block_type_index].m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);

    			var filteritems_changes = {};
    			if (changed.lessons) filteritems_changes.store = lessons;
    			filteritems.$set(filteritems_changes);

    			var previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(changed, ctx);
    			if (current_block_type_index !== previous_block_index) {
    				if (if_block) {
    					group_outros();
    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});
    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];
    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					}
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);

    			transition_in(filteritems.$$.fragment, local);

    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			transition_out(filteritems.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t0);
    				detach(h1);
    				detach(t2);
    			}

    			destroy_component(error, detaching);

    			if (detaching) {
    				detach(t3);
    				detach(a);
    				detach(t5);
    			}

    			destroy_component(filteritems, detaching);

    			if (detaching) {
    				detach(t6);
    			}

    			if (~current_block_type_index) if_blocks[current_block_type_index].d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function instance$18($$self, $$props, $$invalidate) {
    	let $lessons;

    	validate_store(lessons, 'lessons');
    	component_subscribe($$self, lessons, $$value => { $lessons = $$value; $$invalidate('$lessons', $lessons); });

    	

      let errors = '';

      onMount(async () => {
        try {
          await lessons.get();
        } catch (error) {
          $$invalidate('errors', errors = error);
          notifications.add({ text: "Couldn't get lessons from server.", type: 'danger' });
        }
      });

    	return { errors, $lessons };
    }

    class Lessons extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$18, create_fragment$19, safe_not_equal, []);
    	}
    }

    const TAGS = /* GraphQL */ `
 {
   tags {
     id
     name
     connections
   }
 }`;

    const TAG = /* GraphQL */ `
 query ($id: ID!){
   tag (id: $id) {
     id
     name
     materials {
       id
       title
     }
    words {
      id
      english
    }
    lessons {
      id
      name
    }
   }
 }`;

    const CREATE_TAG = /* GraphQL */ `
 mutation CreateTag($name: String!) {
   createTag(name:$name) {
     id
     name
     connections
   }
 }`;

    const UPDATE_TAG = /* GraphQL */ `
  mutation UpdateTag($id: ID!, $input: TagUpdateInput!) {
    updateTag(id: $id, input:$input) {
      id
      name
      connections
    }
  }`;

    const DELETE_TAG = /* GraphQL */ `
 mutation DeleteTag ($id: ID!) {
   deleteTag(id:$id) {
     id
   }
 }`;

    const createTagsStore = () => {
      const { subscribe, set, update } = writable();

      return {
        subscribe,
        get: async () => {
          const response = await request(TAGS);
          const tags = response.tags.sort((a, b) => {
            return a.connections - b.connections
          });
          set(tags);
        },
        remove: async id => {
          await request(DELETE_TAG, { id });
          update(previous => previous && previous.filter(tag => id !== tag.id));
        },
        create: async (name) => {
          const response = await request(CREATE_TAG, { name });
          update(previous => !previous ? [response.createTag] : [...previous, response.createTag]);
        },
        patch: async ({ id, input }) => {
          const response = await request(UPDATE_TAG, { id, input });
          update(previous => !previous ? [response.updateTag] : previous.map((tag) => {
            if (tag.id !== id) return tag
            return response.updateTag
          }));
          return response.updateTag
        }
      }
    };

    const tags = createTagsStore();

    const createTagStore = () => {
      const { subscribe, set } = writable();

      return {
        subscribe,
        get: async (id) => {
          const response = await request(TAG, { id });
          set(response.tag);
        }
      }
    };

    const tag = createTagStore();

    /* admin/src/components/tags/AddTagToItem.svelte generated by Svelte v3.9.2 */
    const { console: console_1$6 } = globals;

    const file$13 = "admin/src/components/tags/AddTagToItem.svelte";

    function get_each_context$m(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.tag = list[i];
    	return child_ctx;
    }

    // (67:0) {#if otherTags}
    function create_if_block$G(ctx) {
    	var div, select, option, each_blocks = [], each_1_lookup = new Map(), dispose;

    	var each_value = ctx.otherTags;

    	const get_key = ctx => ctx.tag.id;

    	for (var i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$m(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$m(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			div = element("div");
    			select = element("select");
    			option = element("option");
    			option.textContent = "Add existing tag";

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();
    			option.__value = "";
    			option.value = option.__value;
    			add_location(option, file$13, 69, 6, 1486);
    			if (ctx.toAdd === void 0) add_render_callback(() => ctx.select_change_handler.call(select));
    			add_location(select, file$13, 68, 4, 1436);
    			attr(div, "class", "select svelte-16yzrx7");
    			add_location(div, file$13, 67, 0, 1411);

    			dispose = [
    				listen(select, "change", ctx.select_change_handler),
    				listen(select, "change", ctx.add)
    			];
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, select);
    			append(select, option);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(select, null);

    			select_option(select, ctx.toAdd);
    		},

    		p: function update(changed, ctx) {
    			const each_value = ctx.otherTags;
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, select, destroy_block, create_each_block$m, null, get_each_context$m);

    			if (changed.toAdd) select_option(select, ctx.toAdd);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d();

    			run_all(dispose);
    		}
    	};
    }

    // (71:6) {#each otherTags as tag (tag.id)}
    function create_each_block$m(key_1, ctx) {
    	var option, t_value = ctx.tag.name + "", t, option_value_value;

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = ctx.tag.id;
    			option.value = option.__value;
    			add_location(option, file$13, 71, 8, 1577);
    			this.first = option;
    		},

    		m: function mount(target, anchor) {
    			insert(target, option, anchor);
    			append(option, t);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.otherTags) && t_value !== (t_value = ctx.tag.name + "")) {
    				set_data(t, t_value);
    			}

    			if ((changed.otherTags) && option_value_value !== (option_value_value = ctx.tag.id)) {
    				option.__value = option_value_value;
    			}

    			option.value = option.__value;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(option);
    			}
    		}
    	};
    }

    function create_fragment$1a(ctx) {
    	var t0, div1, div0, input, t1, span, i, t2, button, dispose;

    	var if_block = (ctx.otherTags) && create_if_block$G(ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			t0 = space();
    			div1 = element("div");
    			div0 = element("div");
    			input = element("input");
    			t1 = space();
    			span = element("span");
    			i = element("i");
    			t2 = space();
    			button = element("button");
    			button.textContent = "add";
    			attr(input, "class", "input svelte-16yzrx7");
    			attr(input, "type", "text");
    			attr(input, "placeholder", "new tag");
    			add_location(input, file$13, 79, 4, 1742);
    			attr(i, "class", "fas fa-tag");
    			add_location(i, file$13, 81, 6, 1896);
    			attr(span, "class", "icon is-small is-left");
    			add_location(span, file$13, 80, 4, 1853);
    			attr(div0, "class", "control new has-icons-left");
    			add_location(div0, file$13, 78, 2, 1697);
    			attr(button, "class", "button is-success svelte-16yzrx7");
    			add_location(button, file$13, 84, 2, 1946);
    			attr(div1, "class", "field has-addons svelte-16yzrx7");
    			add_location(div1, file$13, 77, 0, 1664);

    			dispose = [
    				listen(input, "input", ctx.input_input_handler),
    				listen(input, "change", ctx.change_handler),
    				listen(button, "change", ctx.change_handler_1)
    			];
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, t0, anchor);
    			insert(target, div1, anchor);
    			append(div1, div0);
    			append(div0, input);

    			set_input_value(input, ctx.newTag);

    			append(div0, t1);
    			append(div0, span);
    			append(span, i);
    			append(div1, t2);
    			append(div1, button);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.otherTags) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$G(ctx);
    					if_block.c();
    					if_block.m(t0.parentNode, t0);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (changed.newTag && (input.value !== ctx.newTag)) set_input_value(input, ctx.newTag);
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(t0);
    				detach(div1);
    			}

    			run_all(dispose);
    		}
    	};
    }

    function instance$19($$self, $$props, $$invalidate) {
    	let $tags;

    	validate_store(tags, 'tags');
    	component_subscribe($$self, tags, $$value => { $tags = $$value; $$invalidate('$tags', $tags); });

    	

      let { item, store, type = '' } = $$props;
      let newTag = '';
      let toAdd;

      onMount(async () => {
        if (!$tags) {
          await tags.get();
        }
      });

      const add = async kind => {
        const input = {};
        if (kind === 'new') {
          if (!newTag) return
          input.tags = { create: { name: newTag } };
        } else {
          if (!toAdd) return
          input.tags = { connect: { id: toAdd } };
        }
        try {
          await store.patch({ input, id: item.id });
          notifications.add({ text: 'Added tag to item', type: 'success' });
          $$invalidate('newTag', newTag = '');
          $$invalidate('toAdd', toAdd = '');
        } catch (error) {
          console.error(error);
          notifications.add({ text: "Couldn't add tag to item", type: 'danger' });
        }
      };

    	const writable_props = ['item', 'store', 'type'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console_1$6.warn(`<AddTagToItem> was created with unknown prop '${key}'`);
    	});

    	function select_change_handler() {
    		toAdd = select_value(this);
    		$$invalidate('toAdd', toAdd);
    		$$invalidate('otherTags', otherTags), $$invalidate('$tags', $tags), $$invalidate('currentTags', currentTags), $$invalidate('item', item);
    	}

    	function input_input_handler() {
    		newTag = this.value;
    		$$invalidate('newTag', newTag);
    	}

    	function change_handler() {
    		return add('new');
    	}

    	function change_handler_1() {
    		return add('new');
    	}

    	$$self.$set = $$props => {
    		if ('item' in $$props) $$invalidate('item', item = $$props.item);
    		if ('store' in $$props) $$invalidate('store', store = $$props.store);
    		if ('type' in $$props) $$invalidate('type', type = $$props.type);
    	};

    	let currentTags, otherTags;

    	$$self.$$.update = ($$dirty = { item: 1, $tags: 1, currentTags: 1 }) => {
    		if ($$dirty.item) { $$invalidate('currentTags', currentTags = item.tags.length > 0 ? item.tags.map(t => t.id) : []); }
    		if ($$dirty.$tags || $$dirty.currentTags) { $$invalidate('otherTags', otherTags = ($tags && $tags.length > 0)
            ? $tags.filter(t => !currentTags.includes(t.id)).sort((a, b) => {
              const nameA = a.name.toUpperCase();
              const nameB = b.name.toUpperCase();
              if (nameA < nameB) return -1
              if (nameA > nameB) return 1
            })
            : []); }
    	};

    	return {
    		item,
    		store,
    		type,
    		newTag,
    		toAdd,
    		add,
    		otherTags,
    		select_change_handler,
    		input_input_handler,
    		change_handler,
    		change_handler_1
    	};
    }

    class AddTagToItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$19, create_fragment$1a, safe_not_equal, ["item", "store", "type"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.item === undefined && !('item' in props)) {
    			console_1$6.warn("<AddTagToItem> was created without expected prop 'item'");
    		}
    		if (ctx.store === undefined && !('store' in props)) {
    			console_1$6.warn("<AddTagToItem> was created without expected prop 'store'");
    		}
    	}

    	get item() {
    		throw new Error("<AddTagToItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<AddTagToItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get store() {
    		throw new Error("<AddTagToItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set store(value) {
    		throw new Error("<AddTagToItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<AddTagToItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<AddTagToItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/tags/TagOnItem.svelte generated by Svelte v3.9.2 */
    const { console: console_1$7 } = globals;

    const file$14 = "admin/src/components/tags/TagOnItem.svelte";

    function create_fragment$1b(ctx) {
    	var span, t0_value = ctx.tag.name + "", t0, t1, button, dispose;

    	return {
    		c: function create() {
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			button = element("button");
    			attr(button, "class", "delete is-small");
    			add_location(button, file$14, 26, 2, 631);
    			attr(span, "class", "tag is-dark");
    			add_location(span, file$14, 24, 0, 589);
    			dispose = listen(button, "click", ctx.remove);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, span, anchor);
    			append(span, t0);
    			append(span, t1);
    			append(span, button);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.tag) && t0_value !== (t0_value = ctx.tag.name + "")) {
    				set_data(t0, t0_value);
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(span);
    			}

    			dispose();
    		}
    	};
    }

    function instance$1a($$self, $$props, $$invalidate) {
    	

      let { tag, store, type, itemId } = $$props;

      const remove = async () => {
        const input = { tags: { disconnect: { id: tag.id } } };
        try {
          await store.patch({ input, id: itemId });
          notifications.add({
            text: `Removed tag '${tag.name}' from the item`,
            type: 'success'
          });
        } catch (error) {
          console.error(error);
          notifications.add({ text: `Could not remove tag '${tag.name}'`, type: 'danger' });
        }
      };

    	const writable_props = ['tag', 'store', 'type', 'itemId'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console_1$7.warn(`<TagOnItem> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('tag' in $$props) $$invalidate('tag', tag = $$props.tag);
    		if ('store' in $$props) $$invalidate('store', store = $$props.store);
    		if ('type' in $$props) $$invalidate('type', type = $$props.type);
    		if ('itemId' in $$props) $$invalidate('itemId', itemId = $$props.itemId);
    	};

    	return { tag, store, type, itemId, remove };
    }

    class TagOnItem extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1a, create_fragment$1b, safe_not_equal, ["tag", "store", "type", "itemId"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.tag === undefined && !('tag' in props)) {
    			console_1$7.warn("<TagOnItem> was created without expected prop 'tag'");
    		}
    		if (ctx.store === undefined && !('store' in props)) {
    			console_1$7.warn("<TagOnItem> was created without expected prop 'store'");
    		}
    		if (ctx.type === undefined && !('type' in props)) {
    			console_1$7.warn("<TagOnItem> was created without expected prop 'type'");
    		}
    		if (ctx.itemId === undefined && !('itemId' in props)) {
    			console_1$7.warn("<TagOnItem> was created without expected prop 'itemId'");
    		}
    	}

    	get tag() {
    		throw new Error("<TagOnItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tag(value) {
    		throw new Error("<TagOnItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get store() {
    		throw new Error("<TagOnItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set store(value) {
    		throw new Error("<TagOnItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<TagOnItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<TagOnItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get itemId() {
    		throw new Error("<TagOnItem>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set itemId(value) {
    		throw new Error("<TagOnItem>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/tags/ItemTagList.svelte generated by Svelte v3.9.2 */

    const file$15 = "admin/src/components/tags/ItemTagList.svelte";

    function get_each_context$n(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.tag = list[i];
    	return child_ctx;
    }

    // (17:0) {#if item.tags && item.tags.length > 0}
    function create_if_block$H(ctx) {
    	var div, each_blocks = [], each_1_lookup = new Map(), current;

    	var each_value = ctx.item.tags;

    	const get_key = ctx => ctx.tag.id;

    	for (var i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$n(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$n(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			div = element("div");

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();
    			attr(div, "class", "tags");
    			add_location(div, file$15, 17, 2, 292);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(div, null);

    			current = true;
    		},

    		p: function update(changed, ctx) {
    			const each_value = ctx.item.tags;

    			group_outros();
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$n, null, get_each_context$n);
    			check_outros();
    		},

    		i: function intro(local) {
    			if (current) return;
    			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

    			current = true;
    		},

    		o: function outro(local) {
    			for (i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d();
    		}
    	};
    }

    // (19:4) {#each item.tags as tag (tag.id)}
    function create_each_block$n(key_1, ctx) {
    	var first, current;

    	var tagonitem = new TagOnItem({
    		props: {
    		tag: ctx.tag,
    		itemId: ctx.item.id,
    		store: ctx.store,
    		type: ctx.type
    	},
    		$$inline: true
    	});

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			first = empty();
    			tagonitem.$$.fragment.c();
    			this.first = first;
    		},

    		m: function mount(target, anchor) {
    			insert(target, first, anchor);
    			mount_component(tagonitem, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var tagonitem_changes = {};
    			if (changed.item) tagonitem_changes.tag = ctx.tag;
    			if (changed.item) tagonitem_changes.itemId = ctx.item.id;
    			if (changed.store) tagonitem_changes.store = ctx.store;
    			if (changed.type) tagonitem_changes.type = ctx.type;
    			tagonitem.$set(tagonitem_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(tagonitem.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(tagonitem.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(first);
    			}

    			destroy_component(tagonitem, detaching);
    		}
    	};
    }

    function create_fragment$1c(ctx) {
    	var t, div, current;

    	var if_block = (ctx.item.tags && ctx.item.tags.length > 0) && create_if_block$H(ctx);

    	var addtagtoitem = new AddTagToItem({
    		props: {
    		item: ctx.item,
    		type: ctx.type,
    		store: ctx.store
    	},
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			div = element("div");
    			addtagtoitem.$$.fragment.c();
    			attr(div, "class", "tag-inputs svelte-eil3r6");
    			add_location(div, file$15, 24, 0, 437);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, t, anchor);
    			insert(target, div, anchor);
    			mount_component(addtagtoitem, div, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.item.tags && ctx.item.tags.length > 0) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$H(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}

    			var addtagtoitem_changes = {};
    			if (changed.item) addtagtoitem_changes.item = ctx.item;
    			if (changed.type) addtagtoitem_changes.type = ctx.type;
    			if (changed.store) addtagtoitem_changes.store = ctx.store;
    			addtagtoitem.$set(addtagtoitem_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);

    			transition_in(addtagtoitem.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(addtagtoitem.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(t);
    				detach(div);
    			}

    			destroy_component(addtagtoitem);
    		}
    	};
    }

    function instance$1b($$self, $$props, $$invalidate) {
    	

      let { item, store, type } = $$props;

    	const writable_props = ['item', 'store', 'type'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<ItemTagList> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('item' in $$props) $$invalidate('item', item = $$props.item);
    		if ('store' in $$props) $$invalidate('store', store = $$props.store);
    		if ('type' in $$props) $$invalidate('type', type = $$props.type);
    	};

    	return { item, store, type };
    }

    class ItemTagList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1b, create_fragment$1c, safe_not_equal, ["item", "store", "type"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.item === undefined && !('item' in props)) {
    			console.warn("<ItemTagList> was created without expected prop 'item'");
    		}
    		if (ctx.store === undefined && !('store' in props)) {
    			console.warn("<ItemTagList> was created without expected prop 'store'");
    		}
    		if (ctx.type === undefined && !('type' in props)) {
    			console.warn("<ItemTagList> was created without expected prop 'type'");
    		}
    	}

    	get item() {
    		throw new Error("<ItemTagList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<ItemTagList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get store() {
    		throw new Error("<ItemTagList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set store(value) {
    		throw new Error("<ItemTagList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error("<ItemTagList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error("<ItemTagList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/lessons/AddMaterialRow.svelte generated by Svelte v3.9.2 */
    const { console: console_1$8 } = globals;

    const file$16 = "admin/src/components/lessons/AddMaterialRow.svelte";

    function create_fragment$1d(ctx) {
    	var li, label, i, i_class_value, t0, t1_value = ctx.material.title + "", t1, t2, t3_value = ctx.material.type + "", t3, dispose;

    	return {
    		c: function create() {
    			li = element("li");
    			label = element("label");
    			i = element("i");
    			t0 = space();
    			t1 = text(t1_value);
    			t2 = text(" - ");
    			t3 = text(t3_value);
    			attr(i, "class", i_class_value = "fas fa-" + (ctx.isAdded ? 'check-' : '') + "square status" + " svelte-12hcy12");
    			add_location(i, file$16, 39, 4, 824);
    			attr(label, "class", "checkbox");
    			add_location(label, file$16, 38, 2, 795);
    			attr(li, "class", "svelte-12hcy12");
    			add_location(li, file$16, 37, 0, 770);
    			dispose = listen(li, "click", ctx.toggle);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, li, anchor);
    			append(li, label);
    			append(label, i);
    			append(label, t0);
    			append(label, t1);
    			append(label, t2);
    			append(label, t3);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.isAdded) && i_class_value !== (i_class_value = "fas fa-" + (ctx.isAdded ? 'check-' : '') + "square status" + " svelte-12hcy12")) {
    				attr(i, "class", i_class_value);
    			}

    			if ((changed.material) && t1_value !== (t1_value = ctx.material.title + "")) {
    				set_data(t1, t1_value);
    			}

    			if ((changed.material) && t3_value !== (t3_value = ctx.material.type + "")) {
    				set_data(t3, t3_value);
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(li);
    			}

    			dispose();
    		}
    	};
    }

    function instance$1c($$self, $$props, $$invalidate) {
    	let $lesson;

    	validate_store(lesson, 'lesson');
    	component_subscribe($$self, lesson, $$value => { $lesson = $$value; $$invalidate('$lesson', $lesson); });

    	

      let { material } = $$props;

      const toggle = async () => {
        const input = {};
        let text = 'Removed material from lesson';
        if (isAdded) {
          input.materials = { disconnect: { id: material.id } };
        } else {
          text = 'Added material to lesson';
          input.materials = { connect: { id: material.id } };
        }
        try {
          await lesson.patch({ id: $lesson.id, input });
          notifications.add({ text, type: 'success' });
        } catch (error) {
          console.error(error);
        }
      };

    	const writable_props = ['material'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console_1$8.warn(`<AddMaterialRow> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('material' in $$props) $$invalidate('material', material = $$props.material);
    	};

    	let isAdded;

    	$$self.$$.update = ($$dirty = { $lesson: 1, material: 1 }) => {
    		if ($$dirty.$lesson || $$dirty.material) { $$invalidate('isAdded', isAdded = !!$lesson.materials.find(m => m.id === material.id)); }
    	};

    	return { material, toggle, isAdded };
    }

    class AddMaterialRow$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1c, create_fragment$1d, safe_not_equal, ["material"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.material === undefined && !('material' in props)) {
    			console_1$8.warn("<AddMaterialRow> was created without expected prop 'material'");
    		}
    	}

    	get material() {
    		throw new Error("<AddMaterialRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set material(value) {
    		throw new Error("<AddMaterialRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/lessons/AddMaterialToLesson.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$k } = globals;

    const file$17 = "admin/src/components/lessons/AddMaterialToLesson.svelte";

    function get_each_context$o(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.material = list[i];
    	return child_ctx;
    }

    // (38:4) {#if $materials }
    function create_if_block$I(ctx) {
    	var p, t0_value = ctx.$materials.length + "", t0, t1, t2, each_blocks = [], each_1_lookup = new Map(), each_1_anchor, current;

    	var each_value = ctx.$materials;

    	const get_key = ctx => ctx.material.id;

    	for (var i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$o(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$o(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = text(" matches:");
    			t2 = space();

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();

    			each_1_anchor = empty();
    			add_location(p, file$17, 38, 4, 796);
    		},

    		m: function mount(target, anchor) {
    			insert(target, p, anchor);
    			append(p, t0);
    			append(p, t1);
    			insert(target, t2, anchor);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(target, anchor);

    			insert(target, each_1_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if ((!current || changed.$materials) && t0_value !== (t0_value = ctx.$materials.length + "")) {
    				set_data(t0, t0_value);
    			}

    			const each_value = ctx.$materials;

    			group_outros();
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$o, each_1_anchor, get_each_context$o);
    			check_outros();
    		},

    		i: function intro(local) {
    			if (current) return;
    			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

    			current = true;
    		},

    		o: function outro(local) {
    			for (i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(p);
    				detach(t2);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d(detaching);

    			if (detaching) {
    				detach(each_1_anchor);
    			}
    		}
    	};
    }

    // (40:4) {#each $materials as material (material.id)}
    function create_each_block$o(key_1, ctx) {
    	var first, current;

    	var addmaterialrow = new AddMaterialRow$1({
    		props: { material: ctx.material },
    		$$inline: true
    	});

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			first = empty();
    			addmaterialrow.$$.fragment.c();
    			this.first = first;
    		},

    		m: function mount(target, anchor) {
    			insert(target, first, anchor);
    			mount_component(addmaterialrow, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var addmaterialrow_changes = {};
    			if (changed.$materials) addmaterialrow_changes.material = ctx.material;
    			addmaterialrow.$set(addmaterialrow_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(addmaterialrow.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(addmaterialrow.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(first);
    			}

    			destroy_component(addmaterialrow, detaching);
    		}
    	};
    }

    // (30:0) <Modal bind:open>
    function create_default_slot$f(ctx) {
    	var h2, t1, t2, t3, div0, t4, div1, button, current, dispose;

    	var filteritems = new FilterItems({
    		props: {
    		store: materials,
    		searchParams: "title"
    	},
    		$$inline: true
    	});

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	var if_block = (ctx.$materials) && create_if_block$I(ctx);

    	return {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "Add material to lesson";
    			t1 = space();
    			filteritems.$$.fragment.c();
    			t2 = space();
    			error.$$.fragment.c();
    			t3 = space();
    			div0 = element("div");
    			if (if_block) if_block.c();
    			t4 = space();
    			div1 = element("div");
    			button = element("button");
    			button.textContent = "Exit";
    			attr(h2, "class", "title is-4");
    			add_location(h2, file$17, 31, 2, 615);
    			attr(div0, "class", "results");
    			add_location(div0, file$17, 36, 2, 748);
    			attr(button, "class", "button");
    			add_location(button, file$17, 46, 4, 977);
    			attr(div1, "class", "buttons svelte-jsaq7t");
    			add_location(div1, file$17, 45, 2, 951);
    			dispose = listen(button, "click", ctx.click_handler_1);
    		},

    		m: function mount(target, anchor) {
    			insert(target, h2, anchor);
    			insert(target, t1, anchor);
    			mount_component(filteritems, target, anchor);
    			insert(target, t2, anchor);
    			mount_component(error, target, anchor);
    			insert(target, t3, anchor);
    			insert(target, div0, anchor);
    			if (if_block) if_block.m(div0, null);
    			insert(target, t4, anchor);
    			insert(target, div1, anchor);
    			append(div1, button);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var filteritems_changes = {};
    			if (changed.materials) filteritems_changes.store = materials;
    			filteritems.$set(filteritems_changes);

    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);

    			if (ctx.$materials) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$I(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div0, null);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(filteritems.$$.fragment, local);

    			transition_in(error.$$.fragment, local);

    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(filteritems.$$.fragment, local);
    			transition_out(error.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h2);
    				detach(t1);
    			}

    			destroy_component(filteritems, detaching);

    			if (detaching) {
    				detach(t2);
    			}

    			destroy_component(error, detaching);

    			if (detaching) {
    				detach(t3);
    				detach(div0);
    			}

    			if (if_block) if_block.d();

    			if (detaching) {
    				detach(t4);
    				detach(div1);
    			}

    			dispose();
    		}
    	};
    }

    function create_fragment$1e(ctx) {
    	var button, t_1, updating_open, current, dispose;

    	function modal_open_binding(value) {
    		ctx.modal_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let modal_props = {
    		$$slots: { default: [create_default_slot$f] },
    		$$scope: { ctx }
    	};
    	if (ctx.open !== void 0) {
    		modal_props.open = ctx.open;
    	}
    	var modal = new Modal({ props: modal_props, $$inline: true });

    	binding_callbacks.push(() => bind(modal, 'open', modal_open_binding));

    	return {
    		c: function create() {
    			button = element("button");
    			button.textContent = "add material";
    			t_1 = space();
    			modal.$$.fragment.c();
    			attr(button, "class", "button");
    			add_location(button, file$17, 27, 0, 515);
    			dispose = listen(button, "click", ctx.click_handler);
    		},

    		l: function claim(nodes) {
    			throw new Error_1$k("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);
    			insert(target, t_1, anchor);
    			mount_component(modal, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var modal_changes = {};
    			if (changed.$$scope || changed.$materials || changed.errors) modal_changes.$$scope = { changed, ctx };
    			if (!updating_open && changed.open) {
    				modal_changes.open = ctx.open;
    			}
    			modal.$set(modal_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(button);
    				detach(t_1);
    			}

    			destroy_component(modal, detaching);

    			dispose();
    		}
    	};
    }

    function instance$1d($$self, $$props, $$invalidate) {
    	let $materials;

    	validate_store(materials, 'materials');
    	component_subscribe($$self, materials, $$value => { $materials = $$value; $$invalidate('$materials', $materials); });

    	

      let { lesson } = $$props;
      let open = false;
      let errors = '';

      onMount(async () => {
        try {
          await materials.get();
        } catch (error) {
          $$invalidate('errors', errors = error);
        }
      });

    	const writable_props = ['lesson'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<AddMaterialToLesson> was created with unknown prop '${key}'`);
    	});

    	function click_handler() { open = true; $$invalidate('open', open); }

    	function click_handler_1() { open = false; $$invalidate('open', open); }

    	function modal_open_binding(value) {
    		open = value;
    		$$invalidate('open', open);
    	}

    	$$self.$set = $$props => {
    		if ('lesson' in $$props) $$invalidate('lesson', lesson = $$props.lesson);
    	};

    	return {
    		lesson,
    		open,
    		errors,
    		$materials,
    		click_handler,
    		click_handler_1,
    		modal_open_binding
    	};
    }

    class AddMaterialToLesson extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1d, create_fragment$1e, safe_not_equal, ["lesson"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.lesson === undefined && !('lesson' in props)) {
    			console.warn("<AddMaterialToLesson> was created without expected prop 'lesson'");
    		}
    	}

    	get lesson() {
    		throw new Error_1$k("<AddMaterialToLesson>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lesson(value) {
    		throw new Error_1$k("<AddMaterialToLesson>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/lessons/AddWordRow.svelte generated by Svelte v3.9.2 */
    const { console: console_1$9 } = globals;

    const file$18 = "admin/src/components/lessons/AddWordRow.svelte";

    // (41:4) {#if word.chinese}
    function create_if_block$J(ctx) {
    	var t0, t1_value = ctx.word.chinese + "", t1, t2;

    	return {
    		c: function create() {
    			t0 = text("(");
    			t1 = text(t1_value);
    			t2 = text(")");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t0, anchor);
    			insert(target, t1, anchor);
    			insert(target, t2, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.word) && t1_value !== (t1_value = ctx.word.chinese + "")) {
    				set_data(t1, t1_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t0);
    				detach(t1);
    				detach(t2);
    			}
    		}
    	};
    }

    function create_fragment$1f(ctx) {
    	var li, label, i, i_class_value, t0, t1_value = ctx.word.english + "", t1, t2, dispose;

    	var if_block = (ctx.word.chinese) && create_if_block$J(ctx);

    	return {
    		c: function create() {
    			li = element("li");
    			label = element("label");
    			i = element("i");
    			t0 = space();
    			t1 = text(t1_value);
    			t2 = space();
    			if (if_block) if_block.c();
    			attr(i, "class", i_class_value = "fas fa-" + (ctx.isAdded ? 'check-' : '') + "square status" + " svelte-12hcy12");
    			add_location(i, file$18, 38, 4, 787);
    			attr(label, "class", "checkbox");
    			add_location(label, file$18, 37, 2, 758);
    			attr(li, "class", "svelte-12hcy12");
    			add_location(li, file$18, 36, 0, 733);
    			dispose = listen(li, "click", ctx.toggle);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, li, anchor);
    			append(li, label);
    			append(label, i);
    			append(label, t0);
    			append(label, t1);
    			append(label, t2);
    			if (if_block) if_block.m(label, null);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.isAdded) && i_class_value !== (i_class_value = "fas fa-" + (ctx.isAdded ? 'check-' : '') + "square status" + " svelte-12hcy12")) {
    				attr(i, "class", i_class_value);
    			}

    			if ((changed.word) && t1_value !== (t1_value = ctx.word.english + "")) {
    				set_data(t1, t1_value);
    			}

    			if (ctx.word.chinese) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$J(ctx);
    					if_block.c();
    					if_block.m(label, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(li);
    			}

    			if (if_block) if_block.d();
    			dispose();
    		}
    	};
    }

    function instance$1e($$self, $$props, $$invalidate) {
    	let $lesson;

    	validate_store(lesson, 'lesson');
    	component_subscribe($$self, lesson, $$value => { $lesson = $$value; $$invalidate('$lesson', $lesson); });

    	

      let { word } = $$props;

      const toggle = async () => {
        const input = {};
        let text = 'Removed word from lesson';
        if (isAdded) {
          input.words = { disconnect: { id: word.id } };
        } else {
          text = 'Added word to lesson';
          input.words = { connect: { id: word.id } };
        }
        try {
          await lesson.patch({ id: $lesson.id, input });
          notifications.add({ text, type: 'success' });
        } catch (error) {
          console.error(error);
        }
      };

    	const writable_props = ['word'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console_1$9.warn(`<AddWordRow> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('word' in $$props) $$invalidate('word', word = $$props.word);
    	};

    	let isAdded;

    	$$self.$$.update = ($$dirty = { $lesson: 1, word: 1 }) => {
    		if ($$dirty.$lesson || $$dirty.word) { $$invalidate('isAdded', isAdded = !!$lesson.words.find(w => w.id === word.id)); }
    	};

    	return { word, toggle, isAdded };
    }

    class AddWordRow$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1e, create_fragment$1f, safe_not_equal, ["word"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.word === undefined && !('word' in props)) {
    			console_1$9.warn("<AddWordRow> was created without expected prop 'word'");
    		}
    	}

    	get word() {
    		throw new Error("<AddWordRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set word(value) {
    		throw new Error("<AddWordRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/lessons/AddWordToLesson.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$l } = globals;

    const file$19 = "admin/src/components/lessons/AddWordToLesson.svelte";

    function get_each_context$p(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.word = list[i];
    	return child_ctx;
    }

    // (38:4) {#if $words }
    function create_if_block$K(ctx) {
    	var p, t0_value = ctx.$words.length + "", t0, t1, t2, each_blocks = [], each_1_lookup = new Map(), each_1_anchor, current;

    	var each_value = ctx.$words;

    	const get_key = ctx => ctx.word.id;

    	for (var i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$p(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$p(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = text(" matches:");
    			t2 = space();

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();

    			each_1_anchor = empty();
    			add_location(p, file$19, 38, 6, 765);
    		},

    		m: function mount(target, anchor) {
    			insert(target, p, anchor);
    			append(p, t0);
    			append(p, t1);
    			insert(target, t2, anchor);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(target, anchor);

    			insert(target, each_1_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if ((!current || changed.$words) && t0_value !== (t0_value = ctx.$words.length + "")) {
    				set_data(t0, t0_value);
    			}

    			const each_value = ctx.$words;

    			group_outros();
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$p, each_1_anchor, get_each_context$p);
    			check_outros();
    		},

    		i: function intro(local) {
    			if (current) return;
    			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

    			current = true;
    		},

    		o: function outro(local) {
    			for (i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(p);
    				detach(t2);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d(detaching);

    			if (detaching) {
    				detach(each_1_anchor);
    			}
    		}
    	};
    }

    // (40:6) {#each $words as word (word.id)}
    function create_each_block$p(key_1, ctx) {
    	var first, current;

    	var addwordrow = new AddWordRow$1({
    		props: { word: ctx.word },
    		$$inline: true
    	});

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			first = empty();
    			addwordrow.$$.fragment.c();
    			this.first = first;
    		},

    		m: function mount(target, anchor) {
    			insert(target, first, anchor);
    			mount_component(addwordrow, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var addwordrow_changes = {};
    			if (changed.$words) addwordrow_changes.word = ctx.word;
    			addwordrow.$set(addwordrow_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(addwordrow.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(addwordrow.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(first);
    			}

    			destroy_component(addwordrow, detaching);
    		}
    	};
    }

    // (29:0) <Modal bind:open>
    function create_default_slot$g(ctx) {
    	var h2, t1, t2, t3, div0, t4, div1, button, current, dispose;

    	var filteritems = new FilterItems({
    		props: {
    		store: words,
    		searchParams: ['english', 'chinese']
    	},
    		$$inline: true
    	});

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	var if_block = (ctx.$words) && create_if_block$K(ctx);

    	return {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "Add word to lesson";
    			t1 = space();
    			filteritems.$$.fragment.c();
    			t2 = space();
    			error.$$.fragment.c();
    			t3 = space();
    			div0 = element("div");
    			if (if_block) if_block.c();
    			t4 = space();
    			div1 = element("div");
    			button = element("button");
    			button.textContent = "Exit";
    			attr(h2, "class", "title is-4");
    			add_location(h2, file$19, 30, 2, 576);
    			attr(div0, "class", "results");
    			add_location(div0, file$19, 36, 2, 719);
    			attr(button, "class", "button");
    			add_location(button, file$19, 46, 6, 938);
    			attr(div1, "class", "buttons svelte-jsaq7t");
    			add_location(div1, file$19, 45, 4, 910);
    			dispose = listen(button, "click", ctx.click_handler_1);
    		},

    		m: function mount(target, anchor) {
    			insert(target, h2, anchor);
    			insert(target, t1, anchor);
    			mount_component(filteritems, target, anchor);
    			insert(target, t2, anchor);
    			mount_component(error, target, anchor);
    			insert(target, t3, anchor);
    			insert(target, div0, anchor);
    			if (if_block) if_block.m(div0, null);
    			insert(target, t4, anchor);
    			insert(target, div1, anchor);
    			append(div1, button);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var filteritems_changes = {};
    			if (changed.words) filteritems_changes.store = words;
    			filteritems.$set(filteritems_changes);

    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);

    			if (ctx.$words) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$K(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div0, null);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(filteritems.$$.fragment, local);

    			transition_in(error.$$.fragment, local);

    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(filteritems.$$.fragment, local);
    			transition_out(error.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h2);
    				detach(t1);
    			}

    			destroy_component(filteritems, detaching);

    			if (detaching) {
    				detach(t2);
    			}

    			destroy_component(error, detaching);

    			if (detaching) {
    				detach(t3);
    				detach(div0);
    			}

    			if (if_block) if_block.d();

    			if (detaching) {
    				detach(t4);
    				detach(div1);
    			}

    			dispose();
    		}
    	};
    }

    function create_fragment$1g(ctx) {
    	var button, t_1, updating_open, current, dispose;

    	function modal_open_binding(value) {
    		ctx.modal_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let modal_props = {
    		$$slots: { default: [create_default_slot$g] },
    		$$scope: { ctx }
    	};
    	if (ctx.open !== void 0) {
    		modal_props.open = ctx.open;
    	}
    	var modal = new Modal({ props: modal_props, $$inline: true });

    	binding_callbacks.push(() => bind(modal, 'open', modal_open_binding));

    	return {
    		c: function create() {
    			button = element("button");
    			button.textContent = "add words";
    			t_1 = space();
    			modal.$$.fragment.c();
    			attr(button, "class", "button add");
    			add_location(button, file$19, 26, 0, 475);
    			dispose = listen(button, "click", ctx.click_handler);
    		},

    		l: function claim(nodes) {
    			throw new Error_1$l("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);
    			insert(target, t_1, anchor);
    			mount_component(modal, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var modal_changes = {};
    			if (changed.$$scope || changed.$words || changed.errors) modal_changes.$$scope = { changed, ctx };
    			if (!updating_open && changed.open) {
    				modal_changes.open = ctx.open;
    			}
    			modal.$set(modal_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(button);
    				detach(t_1);
    			}

    			destroy_component(modal, detaching);

    			dispose();
    		}
    	};
    }

    function instance$1f($$self, $$props, $$invalidate) {
    	let $words;

    	validate_store(words, 'words');
    	component_subscribe($$self, words, $$value => { $words = $$value; $$invalidate('$words', $words); });

    	

      let open = false;
      let errors = '';

      onMount(async () => {
        try {
          await words.get();
        } catch (error) {
          $$invalidate('errors', errors = error);
        }
      });

    	function click_handler() { open = true; $$invalidate('open', open); }

    	function click_handler_1() { open = false; $$invalidate('open', open); }

    	function modal_open_binding(value) {
    		open = value;
    		$$invalidate('open', open);
    	}

    	return {
    		open,
    		errors,
    		$words,
    		click_handler,
    		click_handler_1,
    		modal_open_binding
    	};
    }

    class AddWordToLesson extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1f, create_fragment$1g, safe_not_equal, []);
    	}
    }

    /* admin/src/components/lessons/RemoveMaterialButton.svelte generated by Svelte v3.9.2 */
    const { console: console_1$a } = globals;

    const file$1a = "admin/src/components/lessons/RemoveMaterialButton.svelte";

    function create_fragment$1h(ctx) {
    	var button, dispose;

    	return {
    		c: function create() {
    			button = element("button");
    			attr(button, "class", "delete");
    			add_location(button, file$1a, 17, 0, 434);
    			dispose = listen(button, "click", ctx.remove);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);
    		},

    		p: noop,
    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(button);
    			}

    			dispose();
    		}
    	};
    }

    function instance$1g($$self, $$props, $$invalidate) {
    	let $lesson;

    	validate_store(lesson, 'lesson');
    	component_subscribe($$self, lesson, $$value => { $lesson = $$value; $$invalidate('$lesson', $lesson); });

    	

      let { materialId } = $$props;

      const remove = async () => {
        const input = { materials: { disconnect: { id: materialId } } };
        try {
          await lesson.patch({ id: $lesson.id, input });
          notifications.add({ text: 'Removed material from lesson', type: 'success' });
        } catch (error) {
          console.error(error);
        }
      };

    	const writable_props = ['materialId'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console_1$a.warn(`<RemoveMaterialButton> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('materialId' in $$props) $$invalidate('materialId', materialId = $$props.materialId);
    	};

    	return { materialId, remove };
    }

    class RemoveMaterialButton$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1g, create_fragment$1h, safe_not_equal, ["materialId"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.materialId === undefined && !('materialId' in props)) {
    			console_1$a.warn("<RemoveMaterialButton> was created without expected prop 'materialId'");
    		}
    	}

    	get materialId() {
    		throw new Error("<RemoveMaterialButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set materialId(value) {
    		throw new Error("<RemoveMaterialButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/lessons/RemoveWordButton.svelte generated by Svelte v3.9.2 */
    const { console: console_1$b } = globals;

    const file$1b = "admin/src/components/lessons/RemoveWordButton.svelte";

    function create_fragment$1i(ctx) {
    	var button, dispose;

    	return {
    		c: function create() {
    			button = element("button");
    			attr(button, "class", "delete");
    			add_location(button, file$1b, 17, 0, 418);
    			dispose = listen(button, "click", ctx.remove);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);
    		},

    		p: noop,
    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(button);
    			}

    			dispose();
    		}
    	};
    }

    function instance$1h($$self, $$props, $$invalidate) {
    	let $lesson;

    	validate_store(lesson, 'lesson');
    	component_subscribe($$self, lesson, $$value => { $lesson = $$value; $$invalidate('$lesson', $lesson); });

    	

      let { wordId } = $$props;

      const remove = async () => {
        const input = { words: { disconnect: { id: wordId } } };
        try {
          await lesson.patch({ id: $lesson.id, input });
          notifications.add({ text: 'Removed word from lesson', type: 'success' });
        } catch (error) {
          console.error(error);
        }
      };

    	const writable_props = ['wordId'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console_1$b.warn(`<RemoveWordButton> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('wordId' in $$props) $$invalidate('wordId', wordId = $$props.wordId);
    	};

    	return { wordId, remove };
    }

    class RemoveWordButton$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1h, create_fragment$1i, safe_not_equal, ["wordId"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.wordId === undefined && !('wordId' in props)) {
    			console_1$b.warn("<RemoveWordButton> was created without expected prop 'wordId'");
    		}
    	}

    	get wordId() {
    		throw new Error("<RemoveWordButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set wordId(value) {
    		throw new Error("<RemoveWordButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/lessons/Lesson.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$m } = globals;

    const file$1c = "admin/src/components/lessons/Lesson.svelte";

    function get_each_context$q(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.word = list[i];
    	return child_ctx;
    }

    function get_each_context_1$4(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.material = list[i];
    	return child_ctx;
    }

    // (55:0) {#if errors}
    function create_if_block_5$2(ctx) {
    	var current;

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			error.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(error, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(error, detaching);
    		}
    	};
    }

    // (121:18) 
    function create_if_block_4$2(ctx) {
    	var current;

    	var loading = new Loading({
    		props: { what: "Lesson" },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			loading.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},

    		p: noop,

    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};
    }

    // (59:0) {#if $lesson && $lesson.id === params.id}
    function create_if_block$L(ctx) {
    	var h1, t0_value = ctx.$lesson.name + "", t0, t1, t2, section0, h20, t4, html_tag, raw0_value = marked(ctx.$lesson.summaryEN, { breaks: true }) + "", t5, h21, t7, html_tag_1, raw1_value = marked(ctx.$lesson.homeworkEN, { breaks: true }) + "", t8, h22, t10, html_tag_2, raw2_value = marked(ctx.$lesson.summaryZH, { breaks: true }) + "", t11, h23, t13, html_tag_3, raw3_value = marked(ctx.$lesson.homeworkZH, { breaks: true }) + "", t14, section1, h24, t16, t17, t18, section2, h25, t20, t21, t22, section3, h26, t24, div, a, i0, t25, a_href_value, t26, button, i1, t27, t28, updating_open, current, dispose;

    	var itemtaglist = new ItemTagList({
    		props: {
    		item: ctx.$lesson,
    		type: "lessons",
    		store: lesson
    	},
    		$$inline: true
    	});

    	var if_block0 = (ctx.$lesson.materials && ctx.$lesson.materials.length > 0) && create_if_block_3$5(ctx);

    	var addmaterialtolesson = new AddMaterialToLesson({
    		props: { lesson: ctx.$lesson },
    		$$inline: true
    	});

    	var if_block1 = (ctx.$lesson.words && ctx.$lesson.words.length > 0) && create_if_block_1$o(ctx);

    	var addwordtolesson = new AddWordToLesson({ $$inline: true });

    	function deleteitem_open_binding(value) {
    		ctx.deleteitem_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let deleteitem_props = {
    		id: ctx.$lesson.id,
    		store: lessons,
    		type: "lesson",
    		name: ctx.$lesson.title
    	};
    	if (ctx.showDelete !== void 0) {
    		deleteitem_props.open = ctx.showDelete;
    	}
    	var deleteitem = new DeleteItem({ props: deleteitem_props, $$inline: true });

    	binding_callbacks.push(() => bind(deleteitem, 'open', deleteitem_open_binding));

    	return {
    		c: function create() {
    			h1 = element("h1");
    			t0 = text(t0_value);
    			t1 = space();
    			itemtaglist.$$.fragment.c();
    			t2 = space();
    			section0 = element("section");
    			h20 = element("h2");
    			h20.textContent = "Summary (English)";
    			t4 = space();
    			t5 = space();
    			h21 = element("h2");
    			h21.textContent = "Homework (English)";
    			t7 = space();
    			t8 = space();
    			h22 = element("h2");
    			h22.textContent = "Summary (Chinese)";
    			t10 = space();
    			t11 = space();
    			h23 = element("h2");
    			h23.textContent = "Homework (Chinese)";
    			t13 = space();
    			t14 = space();
    			section1 = element("section");
    			h24 = element("h2");
    			h24.textContent = "Materials";
    			t16 = space();
    			if (if_block0) if_block0.c();
    			t17 = space();
    			addmaterialtolesson.$$.fragment.c();
    			t18 = space();
    			section2 = element("section");
    			h25 = element("h2");
    			h25.textContent = "Words";
    			t20 = space();
    			if (if_block1) if_block1.c();
    			t21 = space();
    			addwordtolesson.$$.fragment.c();
    			t22 = space();
    			section3 = element("section");
    			h26 = element("h2");
    			h26.textContent = "Lesson actions";
    			t24 = space();
    			div = element("div");
    			a = element("a");
    			i0 = element("i");
    			t25 = text("Edit");
    			t26 = space();
    			button = element("button");
    			i1 = element("i");
    			t27 = text("Delete");
    			t28 = space();
    			deleteitem.$$.fragment.c();
    			attr(h1, "class", "title");
    			add_location(h1, file$1c, 59, 2, 1347);
    			attr(h20, "class", "title is-4 svelte-14e6l9j");
    			add_location(h20, file$1c, 64, 4, 1484);
    			html_tag = new HtmlTag(raw0_value, t5);
    			attr(h21, "class", "title is-4 svelte-14e6l9j");
    			add_location(h21, file$1c, 67, 4, 1593);
    			html_tag_1 = new HtmlTag(raw1_value, t8);
    			attr(h22, "class", "title is-4 svelte-14e6l9j");
    			add_location(h22, file$1c, 70, 4, 1702);
    			html_tag_2 = new HtmlTag(raw2_value, t11);
    			attr(h23, "class", "title is-4 svelte-14e6l9j");
    			add_location(h23, file$1c, 73, 4, 1811);
    			html_tag_3 = new HtmlTag(raw3_value, null);
    			attr(section0, "class", "summaries svelte-14e6l9j");
    			add_location(section0, file$1c, 63, 2, 1452);
    			attr(h24, "class", "title is-4 svelte-14e6l9j");
    			add_location(h24, file$1c, 78, 4, 1965);
    			attr(section1, "class", "materials svelte-14e6l9j");
    			add_location(section1, file$1c, 77, 2, 1933);
    			attr(h25, "class", "title is-4 svelte-14e6l9j");
    			add_location(h25, file$1c, 94, 4, 2461);
    			attr(section2, "class", "words svelte-14e6l9j");
    			add_location(section2, file$1c, 93, 2, 2433);
    			attr(h26, "class", "title is-4 svelte-14e6l9j");
    			add_location(h26, file$1c, 112, 4, 2920);
    			attr(i0, "class", "fas fa-edit");
    			add_location(i0, file$1c, 114, 67, 3056);
    			attr(a, "class", "button is-primary");
    			attr(a, "href", a_href_value = "#/edit-lesson/" + ctx.$lesson.id);
    			add_location(a, file$1c, 114, 4, 2993);
    			attr(i1, "class", "fas fa-trash");
    			add_location(i1, file$1c, 115, 76, 3168);
    			attr(button, "class", "button is-danger");
    			add_location(button, file$1c, 115, 4, 3096);
    			attr(div, "class", "buttons");
    			add_location(div, file$1c, 113, 4, 2967);
    			attr(section3, "class", "actions svelte-14e6l9j");
    			add_location(section3, file$1c, 111, 2, 2890);
    			dispose = listen(button, "click", ctx.click_handler);
    		},

    		m: function mount(target, anchor) {
    			insert(target, h1, anchor);
    			append(h1, t0);
    			insert(target, t1, anchor);
    			mount_component(itemtaglist, target, anchor);
    			insert(target, t2, anchor);
    			insert(target, section0, anchor);
    			append(section0, h20);
    			append(section0, t4);
    			html_tag.m(section0);
    			append(section0, t5);
    			append(section0, h21);
    			append(section0, t7);
    			html_tag_1.m(section0);
    			append(section0, t8);
    			append(section0, h22);
    			append(section0, t10);
    			html_tag_2.m(section0);
    			append(section0, t11);
    			append(section0, h23);
    			append(section0, t13);
    			html_tag_3.m(section0);
    			insert(target, t14, anchor);
    			insert(target, section1, anchor);
    			append(section1, h24);
    			append(section1, t16);
    			if (if_block0) if_block0.m(section1, null);
    			append(section1, t17);
    			mount_component(addmaterialtolesson, section1, null);
    			insert(target, t18, anchor);
    			insert(target, section2, anchor);
    			append(section2, h25);
    			append(section2, t20);
    			if (if_block1) if_block1.m(section2, null);
    			append(section2, t21);
    			mount_component(addwordtolesson, section2, null);
    			insert(target, t22, anchor);
    			insert(target, section3, anchor);
    			append(section3, h26);
    			append(section3, t24);
    			append(section3, div);
    			append(div, a);
    			append(a, i0);
    			append(a, t25);
    			append(div, t26);
    			append(div, button);
    			append(button, i1);
    			append(button, t27);
    			append(div, t28);
    			mount_component(deleteitem, div, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if ((!current || changed.$lesson) && t0_value !== (t0_value = ctx.$lesson.name + "")) {
    				set_data(t0, t0_value);
    			}

    			var itemtaglist_changes = {};
    			if (changed.$lesson) itemtaglist_changes.item = ctx.$lesson;
    			if (changed.lesson) itemtaglist_changes.store = lesson;
    			itemtaglist.$set(itemtaglist_changes);

    			if ((!current || changed.$lesson) && raw0_value !== (raw0_value = marked(ctx.$lesson.summaryEN, { breaks: true }) + "")) {
    				html_tag.p(raw0_value);
    			}

    			if ((!current || changed.$lesson) && raw1_value !== (raw1_value = marked(ctx.$lesson.homeworkEN, { breaks: true }) + "")) {
    				html_tag_1.p(raw1_value);
    			}

    			if ((!current || changed.$lesson) && raw2_value !== (raw2_value = marked(ctx.$lesson.summaryZH, { breaks: true }) + "")) {
    				html_tag_2.p(raw2_value);
    			}

    			if ((!current || changed.$lesson) && raw3_value !== (raw3_value = marked(ctx.$lesson.homeworkZH, { breaks: true }) + "")) {
    				html_tag_3.p(raw3_value);
    			}

    			if (ctx.$lesson.materials && ctx.$lesson.materials.length > 0) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    					transition_in(if_block0, 1);
    				} else {
    					if_block0 = create_if_block_3$5(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(section1, t17);
    				}
    			} else if (if_block0) {
    				group_outros();
    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});
    				check_outros();
    			}

    			var addmaterialtolesson_changes = {};
    			if (changed.$lesson) addmaterialtolesson_changes.lesson = ctx.$lesson;
    			addmaterialtolesson.$set(addmaterialtolesson_changes);

    			if (ctx.$lesson.words && ctx.$lesson.words.length > 0) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    					transition_in(if_block1, 1);
    				} else {
    					if_block1 = create_if_block_1$o(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(section2, t21);
    				}
    			} else if (if_block1) {
    				group_outros();
    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});
    				check_outros();
    			}

    			if ((!current || changed.$lesson) && a_href_value !== (a_href_value = "#/edit-lesson/" + ctx.$lesson.id)) {
    				attr(a, "href", a_href_value);
    			}

    			var deleteitem_changes = {};
    			if (changed.$lesson) deleteitem_changes.id = ctx.$lesson.id;
    			if (changed.lessons) deleteitem_changes.store = lessons;
    			if (changed.$lesson) deleteitem_changes.name = ctx.$lesson.title;
    			if (!updating_open && changed.showDelete) {
    				deleteitem_changes.open = ctx.showDelete;
    			}
    			deleteitem.$set(deleteitem_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(itemtaglist.$$.fragment, local);

    			transition_in(if_block0);

    			transition_in(addmaterialtolesson.$$.fragment, local);

    			transition_in(if_block1);

    			transition_in(addwordtolesson.$$.fragment, local);

    			transition_in(deleteitem.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(itemtaglist.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(addmaterialtolesson.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(addwordtolesson.$$.fragment, local);
    			transition_out(deleteitem.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h1);
    				detach(t1);
    			}

    			destroy_component(itemtaglist, detaching);

    			if (detaching) {
    				detach(t2);
    				detach(section0);
    				detach(t14);
    				detach(section1);
    			}

    			if (if_block0) if_block0.d();

    			destroy_component(addmaterialtolesson);

    			if (detaching) {
    				detach(t18);
    				detach(section2);
    			}

    			if (if_block1) if_block1.d();

    			destroy_component(addwordtolesson);

    			if (detaching) {
    				detach(t22);
    				detach(section3);
    			}

    			destroy_component(deleteitem);

    			dispose();
    		}
    	};
    }

    // (80:4) {#if $lesson.materials && $lesson.materials.length > 0}
    function create_if_block_3$5(ctx) {
    	var ul, each_blocks = [], each_1_lookup = new Map(), current;

    	var each_value_1 = ctx.$lesson.materials;

    	const get_key = ctx => ctx.material.id;

    	for (var i = 0; i < each_value_1.length; i += 1) {
    		let child_ctx = get_each_context_1$4(ctx, each_value_1, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_1$4(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			ul = element("ul");

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();
    			attr(ul, "class", "materials-list svelte-14e6l9j");
    			add_location(ul, file$1c, 80, 4, 2067);
    		},

    		m: function mount(target, anchor) {
    			insert(target, ul, anchor);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(ul, null);

    			current = true;
    		},

    		p: function update(changed, ctx) {
    			const each_value_1 = ctx.$lesson.materials;

    			group_outros();
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value_1, each_1_lookup, ul, outro_and_destroy_block, create_each_block_1$4, null, get_each_context_1$4);
    			check_outros();
    		},

    		i: function intro(local) {
    			if (current) return;
    			for (var i = 0; i < each_value_1.length; i += 1) transition_in(each_blocks[i]);

    			current = true;
    		},

    		o: function outro(local) {
    			for (i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(ul);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d();
    		}
    	};
    }

    // (82:6) {#each $lesson.materials as material (material.id)}
    function create_each_block_1$4(key_1, ctx) {
    	var li, a, t0_value = ctx.material.title + "", t0, a_href_value, t1, t2_value = ctx.material.type + "", t2, t3, t4, current;

    	var removematerialbutton = new RemoveMaterialButton$1({
    		props: { materialId: ctx.material.id },
    		$$inline: true
    	});

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			li = element("li");
    			a = element("a");
    			t0 = text(t0_value);
    			t1 = text("\n           - ");
    			t2 = text(t2_value);
    			t3 = space();
    			removematerialbutton.$$.fragment.c();
    			t4 = space();
    			attr(a, "href", a_href_value = "#/material/" + ctx.material.id);
    			add_location(a, file$1c, 83, 10, 2176);
    			add_location(li, file$1c, 82, 8, 2161);
    			this.first = li;
    		},

    		m: function mount(target, anchor) {
    			insert(target, li, anchor);
    			append(li, a);
    			append(a, t0);
    			append(li, t1);
    			append(li, t2);
    			append(li, t3);
    			mount_component(removematerialbutton, li, null);
    			append(li, t4);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if ((!current || changed.$lesson) && t0_value !== (t0_value = ctx.material.title + "")) {
    				set_data(t0, t0_value);
    			}

    			if ((!current || changed.$lesson) && a_href_value !== (a_href_value = "#/material/" + ctx.material.id)) {
    				attr(a, "href", a_href_value);
    			}

    			if ((!current || changed.$lesson) && t2_value !== (t2_value = ctx.material.type + "")) {
    				set_data(t2, t2_value);
    			}

    			var removematerialbutton_changes = {};
    			if (changed.$lesson) removematerialbutton_changes.materialId = ctx.material.id;
    			removematerialbutton.$set(removematerialbutton_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(removematerialbutton.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(removematerialbutton.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(li);
    			}

    			destroy_component(removematerialbutton);
    		}
    	};
    }

    // (96:4) {#if $lesson.words && $lesson.words.length > 0}
    function create_if_block_1$o(ctx) {
    	var ul, each_blocks = [], each_1_lookup = new Map(), current;

    	var each_value = ctx.$lesson.words;

    	const get_key = ctx => ctx.word.id;

    	for (var i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$q(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$q(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			ul = element("ul");

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();
    			attr(ul, "class", "words-list svelte-14e6l9j");
    			add_location(ul, file$1c, 96, 4, 2551);
    		},

    		m: function mount(target, anchor) {
    			insert(target, ul, anchor);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(ul, null);

    			current = true;
    		},

    		p: function update(changed, ctx) {
    			const each_value = ctx.$lesson.words;

    			group_outros();
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$q, null, get_each_context$q);
    			check_outros();
    		},

    		i: function intro(local) {
    			if (current) return;
    			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

    			current = true;
    		},

    		o: function outro(local) {
    			for (i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(ul);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d();
    		}
    	};
    }

    // (102:10) {#if word.chinese}
    function create_if_block_2$c(ctx) {
    	var t0, t1_value = ctx.word.chinese + "", t1, t2;

    	return {
    		c: function create() {
    			t0 = text("(");
    			t1 = text(t1_value);
    			t2 = text(")");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t0, anchor);
    			insert(target, t1, anchor);
    			insert(target, t2, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.$lesson) && t1_value !== (t1_value = ctx.word.chinese + "")) {
    				set_data(t1, t1_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t0);
    				detach(t1);
    				detach(t2);
    			}
    		}
    	};
    }

    // (98:6) {#each $lesson.words as word (word.id)}
    function create_each_block$q(key_1, ctx) {
    	var li, a, t0_value = ctx.word.english + "", t0, t1, a_href_value, t2, t3, current;

    	var if_block = (ctx.word.chinese) && create_if_block_2$c(ctx);

    	var removewordbutton = new RemoveWordButton$1({
    		props: { wordId: ctx.word.id },
    		$$inline: true
    	});

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			li = element("li");
    			a = element("a");
    			t0 = text(t0_value);
    			t1 = space();
    			if (if_block) if_block.c();
    			t2 = space();
    			removewordbutton.$$.fragment.c();
    			t3 = space();
    			attr(a, "href", a_href_value = "#/word/" + ctx.word.id);
    			add_location(a, file$1c, 99, 8, 2640);
    			add_location(li, file$1c, 98, 6, 2627);
    			this.first = li;
    		},

    		m: function mount(target, anchor) {
    			insert(target, li, anchor);
    			append(li, a);
    			append(a, t0);
    			append(a, t1);
    			if (if_block) if_block.m(a, null);
    			append(li, t2);
    			mount_component(removewordbutton, li, null);
    			append(li, t3);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if ((!current || changed.$lesson) && t0_value !== (t0_value = ctx.word.english + "")) {
    				set_data(t0, t0_value);
    			}

    			if (ctx.word.chinese) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_2$c(ctx);
    					if_block.c();
    					if_block.m(a, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if ((!current || changed.$lesson) && a_href_value !== (a_href_value = "#/word/" + ctx.word.id)) {
    				attr(a, "href", a_href_value);
    			}

    			var removewordbutton_changes = {};
    			if (changed.$lesson) removewordbutton_changes.wordId = ctx.word.id;
    			removewordbutton.$set(removewordbutton_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(removewordbutton.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(removewordbutton.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(li);
    			}

    			if (if_block) if_block.d();

    			destroy_component(removewordbutton);
    		}
    	};
    }

    function create_fragment$1j(ctx) {
    	var t0, t1, current_block_type_index, if_block1, if_block1_anchor, current;

    	var if_block0 = (ctx.errors) && create_if_block_5$2(ctx);

    	var if_block_creators = [
    		create_if_block$L,
    		create_if_block_4$2
    	];

    	var if_blocks = [];

    	function select_block_type(changed, ctx) {
    		if (ctx.$lesson && ctx.$lesson.id === ctx.params.id) return 0;
    		if (!ctx.errors) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(null, ctx))) {
    		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	return {
    		c: function create() {
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    			document.title = "Lesson Details";
    		},

    		l: function claim(nodes) {
    			throw new Error_1$m("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t0, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert(target, t1, anchor);
    			if (~current_block_type_index) if_blocks[current_block_type_index].m(target, anchor);
    			insert(target, if_block1_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.errors) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    					transition_in(if_block0, 1);
    				} else {
    					if_block0 = create_if_block_5$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t1.parentNode, t1);
    				}
    			} else if (if_block0) {
    				group_outros();
    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});
    				check_outros();
    			}

    			var previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(changed, ctx);
    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) if_blocks[current_block_type_index].p(changed, ctx);
    			} else {
    				if (if_block1) {
    					group_outros();
    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});
    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block1 = if_blocks[current_block_type_index];
    					if (!if_block1) {
    						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block1.c();
    					}
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				} else {
    					if_block1 = null;
    				}
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t0);
    			}

    			if (if_block0) if_block0.d(detaching);

    			if (detaching) {
    				detach(t1);
    			}

    			if (~current_block_type_index) if_blocks[current_block_type_index].d(detaching);

    			if (detaching) {
    				detach(if_block1_anchor);
    			}
    		}
    	};
    }

    function instance$1i($$self, $$props, $$invalidate) {
    	let $lesson;

    	validate_store(lesson, 'lesson');
    	component_subscribe($$self, lesson, $$value => { $lesson = $$value; $$invalidate('$lesson', $lesson); });

    	

      let { params = {} } = $$props;
      let errors = '';
      let showDelete = false;

      onMount(async () => {
        if (!$lesson || $lesson.id !== params.id) {
          try {
            await lesson.get(params.id);
          } catch (error) {
            $$invalidate('errors', errors = error);
            notifications.add({ text: 'Could not fetch lesson from the server', type: 'danger' });
          }
        }
      });

    	const writable_props = ['params'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Lesson> was created with unknown prop '${key}'`);
    	});

    	function click_handler() { showDelete = true; $$invalidate('showDelete', showDelete); }

    	function deleteitem_open_binding(value) {
    		showDelete = value;
    		$$invalidate('showDelete', showDelete);
    	}

    	$$self.$set = $$props => {
    		if ('params' in $$props) $$invalidate('params', params = $$props.params);
    	};

    	return {
    		params,
    		errors,
    		showDelete,
    		$lesson,
    		click_handler,
    		deleteitem_open_binding
    	};
    }

    class Lesson extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1i, create_fragment$1j, safe_not_equal, ["params"]);
    	}

    	get params() {
    		throw new Error_1$m("<Lesson>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error_1$m("<Lesson>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/lessons/LessonForm.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$n } = globals;

    const file$1d = "admin/src/components/lessons/LessonForm.svelte";

    function create_fragment$1k(ctx) {
    	var form_1, t0, div0, updating_value, t1, p, t2, strong, t4, t5, div1, label0, t7, textarea0, t8, div2, label1, t10, textarea1, t11, div3, label2, t13, textarea2, t14, div4, label3, t16, textarea3, t17, div5, button, t19, input1, current, dispose;

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	function input0_value_binding(value) {
    		ctx.input0_value_binding.call(null, value);
    		updating_value = true;
    		add_flush_callback(() => updating_value = false);
    	}

    	let input0_props = {
    		label: "Name",
    		placeholder: "i.e. 'My Body part 3'",
    		required: true
    	};
    	if (ctx.name !== void 0) {
    		input0_props.value = ctx.name;
    	}
    	var input0 = new Input({ props: input0_props, $$inline: true });

    	binding_callbacks.push(() => bind(input0, 'value', input0_value_binding));

    	return {
    		c: function create() {
    			form_1 = element("form");
    			error.$$.fragment.c();
    			t0 = space();
    			div0 = element("div");
    			input0.$$.fragment.c();
    			t1 = space();
    			p = element("p");
    			t2 = text("To make report writing easier write the summary in ");
    			strong = element("strong");
    			strong.textContent = "past tense";
    			t4 = text(".");
    			t5 = space();
    			div1 = element("div");
    			label0 = element("label");
    			label0.textContent = "Summary in English";
    			t7 = space();
    			textarea0 = element("textarea");
    			t8 = space();
    			div2 = element("div");
    			label1 = element("label");
    			label1.textContent = "Homework in English";
    			t10 = space();
    			textarea1 = element("textarea");
    			t11 = space();
    			div3 = element("div");
    			label2 = element("label");
    			label2.textContent = "Summary in Chinese";
    			t13 = space();
    			textarea2 = element("textarea");
    			t14 = space();
    			div4 = element("div");
    			label3 = element("label");
    			label3.textContent = "Homework in Chinese";
    			t16 = space();
    			textarea3 = element("textarea");
    			t17 = space();
    			div5 = element("div");
    			button = element("button");
    			button.textContent = "Save\n      lesson";
    			t19 = space();
    			input1 = element("input");
    			attr(div0, "class", "field svelte-14t3m6a");
    			add_location(div0, file$1d, 49, 2, 1065);
    			add_location(strong, file$1d, 53, 56, 1241);
    			add_location(p, file$1d, 53, 2, 1187);
    			attr(label0, "class", "label");
    			add_location(label0, file$1d, 55, 4, 1300);
    			attr(textarea0, "class", "textarea is-primary");
    			add_location(textarea0, file$1d, 56, 4, 1352);
    			attr(div1, "class", "field svelte-14t3m6a");
    			add_location(div1, file$1d, 54, 2, 1276);
    			attr(label1, "class", "label");
    			add_location(label1, file$1d, 60, 4, 1461);
    			attr(textarea1, "class", "textarea is-primary");
    			add_location(textarea1, file$1d, 61, 4, 1514);
    			attr(div2, "class", "field svelte-14t3m6a");
    			add_location(div2, file$1d, 59, 2, 1437);
    			attr(label2, "class", "label");
    			add_location(label2, file$1d, 65, 4, 1624);
    			attr(textarea2, "class", "textarea is-info");
    			add_location(textarea2, file$1d, 66, 4, 1676);
    			attr(div3, "class", "field svelte-14t3m6a");
    			add_location(div3, file$1d, 64, 2, 1600);
    			attr(label3, "class", "label");
    			add_location(label3, file$1d, 70, 4, 1782);
    			attr(textarea3, "class", "textarea is-info");
    			add_location(textarea3, file$1d, 71, 4, 1835);
    			attr(div4, "class", "field svelte-14t3m6a");
    			add_location(div4, file$1d, 69, 2, 1758);
    			attr(button, "type", "submit");
    			attr(button, "class", "button is-primary");
    			toggle_class(button, "is-loading", ctx.loading);
    			add_location(button, file$1d, 76, 4, 1945);
    			attr(input1, "type", "reset");
    			attr(input1, "class", "button");
    			input1.value = "Cancel";
    			add_location(input1, file$1d, 78, 4, 2074);
    			attr(div5, "class", "buttons svelte-14t3m6a");
    			add_location(div5, file$1d, 75, 2, 1919);
    			form_1.noValidate = true;
    			add_location(form_1, file$1d, 47, 0, 958);

    			dispose = [
    				listen(textarea0, "input", ctx.textarea0_input_handler),
    				listen(textarea1, "input", ctx.textarea1_input_handler),
    				listen(textarea2, "input", ctx.textarea2_input_handler),
    				listen(textarea3, "input", ctx.textarea3_input_handler),
    				listen(form_1, "submit", prevent_default(ctx.handleSubmit)),
    				listen(form_1, "reset", ctx.reset_handler)
    			];
    		},

    		l: function claim(nodes) {
    			throw new Error_1$n("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, form_1, anchor);
    			mount_component(error, form_1, null);
    			append(form_1, t0);
    			append(form_1, div0);
    			mount_component(input0, div0, null);
    			append(form_1, t1);
    			append(form_1, p);
    			append(p, t2);
    			append(p, strong);
    			append(p, t4);
    			append(form_1, t5);
    			append(form_1, div1);
    			append(div1, label0);
    			append(div1, t7);
    			append(div1, textarea0);

    			set_input_value(textarea0, ctx.summaryEN);

    			append(form_1, t8);
    			append(form_1, div2);
    			append(div2, label1);
    			append(div2, t10);
    			append(div2, textarea1);

    			set_input_value(textarea1, ctx.homeworkEN);

    			append(form_1, t11);
    			append(form_1, div3);
    			append(div3, label2);
    			append(div3, t13);
    			append(div3, textarea2);

    			set_input_value(textarea2, ctx.summaryZH);

    			append(form_1, t14);
    			append(form_1, div4);
    			append(div4, label3);
    			append(div4, t16);
    			append(div4, textarea3);

    			set_input_value(textarea3, ctx.homeworkZH);

    			append(form_1, t17);
    			append(form_1, div5);
    			append(div5, button);
    			ctx.button_binding(button);
    			append(div5, t19);
    			append(div5, input1);
    			ctx.form_1_binding(form_1);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);

    			var input0_changes = {};
    			if (!updating_value && changed.name) {
    				input0_changes.value = ctx.name;
    			}
    			input0.$set(input0_changes);

    			if (changed.summaryEN) set_input_value(textarea0, ctx.summaryEN);
    			if (changed.homeworkEN) set_input_value(textarea1, ctx.homeworkEN);
    			if (changed.summaryZH) set_input_value(textarea2, ctx.summaryZH);
    			if (changed.homeworkZH) set_input_value(textarea3, ctx.homeworkZH);

    			if (changed.loading) {
    				toggle_class(button, "is-loading", ctx.loading);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);

    			transition_in(input0.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			transition_out(input0.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(form_1);
    			}

    			destroy_component(error);

    			destroy_component(input0);

    			ctx.button_binding(null);
    			ctx.form_1_binding(null);
    			run_all(dispose);
    		}
    	};
    }

    function instance$1j($$self, $$props, $$invalidate) {
    	

      let saveButton;
      let form;

      let { errors, loading, name = '', summaryEN = '', homeworkEN = '', homeworkZH = '', summaryZH = '', id = '', tags = [] } = $$props;

      const dispatch = createEventDispatcher();

      const handleSubmit = () => {
        const isValid = form.checkValidity();
        if (!isValid) {
          notifications.add({
            text: 'Please fix form errors first.',
            type: 'danger'
          });
          return
        }
        dispatch('submit', { name, summaryEN, summaryZH, homeworkEN, homeworkZH });
      };

    	const writable_props = ['errors', 'loading', 'name', 'summaryEN', 'homeworkEN', 'homeworkZH', 'summaryZH', 'id', 'tags'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<LessonForm> was created with unknown prop '${key}'`);
    	});

    	function reset_handler(event) {
    		bubble($$self, event);
    	}

    	function input0_value_binding(value) {
    		name = value;
    		$$invalidate('name', name);
    	}

    	function textarea0_input_handler() {
    		summaryEN = this.value;
    		$$invalidate('summaryEN', summaryEN);
    	}

    	function textarea1_input_handler() {
    		homeworkEN = this.value;
    		$$invalidate('homeworkEN', homeworkEN);
    	}

    	function textarea2_input_handler() {
    		summaryZH = this.value;
    		$$invalidate('summaryZH', summaryZH);
    	}

    	function textarea3_input_handler() {
    		homeworkZH = this.value;
    		$$invalidate('homeworkZH', homeworkZH);
    	}

    	function button_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('saveButton', saveButton = $$value);
    		});
    	}

    	function form_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('form', form = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ('errors' in $$props) $$invalidate('errors', errors = $$props.errors);
    		if ('loading' in $$props) $$invalidate('loading', loading = $$props.loading);
    		if ('name' in $$props) $$invalidate('name', name = $$props.name);
    		if ('summaryEN' in $$props) $$invalidate('summaryEN', summaryEN = $$props.summaryEN);
    		if ('homeworkEN' in $$props) $$invalidate('homeworkEN', homeworkEN = $$props.homeworkEN);
    		if ('homeworkZH' in $$props) $$invalidate('homeworkZH', homeworkZH = $$props.homeworkZH);
    		if ('summaryZH' in $$props) $$invalidate('summaryZH', summaryZH = $$props.summaryZH);
    		if ('id' in $$props) $$invalidate('id', id = $$props.id);
    		if ('tags' in $$props) $$invalidate('tags', tags = $$props.tags);
    	};

    	$$self.$$.update = ($$dirty = { saveButton: 1, loading: 1 }) => {
    		if ($$dirty.saveButton || $$dirty.loading) { if (saveButton) { saveButton.disabled = loading; $$invalidate('saveButton', saveButton), $$invalidate('loading', loading); } }
    	};

    	return {
    		saveButton,
    		form,
    		errors,
    		loading,
    		name,
    		summaryEN,
    		homeworkEN,
    		homeworkZH,
    		summaryZH,
    		id,
    		tags,
    		handleSubmit,
    		reset_handler,
    		input0_value_binding,
    		textarea0_input_handler,
    		textarea1_input_handler,
    		textarea2_input_handler,
    		textarea3_input_handler,
    		button_binding,
    		form_1_binding
    	};
    }

    class LessonForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1j, create_fragment$1k, safe_not_equal, ["errors", "loading", "name", "summaryEN", "homeworkEN", "homeworkZH", "summaryZH", "id", "tags"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.errors === undefined && !('errors' in props)) {
    			console.warn("<LessonForm> was created without expected prop 'errors'");
    		}
    		if (ctx.loading === undefined && !('loading' in props)) {
    			console.warn("<LessonForm> was created without expected prop 'loading'");
    		}
    	}

    	get errors() {
    		throw new Error_1$n("<LessonForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set errors(value) {
    		throw new Error_1$n("<LessonForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loading() {
    		throw new Error_1$n("<LessonForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loading(value) {
    		throw new Error_1$n("<LessonForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error_1$n("<LessonForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error_1$n("<LessonForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get summaryEN() {
    		throw new Error_1$n("<LessonForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set summaryEN(value) {
    		throw new Error_1$n("<LessonForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get homeworkEN() {
    		throw new Error_1$n("<LessonForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set homeworkEN(value) {
    		throw new Error_1$n("<LessonForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get homeworkZH() {
    		throw new Error_1$n("<LessonForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set homeworkZH(value) {
    		throw new Error_1$n("<LessonForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get summaryZH() {
    		throw new Error_1$n("<LessonForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set summaryZH(value) {
    		throw new Error_1$n("<LessonForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error_1$n("<LessonForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error_1$n("<LessonForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tags() {
    		throw new Error_1$n("<LessonForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tags(value) {
    		throw new Error_1$n("<LessonForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/lessons/EditLesson.svelte generated by Svelte v3.9.2 */
    const { console: console_1$c } = globals;

    const file$1e = "admin/src/components/lessons/EditLesson.svelte";

    // (56:0) {:else}
    function create_else_block$j(ctx) {
    	var current;

    	var loading_1 = new Loading({
    		props: { what: "lesson" },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			loading_1.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(loading_1, target, anchor);
    			current = true;
    		},

    		p: noop,

    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading_1.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(loading_1.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(loading_1, detaching);
    		}
    	};
    }

    // (54:0) {#if lesson}
    function create_if_block$M(ctx) {
    	var current;

    	var lessonform_spread_levels = [
    		{ errors: ctx.errors },
    		{ loading: ctx.loading },
    		ctx.$lesson,
    		{ id: ctx.params.id }
    	];

    	let lessonform_props = {};
    	for (var i = 0; i < lessonform_spread_levels.length; i += 1) {
    		lessonform_props = assign(lessonform_props, lessonform_spread_levels[i]);
    	}
    	var lessonform = new LessonForm({ props: lessonform_props, $$inline: true });
    	lessonform.$on("reset", ctx.reset);
    	lessonform.$on("submit", ctx.save);

    	return {
    		c: function create() {
    			lessonform.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(lessonform, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var lessonform_changes = (changed.errors || changed.loading || changed.$lesson || changed.params) ? get_spread_update(lessonform_spread_levels, [
    									(changed.errors) && { errors: ctx.errors },
    			(changed.loading) && { loading: ctx.loading },
    			(changed.$lesson) && ctx.$lesson,
    			(changed.params) && { id: ctx.params.id }
    								]) : {};
    			lessonform.$set(lessonform_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(lessonform.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(lessonform.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(lessonform, detaching);
    		}
    	};
    }

    function create_fragment$1l(ctx) {
    	var t0, h1, t2, current_block_type_index, if_block, if_block_anchor, current;

    	var if_block_creators = [
    		create_if_block$M,
    		create_else_block$j
    	];

    	var if_blocks = [];

    	function select_block_type(changed, ctx) {
    		if (lesson) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type();
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	return {
    		c: function create() {
    			t0 = space();
    			h1 = element("h1");
    			h1.textContent = "Edit a Lesson";
    			t2 = space();
    			if_block.c();
    			if_block_anchor = empty();
    			document.title = "New Lesson";
    			attr(h1, "class", "title");
    			add_location(h1, file$1e, 51, 0, 1213);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t0, anchor);
    			insert(target, h1, anchor);
    			insert(target, t2, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type();
    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(changed, ctx);
    			} else {
    				group_outros();
    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});
    				check_outros();

    				if_block = if_blocks[current_block_type_index];
    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}
    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t0);
    				detach(h1);
    				detach(t2);
    			}

    			if_blocks[current_block_type_index].d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function instance$1k($$self, $$props, $$invalidate) {
    	let $lesson;

    	validate_store(lesson, 'lesson');
    	component_subscribe($$self, lesson, $$value => { $lesson = $$value; $$invalidate('$lesson', $lesson); });

    	

      let loading = false;
      let errors = '';
      let { params = {} } = $$props;

      onMount(async () => {
        if (!$lesson || $lesson.id === params.id) {
          try {
            await lesson.get(params.id);
          } catch (error) {
            $$invalidate('errors', errors = error);
            notifications.add({ text: 'Could not fetch lesson from the server', type: 'danger' });
          }
        }
      });

      const reset = () => {
        $$invalidate('errors', errors = '');
        push(`/lesson/${params.id}`);
      };

      const save = async ({ detail }) => {
        console.log(detail);
        $$invalidate('loading', loading = true);
        try {
          await lessons.patch({ input: detail, id: params.id });
          notifications.add({ text: `Saved edits to lesson '${detail.name}'`, type: 'success' });
          reset();
        } catch (error) {
          $$invalidate('errors', errors = error);
          notifications.add({
            text: 'Could not save lesson.',
            type: 'danger'
          });
        } finally {
          $$invalidate('loading', loading = false);
        }
      };

    	const writable_props = ['params'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console_1$c.warn(`<EditLesson> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('params' in $$props) $$invalidate('params', params = $$props.params);
    	};

    	return {
    		loading,
    		errors,
    		params,
    		reset,
    		save,
    		$lesson
    	};
    }

    class EditLesson extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1k, create_fragment$1l, safe_not_equal, ["params"]);
    	}

    	get params() {
    		throw new Error("<EditLesson>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<EditLesson>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/lessons/CreateLesson.svelte generated by Svelte v3.9.2 */

    const file$1f = "admin/src/components/lessons/CreateLesson.svelte";

    function create_fragment$1m(ctx) {
    	var t0, h1, t2, current;

    	var lessonform = new LessonForm({
    		props: {
    		errors: ctx.errors,
    		loading: ctx.loading
    	},
    		$$inline: true
    	});
    	lessonform.$on("reset", ctx.reset);
    	lessonform.$on("submit", ctx.save);

    	return {
    		c: function create() {
    			t0 = space();
    			h1 = element("h1");
    			h1.textContent = "New Lesson";
    			t2 = space();
    			lessonform.$$.fragment.c();
    			document.title = "New Lesson";
    			attr(h1, "class", "title");
    			add_location(h1, file$1f, 36, 0, 760);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t0, anchor);
    			insert(target, h1, anchor);
    			insert(target, t2, anchor);
    			mount_component(lessonform, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var lessonform_changes = {};
    			if (changed.errors) lessonform_changes.errors = ctx.errors;
    			if (changed.loading) lessonform_changes.loading = ctx.loading;
    			lessonform.$set(lessonform_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(lessonform.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(lessonform.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t0);
    				detach(h1);
    				detach(t2);
    			}

    			destroy_component(lessonform, detaching);
    		}
    	};
    }

    function instance$1l($$self, $$props, $$invalidate) {
    	

      let loading = false;
      let errors = '';

      const reset = () => {
        $$invalidate('errors', errors = '');
        push('/lessons');
      };

      const save = async ({ detail }) => {
        $$invalidate('loading', loading = true);
        try {
          await lessons.create(detail);
          notifications.add({ text: `Saved new lesson '${detail.name}'`, type: 'success' });
          reset();
        } catch (error) {
          $$invalidate('errors', errors = error);
          notifications.add({
            text: 'Could not save new lesson.',
            type: 'danger'
          });
        } finally {
          $$invalidate('loading', loading = false);
        }
      };

    	return { loading, errors, reset, save };
    }

    class CreateLesson extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1l, create_fragment$1m, safe_not_equal, []);
    	}
    }

    /* admin/src/components/materials/MaterialsList.svelte generated by Svelte v3.9.2 */

    const file$1g = "admin/src/components/materials/MaterialsList.svelte";

    function get_each_context_1$5(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.tag = list[i];
    	return child_ctx;
    }

    function get_each_context$r(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.material = list[i];
    	return child_ctx;
    }

    // (22:2) {#if materials}
    function create_if_block$N(ctx) {
    	var p, t0_value = ctx.materials.length + "", t0, t1, t2, each_blocks = [], each_1_lookup = new Map(), each_1_anchor;

    	var each_value = ctx.materials;

    	const get_key = ctx => ctx.material.id;

    	for (var i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$r(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$r(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = text(" matching materials found:");
    			t2 = space();

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();

    			each_1_anchor = empty();
    			add_location(p, file$1g, 22, 4, 258);
    		},

    		m: function mount(target, anchor) {
    			insert(target, p, anchor);
    			append(p, t0);
    			append(p, t1);
    			insert(target, t2, anchor);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(target, anchor);

    			insert(target, each_1_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.materials) && t0_value !== (t0_value = ctx.materials.length + "")) {
    				set_data(t0, t0_value);
    			}

    			const each_value = ctx.materials;
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$r, each_1_anchor, get_each_context$r);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(p);
    				detach(t2);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d(detaching);

    			if (detaching) {
    				detach(each_1_anchor);
    			}
    		}
    	};
    }

    // (27:8) {#if material.tags && material.tags.length > 0}
    function create_if_block_1$p(ctx) {
    	var div, each_blocks = [], each_1_lookup = new Map();

    	var each_value_1 = ctx.material.tags;

    	const get_key = ctx => ctx.tag.id;

    	for (var i = 0; i < each_value_1.length; i += 1) {
    		let child_ctx = get_each_context_1$5(ctx, each_value_1, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_1$5(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			div = element("div");

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();
    			attr(div, "class", "tags");
    			add_location(div, file$1g, 27, 8, 539);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(div, null);
    		},

    		p: function update(changed, ctx) {
    			const each_value_1 = ctx.material.tags;
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value_1, each_1_lookup, div, destroy_block, create_each_block_1$5, null, get_each_context_1$5);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d();
    		}
    	};
    }

    // (29:10) {#each material.tags as tag (tag.id)}
    function create_each_block_1$5(key_1, ctx) {
    	var span, t_value = ctx.tag.name + "", t;

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr(span, "class", "tag is-dark");
    			add_location(span, file$1g, 29, 12, 618);
    			this.first = span;
    		},

    		m: function mount(target, anchor) {
    			insert(target, span, anchor);
    			append(span, t);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.materials) && t_value !== (t_value = ctx.tag.name + "")) {
    				set_data(t, t_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(span);
    			}
    		}
    	};
    }

    // (24:4) {#each materials as material (material.id)}
    function create_each_block$r(key_1, ctx) {
    	var li, a, t0_value = ctx.material.title + "", t0, a_href_value, t1, span, t2_value = ctx.material.type + "", t2, t3, t4;

    	var if_block = (ctx.material.tags && ctx.material.tags.length > 0) && create_if_block_1$p(ctx);

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			li = element("li");
    			a = element("a");
    			t0 = text(t0_value);
    			t1 = space();
    			span = element("span");
    			t2 = text(t2_value);
    			t3 = space();
    			if (if_block) if_block.c();
    			t4 = space();
    			attr(a, "href", a_href_value = "#/material/" + ctx.material.id);
    			add_location(a, file$1g, 25, 8, 377);
    			attr(span, "class", "type svelte-wyy114");
    			add_location(span, file$1g, 25, 64, 433);
    			attr(li, "class", "svelte-wyy114");
    			add_location(li, file$1g, 24, 6, 364);
    			this.first = li;
    		},

    		m: function mount(target, anchor) {
    			insert(target, li, anchor);
    			append(li, a);
    			append(a, t0);
    			append(li, t1);
    			append(li, span);
    			append(span, t2);
    			append(li, t3);
    			if (if_block) if_block.m(li, null);
    			append(li, t4);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.materials) && t0_value !== (t0_value = ctx.material.title + "")) {
    				set_data(t0, t0_value);
    			}

    			if ((changed.materials) && a_href_value !== (a_href_value = "#/material/" + ctx.material.id)) {
    				attr(a, "href", a_href_value);
    			}

    			if ((changed.materials) && t2_value !== (t2_value = ctx.material.type + "")) {
    				set_data(t2, t2_value);
    			}

    			if (ctx.material.tags && ctx.material.tags.length > 0) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_1$p(ctx);
    					if_block.c();
    					if_block.m(li, t4);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(li);
    			}

    			if (if_block) if_block.d();
    		}
    	};
    }

    function create_fragment$1n(ctx) {
    	var section;

    	var if_block = (ctx.materials) && create_if_block$N(ctx);

    	return {
    		c: function create() {
    			section = element("section");
    			if (if_block) if_block.c();
    			attr(section, "class", "materials-list svelte-wyy114");
    			add_location(section, file$1g, 20, 0, 203);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, section, anchor);
    			if (if_block) if_block.m(section, null);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.materials) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$N(ctx);
    					if_block.c();
    					if_block.m(section, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(section);
    			}

    			if (if_block) if_block.d();
    		}
    	};
    }

    function instance$1m($$self, $$props, $$invalidate) {
    	let { materials } = $$props;

    	const writable_props = ['materials'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<MaterialsList> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('materials' in $$props) $$invalidate('materials', materials = $$props.materials);
    	};

    	return { materials };
    }

    class MaterialsList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1m, create_fragment$1n, safe_not_equal, ["materials"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.materials === undefined && !('materials' in props)) {
    			console.warn("<MaterialsList> was created without expected prop 'materials'");
    		}
    	}

    	get materials() {
    		throw new Error("<MaterialsList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set materials(value) {
    		throw new Error("<MaterialsList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/materials/MaterialForm.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$o } = globals;

    const file$1h = "admin/src/components/materials/MaterialForm.svelte";

    // (41:30) {:else}
    function create_else_block$k(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Create");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (41:18) {#if id}
    function create_if_block$O(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Edit");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    function create_fragment$1o(ctx) {
    	var h1, t0, t1, form_1, t2, updating_value, t3, updating_value_1, t4, updating_value_2, t5, updating_value_3, t6, textarea, t7, div, button, t9, input4, current, dispose;

    	function select_block_type(changed, ctx) {
    		if (ctx.id) return create_if_block$O;
    		return create_else_block$k;
    	}

    	var current_block_type = select_block_type(null, ctx);
    	var if_block = current_block_type(ctx);

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	function input0_value_binding(value) {
    		ctx.input0_value_binding.call(null, value);
    		updating_value = true;
    		add_flush_callback(() => updating_value = false);
    	}

    	let input0_props = {
    		label: "Title",
    		placeholder: "e.g. 'Song: Teacher on the bookcase'",
    		required: true
    	};
    	if (ctx.title !== void 0) {
    		input0_props.value = ctx.title;
    	}
    	var input0 = new Input({ props: input0_props, $$inline: true });

    	binding_callbacks.push(() => bind(input0, 'value', input0_value_binding));

    	function input1_value_binding(value_1) {
    		ctx.input1_value_binding.call(null, value_1);
    		updating_value_1 = true;
    		add_flush_callback(() => updating_value_1 = false);
    	}

    	let input1_props = { label: "Complete URL", required: true };
    	if (ctx.url !== void 0) {
    		input1_props.value = ctx.url;
    	}
    	var input1 = new Input({ props: input1_props, $$inline: true });

    	binding_callbacks.push(() => bind(input1, 'value', input1_value_binding));

    	function input2_value_binding(value_2) {
    		ctx.input2_value_binding.call(null, value_2);
    		updating_value_2 = true;
    		add_flush_callback(() => updating_value_2 = false);
    	}

    	let input2_props = {
    		label: "Filetype",
    		placeholder: "e.g. 'audio/mp3'",
    		required: true
    	};
    	if (ctx.type !== void 0) {
    		input2_props.value = ctx.type;
    	}
    	var input2 = new Input({ props: input2_props, $$inline: true });

    	binding_callbacks.push(() => bind(input2, 'value', input2_value_binding));

    	function input3_value_binding(value_3) {
    		ctx.input3_value_binding.call(null, value_3);
    		updating_value_3 = true;
    		add_flush_callback(() => updating_value_3 = false);
    	}

    	let input3_props = { label: "Url of related Image" };
    	if (ctx.imageUrl !== void 0) {
    		input3_props.value = ctx.imageUrl;
    	}
    	var input3 = new Input({ props: input3_props, $$inline: true });

    	binding_callbacks.push(() => bind(input3, 'value', input3_value_binding));

    	return {
    		c: function create() {
    			h1 = element("h1");
    			if_block.c();
    			t0 = text(" material");
    			t1 = space();
    			form_1 = element("form");
    			error.$$.fragment.c();
    			t2 = space();
    			input0.$$.fragment.c();
    			t3 = space();
    			input1.$$.fragment.c();
    			t4 = space();
    			input2.$$.fragment.c();
    			t5 = space();
    			input3.$$.fragment.c();
    			t6 = space();
    			textarea = element("textarea");
    			t7 = space();
    			div = element("div");
    			button = element("button");
    			button.textContent = "Save material";
    			t9 = space();
    			input4 = element("input");
    			attr(h1, "class", "title");
    			add_location(h1, file$1h, 40, 0, 848);
    			attr(textarea, "class", "textarea");
    			add_location(textarea, file$1h, 50, 6, 1365);
    			attr(button, "type", "submit");
    			attr(button, "class", "button is-primary");
    			toggle_class(button, "is-loading", ctx.loading);
    			add_location(button, file$1h, 53, 8, 1460);
    			attr(input4, "type", "reset");
    			attr(input4, "class", "button");
    			input4.value = "Cancel";
    			add_location(input4, file$1h, 54, 8, 1589);
    			attr(div, "class", "buttons svelte-1nzkngr");
    			add_location(div, file$1h, 52, 6, 1430);
    			form_1.noValidate = true;
    			add_location(form_1, file$1h, 42, 4, 918);

    			dispose = [
    				listen(textarea, "input", ctx.textarea_input_handler),
    				listen(form_1, "submit", prevent_default(ctx.handleSubmit)),
    				listen(form_1, "reset", ctx.reset_handler)
    			];
    		},

    		l: function claim(nodes) {
    			throw new Error_1$o("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, h1, anchor);
    			if_block.m(h1, null);
    			append(h1, t0);
    			insert(target, t1, anchor);
    			insert(target, form_1, anchor);
    			mount_component(error, form_1, null);
    			append(form_1, t2);
    			mount_component(input0, form_1, null);
    			append(form_1, t3);
    			mount_component(input1, form_1, null);
    			append(form_1, t4);
    			mount_component(input2, form_1, null);
    			append(form_1, t5);
    			mount_component(input3, form_1, null);
    			append(form_1, t6);
    			append(form_1, textarea);

    			set_input_value(textarea, ctx.notes);

    			append(form_1, t7);
    			append(form_1, div);
    			append(div, button);
    			ctx.button_binding(button);
    			append(div, t9);
    			append(div, input4);
    			ctx.form_1_binding(form_1);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type !== (current_block_type = select_block_type(changed, ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);
    				if (if_block) {
    					if_block.c();
    					if_block.m(h1, t0);
    				}
    			}

    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);

    			var input0_changes = {};
    			if (!updating_value && changed.title) {
    				input0_changes.value = ctx.title;
    			}
    			input0.$set(input0_changes);

    			var input1_changes = {};
    			if (!updating_value_1 && changed.url) {
    				input1_changes.value = ctx.url;
    			}
    			input1.$set(input1_changes);

    			var input2_changes = {};
    			if (!updating_value_2 && changed.type) {
    				input2_changes.value = ctx.type;
    			}
    			input2.$set(input2_changes);

    			var input3_changes = {};
    			if (!updating_value_3 && changed.imageUrl) {
    				input3_changes.value = ctx.imageUrl;
    			}
    			input3.$set(input3_changes);

    			if (changed.notes) set_input_value(textarea, ctx.notes);

    			if (changed.loading) {
    				toggle_class(button, "is-loading", ctx.loading);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);

    			transition_in(input0.$$.fragment, local);

    			transition_in(input1.$$.fragment, local);

    			transition_in(input2.$$.fragment, local);

    			transition_in(input3.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			transition_out(input0.$$.fragment, local);
    			transition_out(input1.$$.fragment, local);
    			transition_out(input2.$$.fragment, local);
    			transition_out(input3.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h1);
    			}

    			if_block.d();

    			if (detaching) {
    				detach(t1);
    				detach(form_1);
    			}

    			destroy_component(error);

    			destroy_component(input0);

    			destroy_component(input1);

    			destroy_component(input2);

    			destroy_component(input3);

    			ctx.button_binding(null);
    			ctx.form_1_binding(null);
    			run_all(dispose);
    		}
    	};
    }

    function instance$1n($$self, $$props, $$invalidate) {
    	

      let { title = '', url = '', notes = '', type = '', id = '', imageUrl = '', errors, loading } = $$props;
      let saveButton;
      let form;

      const dispatch = createEventDispatcher();

      const handleSubmit = () => {
        const isValid = form.checkValidity();
        if (!isValid) {
          notifications.add({
            text: 'Please fix form errors first.',
            type: 'danger'
          });
          return
        }
        dispatch('submit', { title, url, notes, type, imageUrl });
      };

    	const writable_props = ['title', 'url', 'notes', 'type', 'id', 'imageUrl', 'errors', 'loading'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<MaterialForm> was created with unknown prop '${key}'`);
    	});

    	function reset_handler(event) {
    		bubble($$self, event);
    	}

    	function input0_value_binding(value) {
    		title = value;
    		$$invalidate('title', title);
    	}

    	function input1_value_binding(value_1) {
    		url = value_1;
    		$$invalidate('url', url);
    	}

    	function input2_value_binding(value_2) {
    		type = value_2;
    		$$invalidate('type', type);
    	}

    	function input3_value_binding(value_3) {
    		imageUrl = value_3;
    		$$invalidate('imageUrl', imageUrl);
    	}

    	function textarea_input_handler() {
    		notes = this.value;
    		$$invalidate('notes', notes);
    	}

    	function button_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('saveButton', saveButton = $$value);
    		});
    	}

    	function form_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('form', form = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ('title' in $$props) $$invalidate('title', title = $$props.title);
    		if ('url' in $$props) $$invalidate('url', url = $$props.url);
    		if ('notes' in $$props) $$invalidate('notes', notes = $$props.notes);
    		if ('type' in $$props) $$invalidate('type', type = $$props.type);
    		if ('id' in $$props) $$invalidate('id', id = $$props.id);
    		if ('imageUrl' in $$props) $$invalidate('imageUrl', imageUrl = $$props.imageUrl);
    		if ('errors' in $$props) $$invalidate('errors', errors = $$props.errors);
    		if ('loading' in $$props) $$invalidate('loading', loading = $$props.loading);
    	};

    	$$self.$$.update = ($$dirty = { saveButton: 1, loading: 1 }) => {
    		if ($$dirty.saveButton || $$dirty.loading) { if (saveButton) { saveButton.disabled = loading; $$invalidate('saveButton', saveButton), $$invalidate('loading', loading); } }
    	};

    	return {
    		title,
    		url,
    		notes,
    		type,
    		id,
    		imageUrl,
    		errors,
    		loading,
    		saveButton,
    		form,
    		handleSubmit,
    		reset_handler,
    		input0_value_binding,
    		input1_value_binding,
    		input2_value_binding,
    		input3_value_binding,
    		textarea_input_handler,
    		button_binding,
    		form_1_binding
    	};
    }

    class MaterialForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1n, create_fragment$1o, safe_not_equal, ["title", "url", "notes", "type", "id", "imageUrl", "errors", "loading"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.errors === undefined && !('errors' in props)) {
    			console.warn("<MaterialForm> was created without expected prop 'errors'");
    		}
    		if (ctx.loading === undefined && !('loading' in props)) {
    			console.warn("<MaterialForm> was created without expected prop 'loading'");
    		}
    	}

    	get title() {
    		throw new Error_1$o("<MaterialForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error_1$o("<MaterialForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get url() {
    		throw new Error_1$o("<MaterialForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set url(value) {
    		throw new Error_1$o("<MaterialForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get notes() {
    		throw new Error_1$o("<MaterialForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set notes(value) {
    		throw new Error_1$o("<MaterialForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get type() {
    		throw new Error_1$o("<MaterialForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set type(value) {
    		throw new Error_1$o("<MaterialForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error_1$o("<MaterialForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error_1$o("<MaterialForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get imageUrl() {
    		throw new Error_1$o("<MaterialForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set imageUrl(value) {
    		throw new Error_1$o("<MaterialForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get errors() {
    		throw new Error_1$o("<MaterialForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set errors(value) {
    		throw new Error_1$o("<MaterialForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loading() {
    		throw new Error_1$o("<MaterialForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loading(value) {
    		throw new Error_1$o("<MaterialForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/materials/CreateMaterial.svelte generated by Svelte v3.9.2 */

    const file$1i = "admin/src/components/materials/CreateMaterial.svelte";

    // (35:0) <Modal bind:open>
    function create_default_slot$h(ctx) {
    	var current;

    	var materialform = new MaterialForm({
    		props: {
    		errors: ctx.errors,
    		loading: ctx.loading
    	},
    		$$inline: true
    	});
    	materialform.$on("reset", ctx.reset);
    	materialform.$on("submit", ctx.save);

    	return {
    		c: function create() {
    			materialform.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(materialform, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var materialform_changes = {};
    			if (changed.errors) materialform_changes.errors = ctx.errors;
    			if (changed.loading) materialform_changes.loading = ctx.loading;
    			materialform.$set(materialform_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(materialform.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(materialform.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(materialform, detaching);
    		}
    	};
    }

    function create_fragment$1p(ctx) {
    	var button, i, t0, t1, updating_open, current, dispose;

    	function modal_open_binding(value) {
    		ctx.modal_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let modal_props = {
    		$$slots: { default: [create_default_slot$h] },
    		$$scope: { ctx }
    	};
    	if (ctx.open !== void 0) {
    		modal_props.open = ctx.open;
    	}
    	var modal = new Modal({ props: modal_props, $$inline: true });

    	binding_callbacks.push(() => bind(modal, 'open', modal_open_binding));

    	return {
    		c: function create() {
    			button = element("button");
    			i = element("i");
    			t0 = text("Add material");
    			t1 = space();
    			modal.$$.fragment.c();
    			attr(i, "class", "fas fa-plus");
    			add_location(i, file$1i, 33, 67, 792);
    			attr(button, "class", "button is-primary");
    			add_location(button, file$1i, 33, 0, 725);
    			dispose = listen(button, "click", ctx.click_handler);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);
    			append(button, i);
    			append(button, t0);
    			insert(target, t1, anchor);
    			mount_component(modal, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var modal_changes = {};
    			if (changed.$$scope || changed.errors || changed.loading) modal_changes.$$scope = { changed, ctx };
    			if (!updating_open && changed.open) {
    				modal_changes.open = ctx.open;
    			}
    			modal.$set(modal_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(button);
    				detach(t1);
    			}

    			destroy_component(modal, detaching);

    			dispose();
    		}
    	};
    }

    function instance$1o($$self, $$props, $$invalidate) {
    	

      let loading = false;
      let errors = '';
      let open = false;

      const reset = () => {
        $$invalidate('errors', errors = '');
        $$invalidate('open', open = false);
      };

      const save = async ({ detail }) => {
        $$invalidate('loading', loading = true);
        try {
          await materials.create(detail);
          notifications.add({ text: `Saved new material '${detail.title}'`, type: 'success' });
          reset();
        } catch (error) {
          $$invalidate('errors', errors = error);
          notifications.add({
            text: 'Could not save new material.',
            type: 'danger'
          });
        } finally {
          $$invalidate('loading', loading = false);
        }
      };

    	function click_handler() { open = true; $$invalidate('open', open); }

    	function modal_open_binding(value) {
    		open = value;
    		$$invalidate('open', open);
    	}

    	return {
    		loading,
    		errors,
    		open,
    		reset,
    		save,
    		click_handler,
    		modal_open_binding
    	};
    }

    class CreateMaterial extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1o, create_fragment$1p, safe_not_equal, []);
    	}
    }

    /* admin/src/components/materials/Materials.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$p } = globals;

    const file$1j = "admin/src/components/materials/Materials.svelte";

    // (36:18) 
    function create_if_block_1$q(ctx) {
    	var current;

    	var loading = new Loading({
    		props: { what: "materials" },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			loading.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},

    		p: noop,

    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};
    }

    // (34:0) {#if $materials}
    function create_if_block$P(ctx) {
    	var current;

    	var materialslist = new MaterialsList({
    		props: { materials: ctx.$materials },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			materialslist.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(materialslist, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var materialslist_changes = {};
    			if (changed.$materials) materialslist_changes.materials = ctx.$materials;
    			materialslist.$set(materialslist_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(materialslist.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(materialslist.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(materialslist, detaching);
    		}
    	};
    }

    function create_fragment$1q(ctx) {
    	var t0, h1, t2, t3, t4, t5, current_block_type_index, if_block, if_block_anchor, current;

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	var creatematerial = new CreateMaterial({ $$inline: true });

    	var filteritems = new FilterItems({
    		props: {
    		searchParams: "title",
    		store: materials
    	},
    		$$inline: true
    	});

    	var if_block_creators = [
    		create_if_block$P,
    		create_if_block_1$q
    	];

    	var if_blocks = [];

    	function select_block_type(changed, ctx) {
    		if (ctx.$materials) return 0;
    		if (!ctx.errors) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(null, ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	return {
    		c: function create() {
    			t0 = space();
    			h1 = element("h1");
    			h1.textContent = "Materials";
    			t2 = space();
    			error.$$.fragment.c();
    			t3 = space();
    			creatematerial.$$.fragment.c();
    			t4 = space();
    			filteritems.$$.fragment.c();
    			t5 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			document.title = "Materials";
    			attr(h1, "class", "title");
    			add_location(h1, file$1j, 25, 0, 664);
    		},

    		l: function claim(nodes) {
    			throw new Error_1$p("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t0, anchor);
    			insert(target, h1, anchor);
    			insert(target, t2, anchor);
    			mount_component(error, target, anchor);
    			insert(target, t3, anchor);
    			mount_component(creatematerial, target, anchor);
    			insert(target, t4, anchor);
    			mount_component(filteritems, target, anchor);
    			insert(target, t5, anchor);
    			if (~current_block_type_index) if_blocks[current_block_type_index].m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);

    			var filteritems_changes = {};
    			if (changed.materials) filteritems_changes.store = materials;
    			filteritems.$set(filteritems_changes);

    			var previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(changed, ctx);
    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) if_blocks[current_block_type_index].p(changed, ctx);
    			} else {
    				if (if_block) {
    					group_outros();
    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});
    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];
    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					}
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);

    			transition_in(creatematerial.$$.fragment, local);

    			transition_in(filteritems.$$.fragment, local);

    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			transition_out(creatematerial.$$.fragment, local);
    			transition_out(filteritems.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t0);
    				detach(h1);
    				detach(t2);
    			}

    			destroy_component(error, detaching);

    			if (detaching) {
    				detach(t3);
    			}

    			destroy_component(creatematerial, detaching);

    			if (detaching) {
    				detach(t4);
    			}

    			destroy_component(filteritems, detaching);

    			if (detaching) {
    				detach(t5);
    			}

    			if (~current_block_type_index) if_blocks[current_block_type_index].d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function instance$1p($$self, $$props, $$invalidate) {
    	let $materials;

    	validate_store(materials, 'materials');
    	component_subscribe($$self, materials, $$value => { $materials = $$value; $$invalidate('$materials', $materials); });

    	

      let errors = '';

      onMount(async () => {
        try {
          await materials.get({});
        } catch (error) {
          $$invalidate('errors', errors = error);
          notifications.add({ text: "Couldn't get materials from server.", type: 'danger' });
        }
      });

    	return { errors, $materials };
    }

    class Materials extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1p, create_fragment$1q, safe_not_equal, []);
    	}
    }

    /* admin/src/components/materials/EditMaterial.svelte generated by Svelte v3.9.2 */

    const file$1k = "admin/src/components/materials/EditMaterial.svelte";

    // (40:2) {#if open}
    function create_if_block$Q(ctx) {
    	var current;

    	var materialform = new MaterialForm({
    		props: {
    		title: ctx.material.title,
    		url: ctx.material.url,
    		id: ctx.material.id,
    		type: ctx.material.type,
    		notes: ctx.material.notes,
    		imageUrl: ctx.material.imageUrl,
    		errors: ctx.errors,
    		loading: ctx.loading
    	},
    		$$inline: true
    	});
    	materialform.$on("submit", ctx.save);
    	materialform.$on("reset", ctx.reset);

    	return {
    		c: function create() {
    			materialform.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(materialform, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var materialform_changes = {};
    			if (changed.material) materialform_changes.title = ctx.material.title;
    			if (changed.material) materialform_changes.url = ctx.material.url;
    			if (changed.material) materialform_changes.id = ctx.material.id;
    			if (changed.material) materialform_changes.type = ctx.material.type;
    			if (changed.material) materialform_changes.notes = ctx.material.notes;
    			if (changed.material) materialform_changes.imageUrl = ctx.material.imageUrl;
    			if (changed.errors) materialform_changes.errors = ctx.errors;
    			if (changed.loading) materialform_changes.loading = ctx.loading;
    			materialform.$set(materialform_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(materialform.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(materialform.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(materialform, detaching);
    		}
    	};
    }

    // (39:0) <Modal bind:open>
    function create_default_slot$i(ctx) {
    	var if_block_anchor, current;

    	var if_block = (ctx.open) && create_if_block$Q(ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.open) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$Q(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function create_fragment$1r(ctx) {
    	var button, i, t0, t1, updating_open, current, dispose;

    	function modal_open_binding(value) {
    		ctx.modal_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let modal_props = {
    		$$slots: { default: [create_default_slot$i] },
    		$$scope: { ctx }
    	};
    	if (ctx.open !== void 0) {
    		modal_props.open = ctx.open;
    	}
    	var modal = new Modal({ props: modal_props, $$inline: true });

    	binding_callbacks.push(() => bind(modal, 'open', modal_open_binding));

    	return {
    		c: function create() {
    			button = element("button");
    			i = element("i");
    			t0 = text("Edit");
    			t1 = space();
    			modal.$$.fragment.c();
    			attr(i, "class", "fas fa-edit");
    			add_location(i, file$1k, 35, 2, 855);
    			attr(button, "class", "button is-primary");
    			add_location(button, file$1k, 34, 0, 784);
    			dispose = listen(button, "click", ctx.click_handler);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);
    			append(button, i);
    			append(button, t0);
    			insert(target, t1, anchor);
    			mount_component(modal, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var modal_changes = {};
    			if (changed.$$scope || changed.open || changed.material || changed.errors || changed.loading) modal_changes.$$scope = { changed, ctx };
    			if (!updating_open && changed.open) {
    				modal_changes.open = ctx.open;
    			}
    			modal.$set(modal_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(button);
    				detach(t1);
    			}

    			destroy_component(modal, detaching);

    			dispose();
    		}
    	};
    }

    function instance$1q($$self, $$props, $$invalidate) {
    	

      let loading = false;
      let errors = '';
      let open = false;
      let { material } = $$props;

      const reset = () => {
        $$invalidate('errors', errors = '');
        $$invalidate('open', open = false);
      };

      const save = async ({ detail }) => {
        $$invalidate('loading', loading = true);
        try {
          await materials.patch({ input: detail, id: material.id });
          notifications.add({ text: `Saved edits to material '${detail.title}'`, type: 'success' });
          reset();
        } catch (error) {
          $$invalidate('errors', errors = error);
          notifications.add({
            text: 'Could not save edits to material.',
            type: 'danger'
          });
        } finally {
          $$invalidate('loading', loading = false);
        }
      };

    	const writable_props = ['material'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<EditMaterial> was created with unknown prop '${key}'`);
    	});

    	function click_handler() { open = true; $$invalidate('open', open); }

    	function modal_open_binding(value) {
    		open = value;
    		$$invalidate('open', open);
    	}

    	$$self.$set = $$props => {
    		if ('material' in $$props) $$invalidate('material', material = $$props.material);
    	};

    	return {
    		loading,
    		errors,
    		open,
    		material,
    		reset,
    		save,
    		click_handler,
    		modal_open_binding
    	};
    }

    class EditMaterial extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1q, create_fragment$1r, safe_not_equal, ["material"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.material === undefined && !('material' in props)) {
    			console.warn("<EditMaterial> was created without expected prop 'material'");
    		}
    	}

    	get material() {
    		throw new Error("<EditMaterial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set material(value) {
    		throw new Error("<EditMaterial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/materials/AudioPlayer.svelte generated by Svelte v3.9.2 */
    const { isNaN: isNaN_1 } = globals;

    const file$1l = "admin/src/components/materials/AudioPlayer.svelte";

    function create_fragment$1s(ctx) {
    	var div, audio_1, source, source_type_value, source_src_value, audio_1_updating = false, audio_1_animationframe, audio_1_is_paused = true, t0, i, t1, span0, t2_value = ctx.format(ctx.time) + "", t2, t3, span1, t4_value = ctx.format(ctx.duration) + "", t4, t5, input, input_value_value, dispose;

    	function audio_1_timeupdate_handler() {
    		cancelAnimationFrame(audio_1_animationframe);
    		if (!audio_1.paused) audio_1_animationframe = raf(audio_1_timeupdate_handler);
    		audio_1_updating = true;
    		ctx.audio_1_timeupdate_handler.call(audio_1);
    	}

    	return {
    		c: function create() {
    			div = element("div");
    			audio_1 = element("audio");
    			source = element("source");
    			t0 = space();
    			i = element("i");
    			t1 = text(" \n  ");
    			span0 = element("span");
    			t2 = text(t2_value);
    			t3 = text("/");
    			span1 = element("span");
    			t4 = text(t4_value);
    			t5 = space();
    			input = element("input");
    			attr(source, "type", source_type_value = ctx.audio.type);
    			attr(source, "src", source_src_value = ctx.audio.url);
    			add_location(source, file$1l, 89, 4, 1767);
    			if (ctx.duration === void 0) add_render_callback(() => ctx.audio_1_durationchange_handler.call(audio_1));
    			add_location(audio_1, file$1l, 88, 2, 1686);
    			attr(i, "class", "fas playpause svelte-mk3mgg");
    			toggle_class(i, "fa-play", ctx.paused);
    			toggle_class(i, "fa-pause", !ctx.paused);
    			add_location(i, file$1l, 91, 2, 1823);
    			attr(span0, "class", "time elapsed svelte-mk3mgg");
    			add_location(span0, file$1l, 96, 2, 1962);
    			attr(span1, "class", "time duration svelte-mk3mgg");
    			add_location(span1, file$1l, 96, 51, 2011);
    			attr(input, "class", "range svelte-mk3mgg");
    			attr(input, "type", "range");
    			attr(input, "id", "seek");
    			attr(input, "max", "100");
    			attr(input, "min", "0");
    			input.value = input_value_value = ctx.progress * 100;
    			add_location(input, file$1l, 97, 2, 2067);
    			attr(div, "class", "audioplayer svelte-mk3mgg");
    			add_location(div, file$1l, 87, 0, 1658);

    			dispose = [
    				listen(audio_1, "timeupdate", audio_1_timeupdate_handler),
    				listen(audio_1, "durationchange", ctx.audio_1_durationchange_handler),
    				listen(audio_1, "play", ctx.audio_1_play_pause_handler),
    				listen(audio_1, "pause", ctx.audio_1_play_pause_handler),
    				listen(i, "click", ctx.click_handler),
    				listen(input, "input", ctx.seek)
    			];
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, audio_1);
    			append(audio_1, source);
    			ctx.audio_1_binding(audio_1);
    			append(div, t0);
    			append(div, i);
    			append(div, t1);
    			append(div, span0);
    			append(span0, t2);
    			append(div, t3);
    			append(div, span1);
    			append(span1, t4);
    			append(div, t5);
    			append(div, input);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.audio) && source_type_value !== (source_type_value = ctx.audio.type)) {
    				attr(source, "type", source_type_value);
    			}

    			if ((changed.audio) && source_src_value !== (source_src_value = ctx.audio.url)) {
    				attr(source, "src", source_src_value);
    			}

    			if (!audio_1_updating && changed.time && !isNaN_1(ctx.time)) audio_1.currentTime = ctx.time;
    			if (changed.paused && audio_1_is_paused !== (audio_1_is_paused = ctx.paused)) audio_1[audio_1_is_paused ? "pause" : "play"]();
    			audio_1_updating = false;

    			if (changed.paused) {
    				toggle_class(i, "fa-play", ctx.paused);
    				toggle_class(i, "fa-pause", !ctx.paused);
    			}

    			if ((changed.time) && t2_value !== (t2_value = ctx.format(ctx.time) + "")) {
    				set_data(t2, t2_value);
    			}

    			if ((changed.duration) && t4_value !== (t4_value = ctx.format(ctx.duration) + "")) {
    				set_data(t4, t4_value);
    			}

    			if ((changed.progress) && input_value_value !== (input_value_value = ctx.progress * 100)) {
    				input.value = input_value_value;
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			ctx.audio_1_binding(null);
    			run_all(dispose);
    		}
    	};
    }

    function instance$1r($$self, $$props, $$invalidate) {
    	let { audio } = $$props;
      let player;
      let paused = true;
      let time = 0;
      let duration;
      let progress = 0;

      onMount(() => {
        const playended = player.addEventListener('ended', () => { $$invalidate('time', time = 0); });
        return () => player.removeEventListener('ended', playended)
      });

      const pad = number => number < 10 ? '0' + number : number;

      const format = time => {
        if (isNaN(time)) return '--:--.-'
        var minutes = Math.floor(time / 60);
        var seconds = (time % 60).toFixed();
        return minutes + ':' + pad(seconds)
      };

      const seek = event => {
        $$invalidate('paused', paused = true);
        const p = event.target.value;
        $$invalidate('time', time = p / 100 * duration);
      };

    	const writable_props = ['audio'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<AudioPlayer> was created with unknown prop '${key}'`);
    	});

    	function audio_1_timeupdate_handler() {
    		time = this.currentTime;
    		$$invalidate('time', time);
    	}

    	function audio_1_durationchange_handler() {
    		duration = this.duration;
    		$$invalidate('duration', duration);
    	}

    	function audio_1_play_pause_handler() {
    		paused = this.paused;
    		$$invalidate('paused', paused);
    	}

    	function audio_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('player', player = $$value);
    		});
    	}

    	function click_handler() { paused = !paused; $$invalidate('paused', paused); }

    	$$self.$set = $$props => {
    		if ('audio' in $$props) $$invalidate('audio', audio = $$props.audio);
    	};

    	$$self.$$.update = ($$dirty = { duration: 1, time: 1 }) => {
    		if ($$dirty.duration || $$dirty.time) { $$invalidate('progress', progress = duration ? time / duration : 0); }
    	};

    	return {
    		audio,
    		player,
    		paused,
    		time,
    		duration,
    		progress,
    		format,
    		seek,
    		audio_1_timeupdate_handler,
    		audio_1_durationchange_handler,
    		audio_1_play_pause_handler,
    		audio_1_binding,
    		click_handler
    	};
    }

    class AudioPlayer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1r, create_fragment$1s, safe_not_equal, ["audio"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.audio === undefined && !('audio' in props)) {
    			console.warn("<AudioPlayer> was created without expected prop 'audio'");
    		}
    	}

    	get audio() {
    		throw new Error("<AudioPlayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set audio(value) {
    		throw new Error("<AudioPlayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/materials/Material.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$q } = globals;

    const file$1m = "admin/src/components/materials/Material.svelte";

    // (60:0) {#if errors}
    function create_if_block_6$1(ctx) {
    	var current;

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			error.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(error, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(error, detaching);
    		}
    	};
    }

    // (100:18) 
    function create_if_block_5$3(ctx) {
    	var current;

    	var loading = new Loading({
    		props: { what: "Material" },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			loading.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},

    		p: noop,

    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};
    }

    // (64:0) {#if $material && $material.id === params.id}
    function create_if_block$R(ctx) {
    	var h1, t0_value = ctx.$material.title + "", t0, t1, t2, show_if_1 = ctx.$material.type.split('/')[0] === 'audio', t3, show_if = ctx.$material.type.split('/')[0] === 'image', t4, section0, h2, t6, p0, t7, t8_value = ctx.$material.type + "", t8, t9, p1, t10, a, t11_value = ctx.truncate(ctx.$material.url) + "", t11, a_href_value, t12, t13, t14, section1, t15, button, i, t16, t17, updating_open, current, dispose;

    	var itemtaglist = new ItemTagList({
    		props: {
    		item: ctx.$material,
    		type: "materials",
    		store: material
    	},
    		$$inline: true
    	});

    	var if_block0 = (show_if_1) && create_if_block_4$3(ctx);

    	var if_block1 = (show_if) && create_if_block_3$6(ctx);

    	var if_block2 = (ctx.$material.imageUrl) && create_if_block_2$d(ctx);

    	var if_block3 = (ctx.$material.notes) && create_if_block_1$r(ctx);

    	var editmaterial = new EditMaterial({
    		props: { material: ctx.$material },
    		$$inline: true
    	});

    	function deleteitem_open_binding(value) {
    		ctx.deleteitem_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let deleteitem_props = {
    		id: ctx.$material.id,
    		store: materials,
    		type: "material",
    		name: ctx.$material.title
    	};
    	if (ctx.showDelete !== void 0) {
    		deleteitem_props.open = ctx.showDelete;
    	}
    	var deleteitem = new DeleteItem({ props: deleteitem_props, $$inline: true });

    	binding_callbacks.push(() => bind(deleteitem, 'open', deleteitem_open_binding));

    	return {
    		c: function create() {
    			h1 = element("h1");
    			t0 = text(t0_value);
    			t1 = space();
    			itemtaglist.$$.fragment.c();
    			t2 = space();
    			if (if_block0) if_block0.c();
    			t3 = space();
    			if (if_block1) if_block1.c();
    			t4 = space();
    			section0 = element("section");
    			h2 = element("h2");
    			h2.textContent = "Material details";
    			t6 = space();
    			p0 = element("p");
    			t7 = text("Type: ");
    			t8 = text(t8_value);
    			t9 = space();
    			p1 = element("p");
    			t10 = text("URL: ");
    			a = element("a");
    			t11 = text(t11_value);
    			t12 = space();
    			if (if_block2) if_block2.c();
    			t13 = space();
    			if (if_block3) if_block3.c();
    			t14 = space();
    			section1 = element("section");
    			editmaterial.$$.fragment.c();
    			t15 = space();
    			button = element("button");
    			i = element("i");
    			t16 = text("Delete");
    			t17 = space();
    			deleteitem.$$.fragment.c();
    			attr(h1, "class", "title");
    			add_location(h1, file$1m, 64, 2, 1420);
    			attr(h2, "class", "title is-4 svelte-1n64ds0");
    			add_location(h2, file$1m, 77, 4, 1770);
    			add_location(p0, file$1m, 78, 4, 1819);
    			attr(a, "href", a_href_value = ctx.$material.url);
    			add_location(a, file$1m, 79, 12, 1861);
    			add_location(p1, file$1m, 79, 4, 1853);
    			attr(section0, "class", "details svelte-1n64ds0");
    			add_location(section0, file$1m, 76, 2, 1740);
    			attr(i, "class", "fas fa-trash");
    			add_location(i, file$1m, 95, 76, 2415);
    			attr(button, "class", "button is-danger");
    			add_location(button, file$1m, 95, 4, 2343);
    			attr(section1, "class", "buttons svelte-1n64ds0");
    			add_location(section1, file$1m, 93, 2, 2271);
    			dispose = listen(button, "click", ctx.click_handler);
    		},

    		m: function mount(target, anchor) {
    			insert(target, h1, anchor);
    			append(h1, t0);
    			insert(target, t1, anchor);
    			mount_component(itemtaglist, target, anchor);
    			insert(target, t2, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert(target, t3, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert(target, t4, anchor);
    			insert(target, section0, anchor);
    			append(section0, h2);
    			append(section0, t6);
    			append(section0, p0);
    			append(p0, t7);
    			append(p0, t8);
    			append(section0, t9);
    			append(section0, p1);
    			append(p1, t10);
    			append(p1, a);
    			append(a, t11);
    			append(section0, t12);
    			if (if_block2) if_block2.m(section0, null);
    			append(section0, t13);
    			if (if_block3) if_block3.m(section0, null);
    			insert(target, t14, anchor);
    			insert(target, section1, anchor);
    			mount_component(editmaterial, section1, null);
    			append(section1, t15);
    			append(section1, button);
    			append(button, i);
    			append(button, t16);
    			append(section1, t17);
    			mount_component(deleteitem, section1, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if ((!current || changed.$material) && t0_value !== (t0_value = ctx.$material.title + "")) {
    				set_data(t0, t0_value);
    			}

    			var itemtaglist_changes = {};
    			if (changed.$material) itemtaglist_changes.item = ctx.$material;
    			if (changed.material) itemtaglist_changes.store = material;
    			itemtaglist.$set(itemtaglist_changes);

    			if (changed.$material) show_if_1 = ctx.$material.type.split('/')[0] === 'audio';

    			if (show_if_1) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    					transition_in(if_block0, 1);
    				} else {
    					if_block0 = create_if_block_4$3(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t3.parentNode, t3);
    				}
    			} else if (if_block0) {
    				group_outros();
    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});
    				check_outros();
    			}

    			if (changed.$material) show_if = ctx.$material.type.split('/')[0] === 'image';

    			if (show_if) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    				} else {
    					if_block1 = create_if_block_3$6(ctx);
    					if_block1.c();
    					if_block1.m(t4.parentNode, t4);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if ((!current || changed.$material) && t8_value !== (t8_value = ctx.$material.type + "")) {
    				set_data(t8, t8_value);
    			}

    			if ((!current || changed.$material) && t11_value !== (t11_value = ctx.truncate(ctx.$material.url) + "")) {
    				set_data(t11, t11_value);
    			}

    			if ((!current || changed.$material) && a_href_value !== (a_href_value = ctx.$material.url)) {
    				attr(a, "href", a_href_value);
    			}

    			if (ctx.$material.imageUrl) {
    				if (if_block2) {
    					if_block2.p(changed, ctx);
    				} else {
    					if_block2 = create_if_block_2$d(ctx);
    					if_block2.c();
    					if_block2.m(section0, t13);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (ctx.$material.notes) {
    				if (if_block3) {
    					if_block3.p(changed, ctx);
    				} else {
    					if_block3 = create_if_block_1$r(ctx);
    					if_block3.c();
    					if_block3.m(section0, null);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			var editmaterial_changes = {};
    			if (changed.$material) editmaterial_changes.material = ctx.$material;
    			editmaterial.$set(editmaterial_changes);

    			var deleteitem_changes = {};
    			if (changed.$material) deleteitem_changes.id = ctx.$material.id;
    			if (changed.materials) deleteitem_changes.store = materials;
    			if (changed.$material) deleteitem_changes.name = ctx.$material.title;
    			if (!updating_open && changed.showDelete) {
    				deleteitem_changes.open = ctx.showDelete;
    			}
    			deleteitem.$set(deleteitem_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(itemtaglist.$$.fragment, local);

    			transition_in(if_block0);

    			transition_in(editmaterial.$$.fragment, local);

    			transition_in(deleteitem.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(itemtaglist.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(editmaterial.$$.fragment, local);
    			transition_out(deleteitem.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h1);
    				detach(t1);
    			}

    			destroy_component(itemtaglist, detaching);

    			if (detaching) {
    				detach(t2);
    			}

    			if (if_block0) if_block0.d(detaching);

    			if (detaching) {
    				detach(t3);
    			}

    			if (if_block1) if_block1.d(detaching);

    			if (detaching) {
    				detach(t4);
    				detach(section0);
    			}

    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();

    			if (detaching) {
    				detach(t14);
    				detach(section1);
    			}

    			destroy_component(editmaterial);

    			destroy_component(deleteitem);

    			dispose();
    		}
    	};
    }

    // (69:2) {#if $material.type.split('/')[0] === 'audio'}
    function create_if_block_4$3(ctx) {
    	var current;

    	var audioplayer = new AudioPlayer({
    		props: { audio: ctx.$material },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			audioplayer.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(audioplayer, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var audioplayer_changes = {};
    			if (changed.$material) audioplayer_changes.audio = ctx.$material;
    			audioplayer.$set(audioplayer_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(audioplayer.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(audioplayer.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(audioplayer, detaching);
    		}
    	};
    }

    // (73:2) {#if $material.type.split('/')[0] === 'image'}
    function create_if_block_3$6(ctx) {
    	var img, img_src_value, img_alt_value;

    	return {
    		c: function create() {
    			img = element("img");
    			attr(img, "src", img_src_value = ctx.$material.url);
    			attr(img, "alt", img_alt_value = ctx.$material.title);
    			attr(img, "class", "svelte-1n64ds0");
    			add_location(img, file$1m, 73, 4, 1681);
    		},

    		m: function mount(target, anchor) {
    			insert(target, img, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.$material) && img_src_value !== (img_src_value = ctx.$material.url)) {
    				attr(img, "src", img_src_value);
    			}

    			if ((changed.$material) && img_alt_value !== (img_alt_value = ctx.$material.title)) {
    				attr(img, "alt", img_alt_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(img);
    			}
    		}
    	};
    }

    // (81:4) {#if $material.imageUrl}
    function create_if_block_2$d(ctx) {
    	var h3, t_1, a, img, img_src_value, a_href_value;

    	return {
    		c: function create() {
    			h3 = element("h3");
    			h3.textContent = "Related image";
    			t_1 = space();
    			a = element("a");
    			img = element("img");
    			attr(h3, "class", "title is-5");
    			add_location(h3, file$1m, 81, 6, 1954);
    			attr(img, "src", img_src_value = ctx.$material.imageUrl);
    			attr(img, "alt", "image related to material");
    			attr(img, "class", "svelte-1n64ds0");
    			add_location(img, file$1m, 83, 8, 2040);
    			attr(a, "href", a_href_value = ctx.$material.imageUrl);
    			add_location(a, file$1m, 82, 6, 2002);
    		},

    		m: function mount(target, anchor) {
    			insert(target, h3, anchor);
    			insert(target, t_1, anchor);
    			insert(target, a, anchor);
    			append(a, img);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.$material) && img_src_value !== (img_src_value = ctx.$material.imageUrl)) {
    				attr(img, "src", img_src_value);
    			}

    			if ((changed.$material) && a_href_value !== (a_href_value = ctx.$material.imageUrl)) {
    				attr(a, "href", a_href_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h3);
    				detach(t_1);
    				detach(a);
    			}
    		}
    	};
    }

    // (87:4) {#if $material.notes}
    function create_if_block_1$r(ctx) {
    	var h3, t_1, html_tag, raw_value = marked(ctx.$material.notes, { breaks: true }) + "";

    	return {
    		c: function create() {
    			h3 = element("h3");
    			h3.textContent = "Notes";
    			t_1 = space();
    			attr(h3, "class", "title is-5");
    			add_location(h3, file$1m, 87, 4, 2154);
    			html_tag = new HtmlTag(raw_value, null);
    		},

    		m: function mount(target, anchor) {
    			insert(target, h3, anchor);
    			insert(target, t_1, anchor);
    			html_tag.m(target, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.$material) && raw_value !== (raw_value = marked(ctx.$material.notes, { breaks: true }) + "")) {
    				html_tag.p(raw_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h3);
    				detach(t_1);
    				html_tag.d();
    			}
    		}
    	};
    }

    function create_fragment$1t(ctx) {
    	var t0, t1, current_block_type_index, if_block1, if_block1_anchor, current;

    	var if_block0 = (ctx.errors) && create_if_block_6$1(ctx);

    	var if_block_creators = [
    		create_if_block$R,
    		create_if_block_5$3
    	];

    	var if_blocks = [];

    	function select_block_type(changed, ctx) {
    		if (ctx.$material && ctx.$material.id === ctx.params.id) return 0;
    		if (!ctx.errors) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(null, ctx))) {
    		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	return {
    		c: function create() {
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    			document.title = "Material Details";
    		},

    		l: function claim(nodes) {
    			throw new Error_1$q("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t0, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert(target, t1, anchor);
    			if (~current_block_type_index) if_blocks[current_block_type_index].m(target, anchor);
    			insert(target, if_block1_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.errors) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    					transition_in(if_block0, 1);
    				} else {
    					if_block0 = create_if_block_6$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t1.parentNode, t1);
    				}
    			} else if (if_block0) {
    				group_outros();
    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});
    				check_outros();
    			}

    			var previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(changed, ctx);
    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) if_blocks[current_block_type_index].p(changed, ctx);
    			} else {
    				if (if_block1) {
    					group_outros();
    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});
    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block1 = if_blocks[current_block_type_index];
    					if (!if_block1) {
    						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block1.c();
    					}
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				} else {
    					if_block1 = null;
    				}
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t0);
    			}

    			if (if_block0) if_block0.d(detaching);

    			if (detaching) {
    				detach(t1);
    			}

    			if (~current_block_type_index) if_blocks[current_block_type_index].d(detaching);

    			if (detaching) {
    				detach(if_block1_anchor);
    			}
    		}
    	};
    }

    function instance$1s($$self, $$props, $$invalidate) {
    	let $material;

    	validate_store(material, 'material');
    	component_subscribe($$self, material, $$value => { $material = $$value; $$invalidate('$material', $material); });

    	

      let { params = {} } = $$props;
      let errors = '';
      let showDelete = false;

      onMount(async () => {
        if (!$material || $material.id !== params.id) {
          try {
            await material.get(params.id);
            if ($material === null) push(`/not-found/material/${params.id}`);
          } catch (error) {
            $$invalidate('errors', errors = error);
            notifications.add({ text: 'Could not fetch material from the server', type: 'danger' });
          }
        }
      });

      const truncate = (string) => {
        if (string.length > 80) {
          return string.substring(0, 77) + '...'
        }
      };

    	const writable_props = ['params'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Material> was created with unknown prop '${key}'`);
    	});

    	function click_handler() { showDelete = true; $$invalidate('showDelete', showDelete); }

    	function deleteitem_open_binding(value) {
    		showDelete = value;
    		$$invalidate('showDelete', showDelete);
    	}

    	$$self.$set = $$props => {
    		if ('params' in $$props) $$invalidate('params', params = $$props.params);
    	};

    	return {
    		params,
    		errors,
    		showDelete,
    		truncate,
    		$material,
    		click_handler,
    		deleteitem_open_binding
    	};
    }

    class Material extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1s, create_fragment$1t, safe_not_equal, ["params"]);
    	}

    	get params() {
    		throw new Error_1$q("<Material>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error_1$q("<Material>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/words/WordList.svelte generated by Svelte v3.9.2 */

    const file$1n = "admin/src/components/words/WordList.svelte";

    function get_each_context_1$6(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.tag = list[i];
    	return child_ctx;
    }

    function get_each_context$s(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.word = list[i];
    	return child_ctx;
    }

    // (22:2) {#if words.length > 0}
    function create_if_block$S(ctx) {
    	var p, t0_value = ctx.words.length + "", t0, t1, t2, each_blocks = [], each_1_lookup = new Map(), each_1_anchor;

    	var each_value = ctx.words;

    	const get_key = ctx => ctx.word.id;

    	for (var i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$s(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$s(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = text(" words found:");
    			t2 = space();

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();

    			each_1_anchor = empty();
    			add_location(p, file$1n, 22, 4, 269);
    		},

    		m: function mount(target, anchor) {
    			insert(target, p, anchor);
    			append(p, t0);
    			append(p, t1);
    			insert(target, t2, anchor);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(target, anchor);

    			insert(target, each_1_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.words) && t0_value !== (t0_value = ctx.words.length + "")) {
    				set_data(t0, t0_value);
    			}

    			const each_value = ctx.words;
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$s, each_1_anchor, get_each_context$s);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(p);
    				detach(t2);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d(detaching);

    			if (detaching) {
    				detach(each_1_anchor);
    			}
    		}
    	};
    }

    // (26:8) {#if word.chinese}
    function create_if_block_2$e(ctx) {
    	var t0, t1_value = ctx.word.chinese + "", t1, t2;

    	return {
    		c: function create() {
    			t0 = text("(");
    			t1 = text(t1_value);
    			t2 = text(")");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t0, anchor);
    			insert(target, t1, anchor);
    			insert(target, t2, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.words) && t1_value !== (t1_value = ctx.word.chinese + "")) {
    				set_data(t1, t1_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t0);
    				detach(t1);
    				detach(t2);
    			}
    		}
    	};
    }

    // (30:8) {#if word.tags && word.tags.length > 0}
    function create_if_block_1$s(ctx) {
    	var div, each_blocks = [], each_1_lookup = new Map();

    	var each_value_1 = ctx.word.tags;

    	const get_key = ctx => ctx.tag.id;

    	for (var i = 0; i < each_value_1.length; i += 1) {
    		let child_ctx = get_each_context_1$6(ctx, each_value_1, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_1$6(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			div = element("div");

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();
    			attr(div, "class", "tags svelte-4s8ccd");
    			add_location(div, file$1n, 30, 8, 530);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(div, null);
    		},

    		p: function update(changed, ctx) {
    			const each_value_1 = ctx.word.tags;
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value_1, each_1_lookup, div, destroy_block, create_each_block_1$6, null, get_each_context_1$6);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d();
    		}
    	};
    }

    // (32:10) {#each word.tags as tag (tag.id)}
    function create_each_block_1$6(key_1, ctx) {
    	var span, t_value = ctx.tag.name + "", t;

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr(span, "class", "tag is-dark");
    			add_location(span, file$1n, 32, 12, 605);
    			this.first = span;
    		},

    		m: function mount(target, anchor) {
    			insert(target, span, anchor);
    			append(span, t);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.words) && t_value !== (t_value = ctx.tag.name + "")) {
    				set_data(t, t_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(span);
    			}
    		}
    	};
    }

    // (24:4) {#each words as word (word.id)}
    function create_each_block$s(key_1, ctx) {
    	var li, a, t0_value = ctx.word.english + "", t0, t1, a_href_value, t2, t3;

    	var if_block0 = (ctx.word.chinese) && create_if_block_2$e(ctx);

    	var if_block1 = (ctx.word.tags && ctx.word.tags.length > 0) && create_if_block_1$s(ctx);

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			li = element("li");
    			a = element("a");
    			t0 = text(t0_value);
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			attr(a, "href", a_href_value = "#/word/" + ctx.word.id);
    			add_location(a, file$1n, 24, 10, 350);
    			attr(li, "class", "svelte-4s8ccd");
    			add_location(li, file$1n, 24, 6, 346);
    			this.first = li;
    		},

    		m: function mount(target, anchor) {
    			insert(target, li, anchor);
    			append(li, a);
    			append(a, t0);
    			append(a, t1);
    			if (if_block0) if_block0.m(a, null);
    			append(li, t2);
    			if (if_block1) if_block1.m(li, null);
    			append(li, t3);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.words) && t0_value !== (t0_value = ctx.word.english + "")) {
    				set_data(t0, t0_value);
    			}

    			if (ctx.word.chinese) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    				} else {
    					if_block0 = create_if_block_2$e(ctx);
    					if_block0.c();
    					if_block0.m(a, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if ((changed.words) && a_href_value !== (a_href_value = "#/word/" + ctx.word.id)) {
    				attr(a, "href", a_href_value);
    			}

    			if (ctx.word.tags && ctx.word.tags.length > 0) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    				} else {
    					if_block1 = create_if_block_1$s(ctx);
    					if_block1.c();
    					if_block1.m(li, t3);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(li);
    			}

    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};
    }

    function create_fragment$1u(ctx) {
    	var section;

    	var if_block = (ctx.words.length > 0) && create_if_block$S(ctx);

    	return {
    		c: function create() {
    			section = element("section");
    			if (if_block) if_block.c();
    			attr(section, "class", "word-list svelte-4s8ccd");
    			add_location(section, file$1n, 20, 0, 212);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, section, anchor);
    			if (if_block) if_block.m(section, null);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.words.length > 0) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$S(ctx);
    					if_block.c();
    					if_block.m(section, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(section);
    			}

    			if (if_block) if_block.d();
    		}
    	};
    }

    function instance$1t($$self, $$props, $$invalidate) {
    	let { words = [] } = $$props;

    	const writable_props = ['words'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<WordList> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('words' in $$props) $$invalidate('words', words = $$props.words);
    	};

    	return { words };
    }

    class WordList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1t, create_fragment$1u, safe_not_equal, ["words"]);
    	}

    	get words() {
    		throw new Error("<WordList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set words(value) {
    		throw new Error("<WordList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/words/WordForm.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$r } = globals;

    const file$1o = "admin/src/components/words/WordForm.svelte";

    // (43:30) {:else}
    function create_else_block$l(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Create");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    // (43:18) {#if id}
    function create_if_block$T(ctx) {
    	var t;

    	return {
    		c: function create() {
    			t = text("Edit");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t);
    			}
    		}
    	};
    }

    function create_fragment$1v(ctx) {
    	var h1, t0, t1, form_1, t2, updating_value, t3, updating_value_1, t4, updating_value_2, t5, div, button, t7, input3, current, dispose;

    	function select_block_type(changed, ctx) {
    		if (ctx.id) return create_if_block$T;
    		return create_else_block$l;
    	}

    	var current_block_type = select_block_type(null, ctx);
    	var if_block = current_block_type(ctx);

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	function input0_value_binding(value) {
    		ctx.input0_value_binding.call(null, value);
    		updating_value = true;
    		add_flush_callback(() => updating_value = false);
    	}

    	let input0_props = {
    		label: "English",
    		placeholder: "e.g. 'bookcase'",
    		required: true
    	};
    	if (ctx.english !== void 0) {
    		input0_props.value = ctx.english;
    	}
    	var input0 = new Input({ props: input0_props, $$inline: true });

    	binding_callbacks.push(() => bind(input0, 'value', input0_value_binding));

    	function input1_value_binding(value_1) {
    		ctx.input1_value_binding.call(null, value_1);
    		updating_value_1 = true;
    		add_flush_callback(() => updating_value_1 = false);
    	}

    	let input1_props = {
    		label: "Chinese",
    		placeholder: "e.g. '书柜'"
    	};
    	if (ctx.chinese !== void 0) {
    		input1_props.value = ctx.chinese;
    	}
    	var input1 = new Input({ props: input1_props, $$inline: true });

    	binding_callbacks.push(() => bind(input1, 'value', input1_value_binding));

    	function input2_value_binding(value_2) {
    		ctx.input2_value_binding.call(null, value_2);
    		updating_value_2 = true;
    		add_flush_callback(() => updating_value_2 = false);
    	}

    	let input2_props = { label: "URL of audio" };
    	if (ctx.audio !== void 0) {
    		input2_props.value = ctx.audio;
    	}
    	var input2 = new Input({ props: input2_props, $$inline: true });

    	binding_callbacks.push(() => bind(input2, 'value', input2_value_binding));

    	return {
    		c: function create() {
    			h1 = element("h1");
    			if_block.c();
    			t0 = text(" word");
    			t1 = space();
    			form_1 = element("form");
    			error.$$.fragment.c();
    			t2 = space();
    			input0.$$.fragment.c();
    			t3 = space();
    			input1.$$.fragment.c();
    			t4 = space();
    			input2.$$.fragment.c();
    			t5 = space();
    			div = element("div");
    			button = element("button");
    			button.textContent = "Save word";
    			t7 = space();
    			input3 = element("input");
    			attr(h1, "class", "title");
    			add_location(h1, file$1o, 42, 0, 832);
    			attr(button, "type", "submit");
    			attr(button, "class", "button is-primary");
    			toggle_class(button, "is-loading", ctx.loading);
    			add_location(button, file$1o, 52, 10, 1290);
    			attr(input3, "type", "reset");
    			attr(input3, "class", "button");
    			input3.value = "Cancel";
    			add_location(input3, file$1o, 53, 10, 1417);
    			attr(div, "class", "buttons svelte-oih4d0");
    			add_location(div, file$1o, 51, 8, 1258);
    			form_1.noValidate = true;
    			attr(form_1, "class", "svelte-oih4d0");
    			add_location(form_1, file$1o, 44, 6, 902);

    			dispose = [
    				listen(form_1, "submit", prevent_default(ctx.handleSubmit)),
    				listen(form_1, "reset", ctx.reset_handler)
    			];
    		},

    		l: function claim(nodes) {
    			throw new Error_1$r("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, h1, anchor);
    			if_block.m(h1, null);
    			append(h1, t0);
    			insert(target, t1, anchor);
    			insert(target, form_1, anchor);
    			mount_component(error, form_1, null);
    			append(form_1, t2);
    			mount_component(input0, form_1, null);
    			append(form_1, t3);
    			mount_component(input1, form_1, null);
    			append(form_1, t4);
    			mount_component(input2, form_1, null);
    			append(form_1, t5);
    			append(form_1, div);
    			append(div, button);
    			ctx.button_binding(button);
    			append(div, t7);
    			append(div, input3);
    			ctx.form_1_binding(form_1);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type !== (current_block_type = select_block_type(changed, ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);
    				if (if_block) {
    					if_block.c();
    					if_block.m(h1, t0);
    				}
    			}

    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);

    			var input0_changes = {};
    			if (!updating_value && changed.english) {
    				input0_changes.value = ctx.english;
    			}
    			input0.$set(input0_changes);

    			var input1_changes = {};
    			if (!updating_value_1 && changed.chinese) {
    				input1_changes.value = ctx.chinese;
    			}
    			input1.$set(input1_changes);

    			var input2_changes = {};
    			if (!updating_value_2 && changed.audio) {
    				input2_changes.value = ctx.audio;
    			}
    			input2.$set(input2_changes);

    			if (changed.loading) {
    				toggle_class(button, "is-loading", ctx.loading);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);

    			transition_in(input0.$$.fragment, local);

    			transition_in(input1.$$.fragment, local);

    			transition_in(input2.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			transition_out(input0.$$.fragment, local);
    			transition_out(input1.$$.fragment, local);
    			transition_out(input2.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h1);
    			}

    			if_block.d();

    			if (detaching) {
    				detach(t1);
    				detach(form_1);
    			}

    			destroy_component(error);

    			destroy_component(input0);

    			destroy_component(input1);

    			destroy_component(input2);

    			ctx.button_binding(null);
    			ctx.form_1_binding(null);
    			run_all(dispose);
    		}
    	};
    }

    function instance$1u($$self, $$props, $$invalidate) {
    	

      let { english = '', chinese = '', audio = '', id = null, errors, loading } = $$props;
      let saveButton;
      let form;

      const dispatch = createEventDispatcher();

      const handleSubmit = () => {
        const isValid = form.checkValidity();
        if (!isValid) {
          notifications.add({
            text: 'Please fix form errors first.',
            type: 'danger'
          });
          return
        }
        dispatch('submit', { english, chinese, audio });
      };

    	const writable_props = ['english', 'chinese', 'audio', 'id', 'errors', 'loading'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<WordForm> was created with unknown prop '${key}'`);
    	});

    	function reset_handler(event) {
    		bubble($$self, event);
    	}

    	function input0_value_binding(value) {
    		english = value;
    		$$invalidate('english', english);
    	}

    	function input1_value_binding(value_1) {
    		chinese = value_1;
    		$$invalidate('chinese', chinese);
    	}

    	function input2_value_binding(value_2) {
    		audio = value_2;
    		$$invalidate('audio', audio);
    	}

    	function button_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('saveButton', saveButton = $$value);
    		});
    	}

    	function form_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('form', form = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ('english' in $$props) $$invalidate('english', english = $$props.english);
    		if ('chinese' in $$props) $$invalidate('chinese', chinese = $$props.chinese);
    		if ('audio' in $$props) $$invalidate('audio', audio = $$props.audio);
    		if ('id' in $$props) $$invalidate('id', id = $$props.id);
    		if ('errors' in $$props) $$invalidate('errors', errors = $$props.errors);
    		if ('loading' in $$props) $$invalidate('loading', loading = $$props.loading);
    	};

    	$$self.$$.update = ($$dirty = { saveButton: 1, loading: 1 }) => {
    		if ($$dirty.saveButton || $$dirty.loading) { if (saveButton) { saveButton.disabled = loading; $$invalidate('saveButton', saveButton), $$invalidate('loading', loading); } }
    	};

    	return {
    		english,
    		chinese,
    		audio,
    		id,
    		errors,
    		loading,
    		saveButton,
    		form,
    		handleSubmit,
    		reset_handler,
    		input0_value_binding,
    		input1_value_binding,
    		input2_value_binding,
    		button_binding,
    		form_1_binding
    	};
    }

    class WordForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1u, create_fragment$1v, safe_not_equal, ["english", "chinese", "audio", "id", "errors", "loading"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.errors === undefined && !('errors' in props)) {
    			console.warn("<WordForm> was created without expected prop 'errors'");
    		}
    		if (ctx.loading === undefined && !('loading' in props)) {
    			console.warn("<WordForm> was created without expected prop 'loading'");
    		}
    	}

    	get english() {
    		throw new Error_1$r("<WordForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set english(value) {
    		throw new Error_1$r("<WordForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get chinese() {
    		throw new Error_1$r("<WordForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set chinese(value) {
    		throw new Error_1$r("<WordForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get audio() {
    		throw new Error_1$r("<WordForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set audio(value) {
    		throw new Error_1$r("<WordForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error_1$r("<WordForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error_1$r("<WordForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get errors() {
    		throw new Error_1$r("<WordForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set errors(value) {
    		throw new Error_1$r("<WordForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loading() {
    		throw new Error_1$r("<WordForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loading(value) {
    		throw new Error_1$r("<WordForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/words/CreateWord.svelte generated by Svelte v3.9.2 */

    const file$1p = "admin/src/components/words/CreateWord.svelte";

    // (35:0) <Modal bind:open>
    function create_default_slot$j(ctx) {
    	var current;

    	var wordform = new WordForm({
    		props: {
    		errors: ctx.errors,
    		loading: ctx.loading
    	},
    		$$inline: true
    	});
    	wordform.$on("reset", ctx.reset);
    	wordform.$on("submit", ctx.save);

    	return {
    		c: function create() {
    			wordform.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(wordform, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var wordform_changes = {};
    			if (changed.errors) wordform_changes.errors = ctx.errors;
    			if (changed.loading) wordform_changes.loading = ctx.loading;
    			wordform.$set(wordform_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(wordform.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(wordform.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(wordform, detaching);
    		}
    	};
    }

    function create_fragment$1w(ctx) {
    	var button, i, t0, t1, updating_open, current, dispose;

    	function modal_open_binding(value) {
    		ctx.modal_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let modal_props = {
    		$$slots: { default: [create_default_slot$j] },
    		$$scope: { ctx }
    	};
    	if (ctx.open !== void 0) {
    		modal_props.open = ctx.open;
    	}
    	var modal = new Modal({ props: modal_props, $$inline: true });

    	binding_callbacks.push(() => bind(modal, 'open', modal_open_binding));

    	return {
    		c: function create() {
    			button = element("button");
    			i = element("i");
    			t0 = text("Add word");
    			t1 = space();
    			modal.$$.fragment.c();
    			attr(i, "class", "fas fa-plus");
    			add_location(i, file$1p, 33, 67, 770);
    			attr(button, "class", "button is-primary");
    			add_location(button, file$1p, 33, 0, 703);
    			dispose = listen(button, "click", ctx.click_handler);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);
    			append(button, i);
    			append(button, t0);
    			insert(target, t1, anchor);
    			mount_component(modal, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var modal_changes = {};
    			if (changed.$$scope || changed.errors || changed.loading) modal_changes.$$scope = { changed, ctx };
    			if (!updating_open && changed.open) {
    				modal_changes.open = ctx.open;
    			}
    			modal.$set(modal_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(button);
    				detach(t1);
    			}

    			destroy_component(modal, detaching);

    			dispose();
    		}
    	};
    }

    function instance$1v($$self, $$props, $$invalidate) {
    	

      let loading = false;
      let errors = '';
      let open = false;

      const reset = () => {
        $$invalidate('errors', errors = '');
        $$invalidate('open', open = false);
      };

      const save = async ({ detail }) => {
        $$invalidate('loading', loading = true);
        try {
          await words.create(detail);
          notifications.add({ text: `Saved new word '${detail.english}'`, type: 'success' });
          reset();
        } catch (error) {
          $$invalidate('errors', errors = error);
          notifications.add({
            text: 'Could not save new word.',
            type: 'danger'
          });
        } finally {
          $$invalidate('loading', loading = false);
        }
      };

    	function click_handler() { open = true; $$invalidate('open', open); }

    	function modal_open_binding(value) {
    		open = value;
    		$$invalidate('open', open);
    	}

    	return {
    		loading,
    		errors,
    		open,
    		reset,
    		save,
    		click_handler,
    		modal_open_binding
    	};
    }

    class CreateWord extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1v, create_fragment$1w, safe_not_equal, []);
    	}
    }

    /* admin/src/components/words/Words.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$s } = globals;

    const file$1q = "admin/src/components/words/Words.svelte";

    // (36:20) 
    function create_if_block_1$t(ctx) {
    	var current;

    	var loading = new Loading({ props: { what: "words" }, $$inline: true });

    	return {
    		c: function create() {
    			loading.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},

    		p: noop,

    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};
    }

    // (34:0) {#if $words}
    function create_if_block$U(ctx) {
    	var current;

    	var wordlist = new WordList({
    		props: { words: ctx.$words },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			wordlist.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(wordlist, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var wordlist_changes = {};
    			if (changed.$words) wordlist_changes.words = ctx.$words;
    			wordlist.$set(wordlist_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(wordlist.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(wordlist.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(wordlist, detaching);
    		}
    	};
    }

    function create_fragment$1x(ctx) {
    	var t0, h1, t2, t3, t4, t5, current_block_type_index, if_block, if_block_anchor, current;

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	var createword = new CreateWord({ $$inline: true });

    	var filteritems = new FilterItems({
    		props: {
    		searchParams: ['english', 'chinese'],
    		store: words
    	},
    		$$inline: true
    	});

    	var if_block_creators = [
    		create_if_block$U,
    		create_if_block_1$t
    	];

    	var if_blocks = [];

    	function select_block_type(changed, ctx) {
    		if (ctx.$words) return 0;
    		if (!ctx.errors) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(null, ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	return {
    		c: function create() {
    			t0 = space();
    			h1 = element("h1");
    			h1.textContent = "Words";
    			t2 = space();
    			error.$$.fragment.c();
    			t3 = space();
    			createword.$$.fragment.c();
    			t4 = space();
    			filteritems.$$.fragment.c();
    			t5 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			document.title = "Words";
    			attr(h1, "class", "title");
    			add_location(h1, file$1q, 25, 0, 628);
    		},

    		l: function claim(nodes) {
    			throw new Error_1$s("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t0, anchor);
    			insert(target, h1, anchor);
    			insert(target, t2, anchor);
    			mount_component(error, target, anchor);
    			insert(target, t3, anchor);
    			mount_component(createword, target, anchor);
    			insert(target, t4, anchor);
    			mount_component(filteritems, target, anchor);
    			insert(target, t5, anchor);
    			if (~current_block_type_index) if_blocks[current_block_type_index].m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);

    			var filteritems_changes = {};
    			if (changed.words) filteritems_changes.store = words;
    			filteritems.$set(filteritems_changes);

    			var previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(changed, ctx);
    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) if_blocks[current_block_type_index].p(changed, ctx);
    			} else {
    				if (if_block) {
    					group_outros();
    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});
    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];
    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					}
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);

    			transition_in(createword.$$.fragment, local);

    			transition_in(filteritems.$$.fragment, local);

    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			transition_out(createword.$$.fragment, local);
    			transition_out(filteritems.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t0);
    				detach(h1);
    				detach(t2);
    			}

    			destroy_component(error, detaching);

    			if (detaching) {
    				detach(t3);
    			}

    			destroy_component(createword, detaching);

    			if (detaching) {
    				detach(t4);
    			}

    			destroy_component(filteritems, detaching);

    			if (detaching) {
    				detach(t5);
    			}

    			if (~current_block_type_index) if_blocks[current_block_type_index].d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function instance$1w($$self, $$props, $$invalidate) {
    	let $words;

    	validate_store(words, 'words');
    	component_subscribe($$self, words, $$value => { $words = $$value; $$invalidate('$words', $words); });

    	

      let errors = '';

      onMount(async () => {
        try {
          await words.get();
        } catch (error) {
          $$invalidate('errors', errors = error);
          notifications.add({ text: "Couldn't get words from server.", type: 'danger' });
        }
      });

    	return { errors, $words };
    }

    class Words extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1w, create_fragment$1x, safe_not_equal, []);
    	}
    }

    /* admin/src/components/words/EditWord.svelte generated by Svelte v3.9.2 */

    const file$1r = "admin/src/components/words/EditWord.svelte";

    // (40:2) {#if open}
    function create_if_block$V(ctx) {
    	var current;

    	var wordform = new WordForm({
    		props: {
    		english: ctx.word.english,
    		audio: ctx.word.audio,
    		chinese: ctx.word.chinese,
    		errors: ctx.errors,
    		loading: ctx.loading
    	},
    		$$inline: true
    	});
    	wordform.$on("submit", ctx.save);
    	wordform.$on("reset", ctx.reset);

    	return {
    		c: function create() {
    			wordform.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(wordform, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var wordform_changes = {};
    			if (changed.word) wordform_changes.english = ctx.word.english;
    			if (changed.word) wordform_changes.audio = ctx.word.audio;
    			if (changed.word) wordform_changes.chinese = ctx.word.chinese;
    			if (changed.errors) wordform_changes.errors = ctx.errors;
    			if (changed.loading) wordform_changes.loading = ctx.loading;
    			wordform.$set(wordform_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(wordform.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(wordform.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(wordform, detaching);
    		}
    	};
    }

    // (39:0) <Modal bind:open>
    function create_default_slot$k(ctx) {
    	var if_block_anchor, current;

    	var if_block = (ctx.open) && create_if_block$V(ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.open) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$V(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function create_fragment$1y(ctx) {
    	var button, i, t0, t1, updating_open, current, dispose;

    	function modal_open_binding(value) {
    		ctx.modal_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let modal_props = {
    		$$slots: { default: [create_default_slot$k] },
    		$$scope: { ctx }
    	};
    	if (ctx.open !== void 0) {
    		modal_props.open = ctx.open;
    	}
    	var modal = new Modal({ props: modal_props, $$inline: true });

    	binding_callbacks.push(() => bind(modal, 'open', modal_open_binding));

    	return {
    		c: function create() {
    			button = element("button");
    			i = element("i");
    			t0 = text("Edit");
    			t1 = space();
    			modal.$$.fragment.c();
    			attr(i, "class", "fas fa-edit");
    			add_location(i, file$1r, 35, 2, 816);
    			attr(button, "class", "button is-primary");
    			add_location(button, file$1r, 34, 0, 745);
    			dispose = listen(button, "click", ctx.click_handler);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, button, anchor);
    			append(button, i);
    			append(button, t0);
    			insert(target, t1, anchor);
    			mount_component(modal, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var modal_changes = {};
    			if (changed.$$scope || changed.open || changed.word || changed.errors || changed.loading) modal_changes.$$scope = { changed, ctx };
    			if (!updating_open && changed.open) {
    				modal_changes.open = ctx.open;
    			}
    			modal.$set(modal_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(modal.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(modal.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(button);
    				detach(t1);
    			}

    			destroy_component(modal, detaching);

    			dispose();
    		}
    	};
    }

    function instance$1x($$self, $$props, $$invalidate) {
    	

      let loading = false;
      let errors = '';
      let open = false;
      let { word } = $$props;

      const reset = () => {
        $$invalidate('errors', errors = '');
        $$invalidate('open', open = false);
      };

      const save = async ({ detail }) => {
        $$invalidate('loading', loading = true);
        try {
          await words.patch({ input: detail, id: word.id });
          notifications.add({ text: `Saved edits to word '${detail.english}'`, type: 'success' });
          reset();
        } catch (error) {
          $$invalidate('errors', errors = error);
          notifications.add({
            text: 'Could not save word.',
            type: 'danger'
          });
        } finally {
          $$invalidate('loading', loading = false);
        }
      };

    	const writable_props = ['word'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<EditWord> was created with unknown prop '${key}'`);
    	});

    	function click_handler() { open = true; $$invalidate('open', open); }

    	function modal_open_binding(value) {
    		open = value;
    		$$invalidate('open', open);
    	}

    	$$self.$set = $$props => {
    		if ('word' in $$props) $$invalidate('word', word = $$props.word);
    	};

    	return {
    		loading,
    		errors,
    		open,
    		word,
    		reset,
    		save,
    		click_handler,
    		modal_open_binding
    	};
    }

    class EditWord extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1x, create_fragment$1y, safe_not_equal, ["word"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.word === undefined && !('word' in props)) {
    			console.warn("<EditWord> was created without expected prop 'word'");
    		}
    	}

    	get word() {
    		throw new Error("<EditWord>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set word(value) {
    		throw new Error("<EditWord>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/words/Word.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$t } = globals;

    const file$1s = "admin/src/components/words/Word.svelte";

    function get_each_context$t(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.lesson = list[i];
    	return child_ctx;
    }

    // (39:0) {#if errors}
    function create_if_block_3$7(ctx) {
    	var current;

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			error.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(error, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(error, detaching);
    		}
    	};
    }

    // (67:20) 
    function create_if_block_2$f(ctx) {
    	var current;

    	var loading = new Loading({ props: { what: "word" }, $$inline: true });

    	return {
    		c: function create() {
    			loading.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},

    		p: noop,

    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};
    }

    // (43:2) {#if $word && $word.id === params.id}
    function create_if_block$W(ctx) {
    	var h1, t0_value = ctx.$word.english + "", t0, t1, p0, a, t3, t4, section0, h20, t6, p1, strong0, t8, t9_value = ctx.$word.chinese + "", t9, t10, p2, strong1, t12, t13_value = ctx.$word.audio || 'none' + "", t13, t14, h21, t15, t16_value = ctx.$word.lessons.length + "", t16, t17, t18, t19, section1, t20, button, i, t21, t22, updating_open, current, dispose;

    	var itemtaglist = new ItemTagList({
    		props: {
    		type: "words",
    		item: ctx.$word,
    		store: words
    	},
    		$$inline: true
    	});

    	var if_block = (ctx.$word.lessons && ctx.$word.lessons.length > 0) && create_if_block_1$u(ctx);

    	var editword = new EditWord({
    		props: { word: ctx.$word },
    		$$inline: true
    	});

    	function deleteitem_open_binding(value) {
    		ctx.deleteitem_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let deleteitem_props = {
    		id: ctx.$word.id,
    		store: words,
    		type: "word",
    		name: ctx.$word.english
    	};
    	if (ctx.showDelete !== void 0) {
    		deleteitem_props.open = ctx.showDelete;
    	}
    	var deleteitem = new DeleteItem({ props: deleteitem_props, $$inline: true });

    	binding_callbacks.push(() => bind(deleteitem, 'open', deleteitem_open_binding));

    	return {
    		c: function create() {
    			h1 = element("h1");
    			t0 = text(t0_value);
    			t1 = space();
    			p0 = element("p");
    			a = element("a");
    			a.textContent = "←Back to word list";
    			t3 = space();
    			itemtaglist.$$.fragment.c();
    			t4 = space();
    			section0 = element("section");
    			h20 = element("h2");
    			h20.textContent = "Details";
    			t6 = space();
    			p1 = element("p");
    			strong0 = element("strong");
    			strong0.textContent = "Chinese";
    			t8 = text(": ");
    			t9 = text(t9_value);
    			t10 = space();
    			p2 = element("p");
    			strong1 = element("strong");
    			strong1.textContent = "Audio";
    			t12 = text(": ");
    			t13 = text(t13_value);
    			t14 = space();
    			h21 = element("h2");
    			t15 = text("Used in ");
    			t16 = text(t16_value);
    			t17 = text(" Lessons");
    			t18 = space();
    			if (if_block) if_block.c();
    			t19 = space();
    			section1 = element("section");
    			editword.$$.fragment.c();
    			t20 = space();
    			button = element("button");
    			i = element("i");
    			t21 = text("Delete");
    			t22 = space();
    			deleteitem.$$.fragment.c();
    			attr(h1, "class", "title");
    			add_location(h1, file$1s, 43, 4, 1030);
    			attr(a, "href", "#/words");
    			add_location(a, file$1s, 45, 7, 1079);
    			add_location(p0, file$1s, 45, 4, 1076);
    			attr(h20, "class", "title is-4");
    			add_location(h20, file$1s, 49, 6, 1233);
    			add_location(strong0, file$1s, 50, 11, 1280);
    			add_location(p1, file$1s, 50, 8, 1277);
    			add_location(strong1, file$1s, 51, 11, 1337);
    			add_location(p2, file$1s, 51, 8, 1334);
    			attr(h21, "class", "title is-4");
    			add_location(h21, file$1s, 52, 6, 1395);
    			attr(section0, "class", "details svelte-xj6mxc");
    			add_location(section0, file$1s, 48, 4, 1201);
    			attr(i, "class", "fas fa-trash");
    			add_location(i, file$1s, 62, 78, 1822);
    			attr(button, "class", "button is-danger");
    			add_location(button, file$1s, 62, 6, 1750);
    			attr(section1, "class", "buttons svelte-xj6mxc");
    			add_location(section1, file$1s, 60, 4, 1686);
    			dispose = listen(button, "click", ctx.click_handler);
    		},

    		m: function mount(target, anchor) {
    			insert(target, h1, anchor);
    			append(h1, t0);
    			insert(target, t1, anchor);
    			insert(target, p0, anchor);
    			append(p0, a);
    			insert(target, t3, anchor);
    			mount_component(itemtaglist, target, anchor);
    			insert(target, t4, anchor);
    			insert(target, section0, anchor);
    			append(section0, h20);
    			append(section0, t6);
    			append(section0, p1);
    			append(p1, strong0);
    			append(p1, t8);
    			append(p1, t9);
    			append(section0, t10);
    			append(section0, p2);
    			append(p2, strong1);
    			append(p2, t12);
    			append(p2, t13);
    			append(section0, t14);
    			append(section0, h21);
    			append(h21, t15);
    			append(h21, t16);
    			append(h21, t17);
    			append(section0, t18);
    			if (if_block) if_block.m(section0, null);
    			insert(target, t19, anchor);
    			insert(target, section1, anchor);
    			mount_component(editword, section1, null);
    			append(section1, t20);
    			append(section1, button);
    			append(button, i);
    			append(button, t21);
    			append(section1, t22);
    			mount_component(deleteitem, section1, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if ((!current || changed.$word) && t0_value !== (t0_value = ctx.$word.english + "")) {
    				set_data(t0, t0_value);
    			}

    			var itemtaglist_changes = {};
    			if (changed.$word) itemtaglist_changes.item = ctx.$word;
    			if (changed.words) itemtaglist_changes.store = words;
    			itemtaglist.$set(itemtaglist_changes);

    			if ((!current || changed.$word) && t9_value !== (t9_value = ctx.$word.chinese + "")) {
    				set_data(t9, t9_value);
    			}

    			if ((!current || changed.$word) && t13_value !== (t13_value = ctx.$word.audio || 'none' + "")) {
    				set_data(t13, t13_value);
    			}

    			if ((!current || changed.$word) && t16_value !== (t16_value = ctx.$word.lessons.length + "")) {
    				set_data(t16, t16_value);
    			}

    			if (ctx.$word.lessons && ctx.$word.lessons.length > 0) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block_1$u(ctx);
    					if_block.c();
    					if_block.m(section0, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			var editword_changes = {};
    			if (changed.$word) editword_changes.word = ctx.$word;
    			editword.$set(editword_changes);

    			var deleteitem_changes = {};
    			if (changed.$word) deleteitem_changes.id = ctx.$word.id;
    			if (changed.words) deleteitem_changes.store = words;
    			if (changed.$word) deleteitem_changes.name = ctx.$word.english;
    			if (!updating_open && changed.showDelete) {
    				deleteitem_changes.open = ctx.showDelete;
    			}
    			deleteitem.$set(deleteitem_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(itemtaglist.$$.fragment, local);

    			transition_in(editword.$$.fragment, local);

    			transition_in(deleteitem.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(itemtaglist.$$.fragment, local);
    			transition_out(editword.$$.fragment, local);
    			transition_out(deleteitem.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h1);
    				detach(t1);
    				detach(p0);
    				detach(t3);
    			}

    			destroy_component(itemtaglist, detaching);

    			if (detaching) {
    				detach(t4);
    				detach(section0);
    			}

    			if (if_block) if_block.d();

    			if (detaching) {
    				detach(t19);
    				detach(section1);
    			}

    			destroy_component(editword);

    			destroy_component(deleteitem);

    			dispose();
    		}
    	};
    }

    // (54:6) {#if $word.lessons && $word.lessons.length > 0}
    function create_if_block_1$u(ctx) {
    	var each_blocks = [], each_1_lookup = new Map(), each_1_anchor;

    	var each_value = ctx.$word.lessons;

    	const get_key = ctx => ctx.lesson.id;

    	for (var i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$t(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$t(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();

    			each_1_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(target, anchor);

    			insert(target, each_1_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			const each_value = ctx.$word.lessons;
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$t, each_1_anchor, get_each_context$t);
    		},

    		d: function destroy(detaching) {
    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d(detaching);

    			if (detaching) {
    				detach(each_1_anchor);
    			}
    		}
    	};
    }

    // (55:8) {#each $word.lessons as lesson (lesson.id)}
    function create_each_block$t(key_1, ctx) {
    	var li, a, t_value = ctx.lesson.name + "", t, a_href_value;

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			li = element("li");
    			a = element("a");
    			t = text(t_value);
    			attr(a, "href", a_href_value = "#/lesson/" + ctx.lesson.id);
    			add_location(a, file$1s, 55, 14, 1582);
    			add_location(li, file$1s, 55, 10, 1578);
    			this.first = li;
    		},

    		m: function mount(target, anchor) {
    			insert(target, li, anchor);
    			append(li, a);
    			append(a, t);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.$word) && t_value !== (t_value = ctx.lesson.name + "")) {
    				set_data(t, t_value);
    			}

    			if ((changed.$word) && a_href_value !== (a_href_value = "#/lesson/" + ctx.lesson.id)) {
    				attr(a, "href", a_href_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(li);
    			}
    		}
    	};
    }

    function create_fragment$1z(ctx) {
    	var t0, t1, current_block_type_index, if_block1, if_block1_anchor, current;

    	var if_block0 = (ctx.errors) && create_if_block_3$7(ctx);

    	var if_block_creators = [
    		create_if_block$W,
    		create_if_block_2$f
    	];

    	var if_blocks = [];

    	function select_block_type(changed, ctx) {
    		if (ctx.$word && ctx.$word.id === ctx.params.id) return 0;
    		if (!ctx.errors) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(null, ctx))) {
    		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	return {
    		c: function create() {
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    			document.title = "Word Details";
    		},

    		l: function claim(nodes) {
    			throw new Error_1$t("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t0, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert(target, t1, anchor);
    			if (~current_block_type_index) if_blocks[current_block_type_index].m(target, anchor);
    			insert(target, if_block1_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.errors) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    					transition_in(if_block0, 1);
    				} else {
    					if_block0 = create_if_block_3$7(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t1.parentNode, t1);
    				}
    			} else if (if_block0) {
    				group_outros();
    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});
    				check_outros();
    			}

    			var previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(changed, ctx);
    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) if_blocks[current_block_type_index].p(changed, ctx);
    			} else {
    				if (if_block1) {
    					group_outros();
    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});
    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block1 = if_blocks[current_block_type_index];
    					if (!if_block1) {
    						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block1.c();
    					}
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				} else {
    					if_block1 = null;
    				}
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t0);
    			}

    			if (if_block0) if_block0.d(detaching);

    			if (detaching) {
    				detach(t1);
    			}

    			if (~current_block_type_index) if_blocks[current_block_type_index].d(detaching);

    			if (detaching) {
    				detach(if_block1_anchor);
    			}
    		}
    	};
    }

    function instance$1y($$self, $$props, $$invalidate) {
    	let $word;

    	validate_store(word, 'word');
    	component_subscribe($$self, word, $$value => { $word = $$value; $$invalidate('$word', $word); });

    	

      let { params = {} } = $$props;
      let errors = '';
      let showDelete = false;

      onMount(async () => {
        if (!$word || $word.id !== params.id) {
          try {
            await word.get(params.id);
            if ($word === null) push(`/not-found/material/${params.id}`);
          } catch (error) {
            $$invalidate('errors', errors = error);
            notifications.add({ text: 'Could not fetch word from the server', type: 'danger' });
          }
        }
      });

    	const writable_props = ['params'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Word> was created with unknown prop '${key}'`);
    	});

    	function click_handler() { showDelete = true; $$invalidate('showDelete', showDelete); }

    	function deleteitem_open_binding(value) {
    		showDelete = value;
    		$$invalidate('showDelete', showDelete);
    	}

    	$$self.$set = $$props => {
    		if ('params' in $$props) $$invalidate('params', params = $$props.params);
    	};

    	return {
    		params,
    		errors,
    		showDelete,
    		$word,
    		click_handler,
    		deleteitem_open_binding
    	};
    }

    class Word extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1y, create_fragment$1z, safe_not_equal, ["params"]);
    	}

    	get params() {
    		throw new Error_1$t("<Word>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error_1$t("<Word>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/tags/TagForm.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$u } = globals;

    const file$1t = "admin/src/components/tags/TagForm.svelte";

    // (39:2) {#if errors}
    function create_if_block$X(ctx) {
    	var current;

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			error.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(error, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(error, detaching);
    		}
    	};
    }

    function create_fragment$1A(ctx) {
    	var form_1, t0, updating_value, t1, div, button, t3, input1, current, dispose;

    	var if_block = (ctx.errors) && create_if_block$X(ctx);

    	function input0_value_binding(value) {
    		ctx.input0_value_binding.call(null, value);
    		updating_value = true;
    		add_flush_callback(() => updating_value = false);
    	}

    	let input0_props = { type: "text", label: ctx.id ? 'Name' : 'New tag name' };
    	if (ctx.name !== void 0) {
    		input0_props.value = ctx.name;
    	}
    	var input0 = new Input({ props: input0_props, $$inline: true });

    	binding_callbacks.push(() => bind(input0, 'value', input0_value_binding));

    	return {
    		c: function create() {
    			form_1 = element("form");
    			if (if_block) if_block.c();
    			t0 = space();
    			input0.$$.fragment.c();
    			t1 = space();
    			div = element("div");
    			button = element("button");
    			button.textContent = "Save Tag";
    			t3 = space();
    			input1 = element("input");
    			attr(button, "type", "submit");
    			attr(button, "class", "button is-primary");
    			toggle_class(button, "is-loading", ctx.loading);
    			add_location(button, file$1t, 45, 4, 950);
    			attr(input1, "type", "reset");
    			attr(input1, "class", "button");
    			input1.value = "Cancel";
    			add_location(input1, file$1t, 46, 4, 1070);
    			attr(div, "class", "buttons svelte-i7r75e");
    			add_location(div, file$1t, 44, 2, 924);
    			form_1.noValidate = true;
    			add_location(form_1, file$1t, 36, 0, 712);

    			dispose = [
    				listen(form_1, "submit", prevent_default(ctx.handleSubmit)),
    				listen(form_1, "reset", ctx.reset_handler)
    			];
    		},

    		l: function claim(nodes) {
    			throw new Error_1$u("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, form_1, anchor);
    			if (if_block) if_block.m(form_1, null);
    			append(form_1, t0);
    			mount_component(input0, form_1, null);
    			append(form_1, t1);
    			append(form_1, div);
    			append(div, button);
    			ctx.button_binding(button);
    			append(div, t3);
    			append(div, input1);
    			ctx.form_1_binding(form_1);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.errors) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$X(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(form_1, t0);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}

    			var input0_changes = {};
    			if (changed.id) input0_changes.label = ctx.id ? 'Name' : 'New tag name';
    			if (!updating_value && changed.name) {
    				input0_changes.value = ctx.name;
    			}
    			input0.$set(input0_changes);

    			if (changed.loading) {
    				toggle_class(button, "is-loading", ctx.loading);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);

    			transition_in(input0.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(input0.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(form_1);
    			}

    			if (if_block) if_block.d();

    			destroy_component(input0);

    			ctx.button_binding(null);
    			ctx.form_1_binding(null);
    			run_all(dispose);
    		}
    	};
    }

    function instance$1z($$self, $$props, $$invalidate) {
    	

      const dispatch = createEventDispatcher();

      let { name = '', id = null, loading = false, errors, connections = null } = $$props;

      let form;
      let saveButton;

      const handleSubmit = () => {
        const isValid = form.checkValidity();
        if (!isValid) {
          notifications.add({
            text: 'Please fix form errors first.',
            type: 'danger'
          });
          return
        }
        dispatch('submit', { id, name });
      };

    	const writable_props = ['name', 'id', 'loading', 'errors', 'connections'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<TagForm> was created with unknown prop '${key}'`);
    	});

    	function reset_handler(event) {
    		bubble($$self, event);
    	}

    	function input0_value_binding(value) {
    		name = value;
    		$$invalidate('name', name);
    	}

    	function button_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('saveButton', saveButton = $$value);
    		});
    	}

    	function form_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('form', form = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ('name' in $$props) $$invalidate('name', name = $$props.name);
    		if ('id' in $$props) $$invalidate('id', id = $$props.id);
    		if ('loading' in $$props) $$invalidate('loading', loading = $$props.loading);
    		if ('errors' in $$props) $$invalidate('errors', errors = $$props.errors);
    		if ('connections' in $$props) $$invalidate('connections', connections = $$props.connections);
    	};

    	return {
    		name,
    		id,
    		loading,
    		errors,
    		connections,
    		form,
    		saveButton,
    		handleSubmit,
    		reset_handler,
    		input0_value_binding,
    		button_binding,
    		form_1_binding
    	};
    }

    class TagForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1z, create_fragment$1A, safe_not_equal, ["name", "id", "loading", "errors", "connections"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.errors === undefined && !('errors' in props)) {
    			console.warn("<TagForm> was created without expected prop 'errors'");
    		}
    	}

    	get name() {
    		throw new Error_1$u("<TagForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error_1$u("<TagForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get id() {
    		throw new Error_1$u("<TagForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error_1$u("<TagForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loading() {
    		throw new Error_1$u("<TagForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loading(value) {
    		throw new Error_1$u("<TagForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get errors() {
    		throw new Error_1$u("<TagForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set errors(value) {
    		throw new Error_1$u("<TagForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get connections() {
    		throw new Error_1$u("<TagForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set connections(value) {
    		throw new Error_1$u("<TagForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/tags/CreateTag.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$v } = globals;

    function create_fragment$1B(ctx) {
    	var updating_name, current;

    	function tagform_name_binding(value) {
    		ctx.tagform_name_binding.call(null, value);
    		updating_name = true;
    		add_flush_callback(() => updating_name = false);
    	}

    	let tagform_props = {
    		errors: ctx.errors,
    		loading: ctx.loading
    	};
    	if (ctx.name !== void 0) {
    		tagform_props.name = ctx.name;
    	}
    	var tagform = new TagForm({ props: tagform_props, $$inline: true });

    	binding_callbacks.push(() => bind(tagform, 'name', tagform_name_binding));
    	tagform.$on("submit", ctx.handleSubmit);
    	tagform.$on("reset", ctx.reset);

    	return {
    		c: function create() {
    			tagform.$$.fragment.c();
    		},

    		l: function claim(nodes) {
    			throw new Error_1$v("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			mount_component(tagform, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var tagform_changes = {};
    			if (changed.errors) tagform_changes.errors = ctx.errors;
    			if (changed.loading) tagform_changes.loading = ctx.loading;
    			if (!updating_name && changed.name) {
    				tagform_changes.name = ctx.name;
    			}
    			tagform.$set(tagform_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(tagform.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(tagform.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(tagform, detaching);
    		}
    	};
    }

    function instance$1A($$self, $$props, $$invalidate) {
    	let $tags;

    	validate_store(tags, 'tags');
    	component_subscribe($$self, tags, $$value => { $tags = $$value; $$invalidate('$tags', $tags); });

    	

      let name = '';
      let errors = '';
      let loading = false;

      const reset = () => {
        $$invalidate('errors', errors = '');
        $$invalidate('name', name = '');
      };

      const handleSubmit = async ({ detail }) => {
        if (!detail.name) return
        $$invalidate('loading', loading = true);
        try {
          // check if name already exists
          if ($tags && $tags.find(t => t.name === detail.name)) {
            throw new Error$1(`The tag '${detail.name}' already exists.`)
          }
          await tags.create(detail.name);
          notifications.add({ text: `Saved new tag '${detail.name}'`, type: 'success' });
          reset();
        } catch (error) {
          $$invalidate('errors', errors = error);
          notifications.add({
            text: 'Could not save new tag.',
            type: 'danger'
          });
        } finally {
          $$invalidate('loading', loading = false);
        }
      };

    	function tagform_name_binding(value) {
    		name = value;
    		$$invalidate('name', name);
    	}

    	return {
    		name,
    		errors,
    		loading,
    		reset,
    		handleSubmit,
    		tagform_name_binding
    	};
    }

    class CreateTag extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1A, create_fragment$1B, safe_not_equal, []);
    	}
    }

    /* admin/src/components/tags/TagConnectionsList.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$w } = globals;

    const file$1u = "admin/src/components/tags/TagConnectionsList.svelte";

    function get_each_context$u(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.word = list[i];
    	return child_ctx;
    }

    function get_each_context_1$7(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.lesson = list[i];
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.material = list[i];
    	return child_ctx;
    }

    // (63:18) 
    function create_if_block_4$4(ctx) {
    	var current;

    	var loading = new Loading({
    		props: { what: "connections" },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			loading.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},

    		p: noop,

    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};
    }

    // (34:0) {#if $tag && $tag.id === id}
    function create_if_block$Y(ctx) {
    	var t0, t1, if_block2_anchor;

    	var if_block0 = (ctx.$tag.materials.length > 0) && create_if_block_3$8(ctx);

    	var if_block1 = (ctx.$tag.lessons.length > 0) && create_if_block_2$g(ctx);

    	var if_block2 = (ctx.$tag.words.length > 0) && create_if_block_1$v(ctx);

    	return {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert(target, if_block2_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.$tag.materials.length > 0) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    				} else {
    					if_block0 = create_if_block_3$8(ctx);
    					if_block0.c();
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (ctx.$tag.lessons.length > 0) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    				} else {
    					if_block1 = create_if_block_2$g(ctx);
    					if_block1.c();
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (ctx.$tag.words.length > 0) {
    				if (if_block2) {
    					if_block2.p(changed, ctx);
    				} else {
    					if_block2 = create_if_block_1$v(ctx);
    					if_block2.c();
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);

    			if (detaching) {
    				detach(t0);
    			}

    			if (if_block1) if_block1.d(detaching);

    			if (detaching) {
    				detach(t1);
    			}

    			if (if_block2) if_block2.d(detaching);

    			if (detaching) {
    				detach(if_block2_anchor);
    			}
    		}
    	};
    }

    // (36:2) {#if $tag.materials.length > 0}
    function create_if_block_3$8(ctx) {
    	var section, h2, t_1, each_blocks = [], each_1_lookup = new Map();

    	var each_value_2 = ctx.$tag.materials;

    	const get_key = ctx => ctx.material.id;

    	for (var i = 0; i < each_value_2.length; i += 1) {
    		let child_ctx = get_each_context_2(ctx, each_value_2, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_2(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			section = element("section");
    			h2 = element("h2");
    			h2.textContent = "Materials";
    			t_1 = space();

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();
    			attr(h2, "class", "title is-4");
    			add_location(h2, file$1u, 37, 4, 746);
    			attr(section, "class", "materials svelte-189pca3");
    			add_location(section, file$1u, 36, 2, 714);
    		},

    		m: function mount(target, anchor) {
    			insert(target, section, anchor);
    			append(section, h2);
    			append(section, t_1);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(section, null);
    		},

    		p: function update(changed, ctx) {
    			const each_value_2 = ctx.$tag.materials;
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value_2, each_1_lookup, section, destroy_block, create_each_block_2, null, get_each_context_2);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(section);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d();
    		}
    	};
    }

    // (39:4) {#each $tag.materials as material (material.id)}
    function create_each_block_2(key_1, ctx) {
    	var a, t_value = ctx.material.title + "", t, a_href_value;

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			a = element("a");
    			t = text(t_value);
    			attr(a, "href", a_href_value = "#/material/" + ctx.material.id);
    			add_location(a, file$1u, 39, 6, 843);
    			this.first = a;
    		},

    		m: function mount(target, anchor) {
    			insert(target, a, anchor);
    			append(a, t);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.$tag) && t_value !== (t_value = ctx.material.title + "")) {
    				set_data(t, t_value);
    			}

    			if ((changed.$tag) && a_href_value !== (a_href_value = "#/material/" + ctx.material.id)) {
    				attr(a, "href", a_href_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(a);
    			}
    		}
    	};
    }

    // (45:2) {#if $tag.lessons.length > 0}
    function create_if_block_2$g(ctx) {
    	var section, h2, t_1, each_blocks = [], each_1_lookup = new Map();

    	var each_value_1 = ctx.$tag.lessons;

    	const get_key = ctx => ctx.lesson.id;

    	for (var i = 0; i < each_value_1.length; i += 1) {
    		let child_ctx = get_each_context_1$7(ctx, each_value_1, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_1$7(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			section = element("section");
    			h2 = element("h2");
    			h2.textContent = "Lessons";
    			t_1 = space();

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();
    			attr(h2, "class", "title is-4");
    			add_location(h2, file$1u, 46, 4, 997);
    			attr(section, "class", "lessons svelte-189pca3");
    			add_location(section, file$1u, 45, 2, 967);
    		},

    		m: function mount(target, anchor) {
    			insert(target, section, anchor);
    			append(section, h2);
    			append(section, t_1);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(section, null);
    		},

    		p: function update(changed, ctx) {
    			const each_value_1 = ctx.$tag.lessons;
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value_1, each_1_lookup, section, destroy_block, create_each_block_1$7, null, get_each_context_1$7);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(section);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d();
    		}
    	};
    }

    // (48:4) {#each $tag.lessons as lesson (lesson.id)}
    function create_each_block_1$7(key_1, ctx) {
    	var a, t_value = ctx.lesson.name + "", t, a_href_value;

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			a = element("a");
    			t = text(t_value);
    			attr(a, "href", a_href_value = "#/lesson/" + ctx.lesson.id);
    			add_location(a, file$1u, 48, 6, 1086);
    			this.first = a;
    		},

    		m: function mount(target, anchor) {
    			insert(target, a, anchor);
    			append(a, t);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.$tag) && t_value !== (t_value = ctx.lesson.name + "")) {
    				set_data(t, t_value);
    			}

    			if ((changed.$tag) && a_href_value !== (a_href_value = "#/lesson/" + ctx.lesson.id)) {
    				attr(a, "href", a_href_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(a);
    			}
    		}
    	};
    }

    // (54:2) {#if $tag.words.length > 0}
    function create_if_block_1$v(ctx) {
    	var section, h2, t_1, each_blocks = [], each_1_lookup = new Map();

    	var each_value = ctx.$tag.words;

    	const get_key = ctx => ctx.word.id;

    	for (var i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$u(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$u(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			section = element("section");
    			h2 = element("h2");
    			h2.textContent = "Words";
    			t_1 = space();

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();
    			attr(h2, "class", "title is-4");
    			add_location(h2, file$1u, 55, 4, 1229);
    			attr(section, "class", "words svelte-189pca3");
    			add_location(section, file$1u, 54, 2, 1201);
    		},

    		m: function mount(target, anchor) {
    			insert(target, section, anchor);
    			append(section, h2);
    			append(section, t_1);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(section, null);
    		},

    		p: function update(changed, ctx) {
    			const each_value = ctx.$tag.words;
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, section, destroy_block, create_each_block$u, null, get_each_context$u);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(section);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d();
    		}
    	};
    }

    // (57:4) {#each $tag.words as word (word.id)}
    function create_each_block$u(key_1, ctx) {
    	var a, t_value = ctx.word.english + "", t, a_href_value;

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			a = element("a");
    			t = text(t_value);
    			attr(a, "href", a_href_value = "#/word/" + ctx.word.id);
    			add_location(a, file$1u, 57, 6, 1310);
    			this.first = a;
    		},

    		m: function mount(target, anchor) {
    			insert(target, a, anchor);
    			append(a, t);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.$tag) && t_value !== (t_value = ctx.word.english + "")) {
    				set_data(t, t_value);
    			}

    			if ((changed.$tag) && a_href_value !== (a_href_value = "#/word/" + ctx.word.id)) {
    				attr(a, "href", a_href_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(a);
    			}
    		}
    	};
    }

    function create_fragment$1C(ctx) {
    	var section, t, current_block_type_index, if_block, if_block_anchor, current;

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	var if_block_creators = [
    		create_if_block$Y,
    		create_if_block_4$4
    	];

    	var if_blocks = [];

    	function select_block_type(changed, ctx) {
    		if (ctx.$tag && ctx.$tag.id === ctx.id) return 0;
    		if (!ctx.errors) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(null, ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	return {
    		c: function create() {
    			section = element("section");
    			error.$$.fragment.c();
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr(section, "class", "errors svelte-189pca3");
    			add_location(section, file$1u, 29, 0, 590);
    		},

    		l: function claim(nodes) {
    			throw new Error_1$w("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, section, anchor);
    			mount_component(error, section, null);
    			insert(target, t, anchor);
    			if (~current_block_type_index) if_blocks[current_block_type_index].m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);

    			var previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(changed, ctx);
    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) if_blocks[current_block_type_index].p(changed, ctx);
    			} else {
    				if (if_block) {
    					group_outros();
    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});
    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];
    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					}
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);

    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(section);
    			}

    			destroy_component(error);

    			if (detaching) {
    				detach(t);
    			}

    			if (~current_block_type_index) if_blocks[current_block_type_index].d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function instance$1B($$self, $$props, $$invalidate) {
    	let $tag;

    	validate_store(tag, 'tag');
    	component_subscribe($$self, tag, $$value => { $tag = $$value; $$invalidate('$tag', $tag); });

    	

      let { id } = $$props;
      let errors = '';

      onMount(async () => {
        if (!$tag || $tag.id !== id) {
          try {
            await tag.get(id);
          } catch (error) {
            $$invalidate('errors', errors = error);
            notifications.add({ text: 'Could not get related items from server', type: 'danger' });
          }
        }
      });

    	const writable_props = ['id'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<TagConnectionsList> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('id' in $$props) $$invalidate('id', id = $$props.id);
    	};

    	return { id, errors, $tag };
    }

    class TagConnectionsList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1B, create_fragment$1C, safe_not_equal, ["id"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.id === undefined && !('id' in props)) {
    			console.warn("<TagConnectionsList> was created without expected prop 'id'");
    		}
    	}

    	get id() {
    		throw new Error_1$w("<TagConnectionsList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error_1$w("<TagConnectionsList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/tags/EditTag.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$x } = globals;

    const file$1v = "admin/src/components/tags/EditTag.svelte";

    // (42:0) {#if openTag.connections}
    function create_if_block$Z(ctx) {
    	var current;

    	var tagconnectionslist = new TagConnectionsList({
    		props: { id: ctx.openTag.id },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			tagconnectionslist.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(tagconnectionslist, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var tagconnectionslist_changes = {};
    			if (changed.openTag) tagconnectionslist_changes.id = ctx.openTag.id;
    			tagconnectionslist.$set(tagconnectionslist_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(tagconnectionslist.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(tagconnectionslist.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(tagconnectionslist, detaching);
    		}
    	};
    }

    function create_fragment$1D(ctx) {
    	var h2, t1, t2, if_block_anchor, current;

    	var tagform_spread_levels = [
    		{ errors: ctx.errors },
    		{ loading: ctx.loading },
    		ctx.openTag
    	];

    	let tagform_props = {};
    	for (var i = 0; i < tagform_spread_levels.length; i += 1) {
    		tagform_props = assign(tagform_props, tagform_spread_levels[i]);
    	}
    	var tagform = new TagForm({ props: tagform_props, $$inline: true });
    	tagform.$on("submit", ctx.handleSubmit);
    	tagform.$on("reset", ctx.reset);

    	var if_block = (ctx.openTag.connections) && create_if_block$Z(ctx);

    	return {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "Tag details";
    			t1 = space();
    			tagform.$$.fragment.c();
    			t2 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr(h2, "class", "title");
    			add_location(h2, file$1v, 37, 0, 947);
    		},

    		l: function claim(nodes) {
    			throw new Error_1$x("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, h2, anchor);
    			insert(target, t1, anchor);
    			mount_component(tagform, target, anchor);
    			insert(target, t2, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var tagform_changes = (changed.errors || changed.loading || changed.openTag) ? get_spread_update(tagform_spread_levels, [
    									(changed.errors) && { errors: ctx.errors },
    			(changed.loading) && { loading: ctx.loading },
    			(changed.openTag) && ctx.openTag
    								]) : {};
    			tagform.$set(tagform_changes);

    			if (ctx.openTag.connections) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$Z(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(tagform.$$.fragment, local);

    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(tagform.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h2);
    				detach(t1);
    			}

    			destroy_component(tagform, detaching);

    			if (detaching) {
    				detach(t2);
    			}

    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function instance$1C($$self, $$props, $$invalidate) {
    	let $tags;

    	validate_store(tags, 'tags');
    	component_subscribe($$self, tags, $$value => { $tags = $$value; $$invalidate('$tags', $tags); });

    	

      let { openTag } = $$props;
      let errors = '';
      let loading = false;

      const reset = () => {
        $$invalidate('errors', errors = '');
        $$invalidate('openTag', openTag = false);
      };

      const handleSubmit = async ({ detail }) => {
        $$invalidate('loading', loading = true);
        try {
          // check if name already exists
          if ($tags && $tags.find(t => t.name === detail.name)) {
            throw new Error(`The tag '${detail.name}' already exists.`)
          }
          await tags.patch({ id: detail.id, input: { name: detail.name } });
          notifications.add({ text: `Updated tag to '${detail.name}'`, type: 'success' });
          reset();
        } catch (error) {
          $$invalidate('errors', errors = error);
          notifications.add({
            text: 'Could not update tag.',
            type: 'danger'
          });
        } finally {
          $$invalidate('loading', loading = false);
        }
      };

    	const writable_props = ['openTag'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<EditTag> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('openTag' in $$props) $$invalidate('openTag', openTag = $$props.openTag);
    	};

    	return {
    		openTag,
    		errors,
    		loading,
    		reset,
    		handleSubmit
    	};
    }

    class EditTag extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1C, create_fragment$1D, safe_not_equal, ["openTag"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.openTag === undefined && !('openTag' in props)) {
    			console.warn("<EditTag> was created without expected prop 'openTag'");
    		}
    	}

    	get openTag() {
    		throw new Error_1$x("<EditTag>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set openTag(value) {
    		throw new Error_1$x("<EditTag>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/tags/Tags.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$y } = globals;

    const file$1w = "admin/src/components/tags/Tags.svelte";

    function get_each_context$v(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.tag = list[i];
    	return child_ctx;
    }

    // (46:2) {#if $tags && $tags.length > 0}
    function create_if_block_2$h(ctx) {
    	var h2, t0_value = ctx.$tags.length + "", t0, t1, t2, div, each_blocks = [], each_1_lookup = new Map();

    	var each_value = ctx.$tags;

    	const get_key = ctx => ctx.tag.id;

    	for (var i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$v(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$v(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = text(" tags. Click to edit.");
    			t2 = space();
    			div = element("div");

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();
    			attr(h2, "class", "title is-4");
    			add_location(h2, file$1w, 46, 2, 860);
    			attr(div, "class", "field is-grouped is-grouped-multiline");
    			add_location(div, file$1w, 47, 2, 926);
    		},

    		m: function mount(target, anchor) {
    			insert(target, h2, anchor);
    			append(h2, t0);
    			append(h2, t1);
    			insert(target, t2, anchor);
    			insert(target, div, anchor);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(div, null);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.$tags) && t0_value !== (t0_value = ctx.$tags.length + "")) {
    				set_data(t0, t0_value);
    			}

    			const each_value = ctx.$tags;
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, div, destroy_block, create_each_block$v, null, get_each_context$v);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h2);
    				detach(t2);
    				detach(div);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d();
    		}
    	};
    }

    // (55:10) {:else}
    function create_else_block$m(ctx) {
    	var span, t_value = ctx.tag.connections + "", t;

    	return {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr(span, "class", "tag svelte-xf633j");
    			add_location(span, file$1w, 55, 10, 1314);
    		},

    		m: function mount(target, anchor) {
    			insert(target, span, anchor);
    			append(span, t);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.$tags) && t_value !== (t_value = ctx.tag.connections + "")) {
    				set_data(t, t_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(span);
    			}
    		}
    	};
    }

    // (53:10) {#if tag.connections === 0}
    function create_if_block_3$9(ctx) {
    	var span, dispose;

    	function click_handler_1() {
    		return ctx.click_handler_1(ctx);
    	}

    	return {
    		c: function create() {
    			span = element("span");
    			attr(span, "class", "tag is-delete svelte-xf633j");
    			add_location(span, file$1w, 53, 10, 1213);
    			dispose = listen(span, "click", click_handler_1);
    		},

    		m: function mount(target, anchor) {
    			insert(target, span, anchor);
    		},

    		p: function update(changed, new_ctx) {
    			ctx = new_ctx;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(span);
    			}

    			dispose();
    		}
    	};
    }

    // (49:4) {#each $tags as tag (tag.id)}
    function create_each_block$v(key_1, ctx) {
    	var div1, div0, span, t0_value = ctx.tag.name + "", t0, t1, t2, dispose;

    	function click_handler() {
    		return ctx.click_handler(ctx);
    	}

    	function select_block_type(changed, ctx) {
    		if (ctx.tag.connections === 0) return create_if_block_3$9;
    		return create_else_block$m;
    	}

    	var current_block_type = select_block_type(null, ctx);
    	var if_block = current_block_type(ctx);

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			if_block.c();
    			t2 = space();
    			attr(span, "class", "tag is-dark svelte-xf633j");
    			add_location(span, file$1w, 51, 10, 1086);
    			attr(div0, "class", "tags has-addons");
    			add_location(div0, file$1w, 50, 8, 1046);
    			attr(div1, "class", "control");
    			add_location(div1, file$1w, 49, 4, 1016);
    			dispose = listen(span, "click", click_handler);
    			this.first = div1;
    		},

    		m: function mount(target, anchor) {
    			insert(target, div1, anchor);
    			append(div1, div0);
    			append(div0, span);
    			append(span, t0);
    			append(div0, t1);
    			if_block.m(div0, null);
    			append(div1, t2);
    		},

    		p: function update(changed, new_ctx) {
    			ctx = new_ctx;
    			if ((changed.$tags) && t0_value !== (t0_value = ctx.tag.name + "")) {
    				set_data(t0, t0_value);
    			}

    			if (current_block_type === (current_block_type = select_block_type(changed, ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);
    				if (if_block) {
    					if_block.c();
    					if_block.m(div0, null);
    				}
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div1);
    			}

    			if_block.d();
    			dispose();
    		}
    	};
    }

    // (66:2) {#if openTag}
    function create_if_block_1$w(ctx) {
    	var updating_openTag, current;

    	function edittag_openTag_binding(value) {
    		ctx.edittag_openTag_binding.call(null, value);
    		updating_openTag = true;
    		add_flush_callback(() => updating_openTag = false);
    	}

    	let edittag_props = {};
    	if (ctx.openTag !== void 0) {
    		edittag_props.openTag = ctx.openTag;
    	}
    	var edittag = new EditTag({ props: edittag_props, $$inline: true });

    	binding_callbacks.push(() => bind(edittag, 'openTag', edittag_openTag_binding));

    	return {
    		c: function create() {
    			edittag.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(edittag, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var edittag_changes = {};
    			if (!updating_openTag && changed.openTag) {
    				edittag_changes.openTag = ctx.openTag;
    			}
    			edittag.$set(edittag_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(edittag.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(edittag.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(edittag, detaching);
    		}
    	};
    }

    // (65:0) <Modal bind:open={openTag}>
    function create_default_slot$l(ctx) {
    	var if_block_anchor, current;

    	var if_block = (ctx.openTag) && create_if_block_1$w(ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.openTag) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block_1$w(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    // (71:0) {#if deleteTag}
    function create_if_block$_(ctx) {
    	var updating_open, current;

    	function deleteitem_open_binding(value) {
    		ctx.deleteitem_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let deleteitem_props = {
    		id: ctx.deleteTag.id,
    		store: tags,
    		type: "tag",
    		name: ctx.deleteTag.name,
    		next: "/tags"
    	};
    	if (ctx.deleteTag !== void 0) {
    		deleteitem_props.open = ctx.deleteTag;
    	}
    	var deleteitem = new DeleteItem({ props: deleteitem_props, $$inline: true });

    	binding_callbacks.push(() => bind(deleteitem, 'open', deleteitem_open_binding));

    	return {
    		c: function create() {
    			deleteitem.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(deleteitem, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var deleteitem_changes = {};
    			if (changed.deleteTag) deleteitem_changes.id = ctx.deleteTag.id;
    			if (changed.tags) deleteitem_changes.store = tags;
    			if (changed.deleteTag) deleteitem_changes.name = ctx.deleteTag.name;
    			if (!updating_open && changed.deleteTag) {
    				deleteitem_changes.open = ctx.deleteTag;
    			}
    			deleteitem.$set(deleteitem_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(deleteitem.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(deleteitem.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(deleteitem, detaching);
    		}
    	};
    }

    function create_fragment$1E(ctx) {
    	var t0, h1, t2, t3, t4, div, t5, updating_open, t6, if_block1_anchor, current;

    	var createtag = new CreateTag({ $$inline: true });

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	var if_block0 = (ctx.$tags && ctx.$tags.length > 0) && create_if_block_2$h(ctx);

    	function modal_open_binding(value) {
    		ctx.modal_open_binding.call(null, value);
    		updating_open = true;
    		add_flush_callback(() => updating_open = false);
    	}

    	let modal_props = {
    		$$slots: { default: [create_default_slot$l] },
    		$$scope: { ctx }
    	};
    	if (ctx.openTag !== void 0) {
    		modal_props.open = ctx.openTag;
    	}
    	var modal = new Modal({ props: modal_props, $$inline: true });

    	binding_callbacks.push(() => bind(modal, 'open', modal_open_binding));

    	var if_block1 = (ctx.deleteTag) && create_if_block$_(ctx);

    	return {
    		c: function create() {
    			t0 = space();
    			h1 = element("h1");
    			h1.textContent = "Tags";
    			t2 = space();
    			createtag.$$.fragment.c();
    			t3 = space();
    			error.$$.fragment.c();
    			t4 = space();
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t5 = space();
    			modal.$$.fragment.c();
    			t6 = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    			document.title = "Tags";
    			attr(h1, "class", "title");
    			add_location(h1, file$1w, 38, 0, 737);
    			attr(div, "class", "tag-list svelte-xf633j");
    			add_location(div, file$1w, 44, 0, 801);
    		},

    		l: function claim(nodes) {
    			throw new Error_1$y("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t0, anchor);
    			insert(target, h1, anchor);
    			insert(target, t2, anchor);
    			mount_component(createtag, target, anchor);
    			insert(target, t3, anchor);
    			mount_component(error, target, anchor);
    			insert(target, t4, anchor);
    			insert(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			insert(target, t5, anchor);
    			mount_component(modal, target, anchor);
    			insert(target, t6, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert(target, if_block1_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);

    			if (ctx.$tags && ctx.$tags.length > 0) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    				} else {
    					if_block0 = create_if_block_2$h(ctx);
    					if_block0.c();
    					if_block0.m(div, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			var modal_changes = {};
    			if (changed.$$scope || changed.openTag) modal_changes.$$scope = { changed, ctx };
    			if (!updating_open && changed.openTag) {
    				modal_changes.open = ctx.openTag;
    			}
    			modal.$set(modal_changes);

    			if (ctx.deleteTag) {
    				if (if_block1) {
    					if_block1.p(changed, ctx);
    					transition_in(if_block1, 1);
    				} else {
    					if_block1 = create_if_block$_(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();
    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(createtag.$$.fragment, local);

    			transition_in(error.$$.fragment, local);

    			transition_in(modal.$$.fragment, local);

    			transition_in(if_block1);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(createtag.$$.fragment, local);
    			transition_out(error.$$.fragment, local);
    			transition_out(modal.$$.fragment, local);
    			transition_out(if_block1);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t0);
    				detach(h1);
    				detach(t2);
    			}

    			destroy_component(createtag, detaching);

    			if (detaching) {
    				detach(t3);
    			}

    			destroy_component(error, detaching);

    			if (detaching) {
    				detach(t4);
    				detach(div);
    			}

    			if (if_block0) if_block0.d();

    			if (detaching) {
    				detach(t5);
    			}

    			destroy_component(modal, detaching);

    			if (detaching) {
    				detach(t6);
    			}

    			if (if_block1) if_block1.d(detaching);

    			if (detaching) {
    				detach(if_block1_anchor);
    			}
    		}
    	};
    }

    function instance$1D($$self, $$props, $$invalidate) {
    	let $tags;

    	validate_store(tags, 'tags');
    	component_subscribe($$self, tags, $$value => { $tags = $$value; $$invalidate('$tags', $tags); });

    	

      let errors = '';
      let openTag;
      let deleteTag;

      onMount(async () => {
        try {
          await tags.get();
        } catch (error) {
          $$invalidate('errors', errors = error);
          notifications.add({ text: "Coudn't load tags from server", type: 'danger' });
        }
      });

    	function click_handler({ tag }) { openTag = tag; $$invalidate('openTag', openTag); }

    	function click_handler_1({ tag }) { deleteTag = tag; $$invalidate('deleteTag', deleteTag); }

    	function edittag_openTag_binding(value) {
    		openTag = value;
    		$$invalidate('openTag', openTag);
    	}

    	function modal_open_binding(value) {
    		openTag = value;
    		$$invalidate('openTag', openTag);
    	}

    	function deleteitem_open_binding(value) {
    		deleteTag = value;
    		$$invalidate('deleteTag', deleteTag);
    	}

    	return {
    		errors,
    		openTag,
    		deleteTag,
    		$tags,
    		click_handler,
    		click_handler_1,
    		edittag_openTag_binding,
    		modal_open_binding,
    		deleteitem_open_binding
    	};
    }

    class Tags extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1D, create_fragment$1E, safe_not_equal, []);
    	}
    }

    const GET_ME = /* GraphQL */`
{
  me {
    id
    username
  }
}
`;

    const createProfileStore = () => {
      const { subscribe, set } = writable();

      return {
        subscribe,
        get: async () => {
          const getres = await request(GET_ME);
          set(getres.me);
        }
      }
    };

    const me = createProfileStore();

    /* admin/src/components/profile/Profile.svelte generated by Svelte v3.9.2 */

    const file$1x = "admin/src/components/profile/Profile.svelte";

    // (22:2) {:else}
    function create_else_block$n(ctx) {
    	var current;

    	var loading = new Loading({ props: { what: "user" }, $$inline: true });

    	return {
    		c: function create() {
    			loading.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},

    		p: noop,

    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};
    }

    // (14:0) {#if $me}
    function create_if_block$$(ctx) {
    	var current;

    	var dl = new DL({
    		props: {
    		$$slots: { default: [create_default_slot$m] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			dl.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(dl, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var dl_changes = {};
    			if (changed.$$scope || changed.$me) dl_changes.$$scope = { changed, ctx };
    			dl.$set(dl_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(dl.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(dl.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(dl, detaching);
    		}
    	};
    }

    // (15:0) <DL>
    function create_default_slot$m(ctx) {
    	var dt0, t1, dd0, t2_value = ctx.$me.username + "", t2, t3, dt1, t5, dd1, t6_value = ctx.$me.id + "", t6;

    	return {
    		c: function create() {
    			dt0 = element("dt");
    			dt0.textContent = "Username:";
    			t1 = space();
    			dd0 = element("dd");
    			t2 = text(t2_value);
    			t3 = space();
    			dt1 = element("dt");
    			dt1.textContent = "ID:";
    			t5 = space();
    			dd1 = element("dd");
    			t6 = text(t6_value);
    			add_location(dt0, file$1x, 15, 2, 256);
    			add_location(dd0, file$1x, 16, 2, 277);
    			add_location(dt1, file$1x, 18, 2, 304);
    			add_location(dd1, file$1x, 19, 2, 319);
    		},

    		m: function mount(target, anchor) {
    			insert(target, dt0, anchor);
    			insert(target, t1, anchor);
    			insert(target, dd0, anchor);
    			append(dd0, t2);
    			insert(target, t3, anchor);
    			insert(target, dt1, anchor);
    			insert(target, t5, anchor);
    			insert(target, dd1, anchor);
    			append(dd1, t6);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.$me) && t2_value !== (t2_value = ctx.$me.username + "")) {
    				set_data(t2, t2_value);
    			}

    			if ((changed.$me) && t6_value !== (t6_value = ctx.$me.id + "")) {
    				set_data(t6, t6_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(dt0);
    				detach(t1);
    				detach(dd0);
    				detach(t3);
    				detach(dt1);
    				detach(t5);
    				detach(dd1);
    			}
    		}
    	};
    }

    function create_fragment$1F(ctx) {
    	var h1, t_1, current_block_type_index, if_block, if_block_anchor, current;

    	var if_block_creators = [
    		create_if_block$$,
    		create_else_block$n
    	];

    	var if_blocks = [];

    	function select_block_type(changed, ctx) {
    		if (ctx.$me) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(null, ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	return {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "User Profile";
    			t_1 = space();
    			if_block.c();
    			if_block_anchor = empty();
    			attr(h1, "class", "title");
    			add_location(h1, file$1x, 11, 0, 202);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, h1, anchor);
    			insert(target, t_1, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(changed, ctx);
    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(changed, ctx);
    			} else {
    				group_outros();
    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});
    				check_outros();

    				if_block = if_blocks[current_block_type_index];
    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}
    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h1);
    				detach(t_1);
    			}

    			if_blocks[current_block_type_index].d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function instance$1E($$self, $$props, $$invalidate) {
    	let $me;

    	validate_store(me, 'me');
    	component_subscribe($$self, me, $$value => { $me = $$value; $$invalidate('$me', $me); });

    	

      onMount(async () => {
        me.get();
      });

    	return { $me };
    }

    class Profile extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1E, create_fragment$1F, safe_not_equal, []);
    	}
    }

    const ACTIVE_SESSION = /* GraphQL */`
{
  classSessions(where: {stage_in: [Active, Started]}) {
    id
    stage
    startsAt
    startedAt
    endsAt
    group {
      id
    }
  }
}
`;

    const ACTIVE_SESSION_SUB = /* GraphQL */`
subscription {
  classSessions(where: { node: {stage_in: [Active, Started]}}) {
    node {
      id
      stage
      startsAt
      startedAt
      endsAt
      group {
        id
      }
    } 
  }
}
`;

    /* admin/src/components/TextStretcher.svelte generated by Svelte v3.9.2 */

    const file$1y = "admin/src/components/TextStretcher.svelte";

    function create_fragment$1G(ctx) {
    	var div, p, t;

    	return {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			t = text(ctx.text);
    			set_style(p, "font-size", "" + ctx.fontSize + "px");
    			add_location(p, file$1y, 30, 2, 596);
    			attr(div, "class", "wrapper svelte-1e7xmbk");
    			add_location(div, file$1y, 29, 0, 572);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, p);
    			append(p, t);
    			ctx.p_binding(p);
    		},

    		p: function update(changed, ctx) {
    			if (changed.text) {
    				set_data(t, ctx.text);
    			}

    			if (changed.fontSize) {
    				set_style(p, "font-size", "" + ctx.fontSize + "px");
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			ctx.p_binding(null);
    		}
    	};
    }

    function instance$1F($$self, $$props, $$invalidate) {
    	let span;
      let { text = 'this is stretchy', padding = 5 } = $$props;
      let fontSize = 14;
      let { minSize = 14, maxSize = 512 } = $$props;

    	const writable_props = ['text', 'padding', 'minSize', 'maxSize'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<TextStretcher> was created with unknown prop '${key}'`);
    	});

    	function p_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('span', span = $$value);
    		});
    	}

    	$$self.$set = $$props => {
    		if ('text' in $$props) $$invalidate('text', text = $$props.text);
    		if ('padding' in $$props) $$invalidate('padding', padding = $$props.padding);
    		if ('minSize' in $$props) $$invalidate('minSize', minSize = $$props.minSize);
    		if ('maxSize' in $$props) $$invalidate('maxSize', maxSize = $$props.maxSize);
    	};

    	$$self.$$.update = ($$dirty = { span: 1, minSize: 1, fontSize: 1, maxSize: 1 }) => {
    		if ($$dirty.span || $$dirty.minSize || $$dirty.fontSize || $$dirty.maxSize) { if (span) {
            const availableWidth = span.parentNode.clientWidth;
            const currentWidth = span.scrollWidth;
            $$invalidate('fontSize', fontSize = Math.min(
              Math.max(
                minSize,
                ((availableWidth - fontSize * 2) / currentWidth) * fontSize),
              maxSize
            ));
          } }
    	};

    	return {
    		span,
    		text,
    		padding,
    		fontSize,
    		minSize,
    		maxSize,
    		p_binding
    	};
    }

    class TextStretcher extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1F, create_fragment$1G, safe_not_equal, ["text", "padding", "minSize", "maxSize"]);
    	}

    	get text() {
    		throw new Error("<TextStretcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<TextStretcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get padding() {
    		throw new Error("<TextStretcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set padding(value) {
    		throw new Error("<TextStretcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get minSize() {
    		throw new Error("<TextStretcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minSize(value) {
    		throw new Error("<TextStretcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get maxSize() {
    		throw new Error("<TextStretcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set maxSize(value) {
    		throw new Error("<TextStretcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/viewer/PreclassBoard.svelte generated by Svelte v3.9.2 */

    const file$1z = "admin/src/components/viewer/PreclassBoard.svelte";

    // (40:2) {#if absentStudents}
    function create_if_block$10(ctx) {
    	var current;

    	var textstretcher = new TextStretcher({
    		props: {
    		text: "waiting on " + ctx.absentStudents,
    		minSize: "32",
    		maxSize: "156"
    	},
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			textstretcher.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(textstretcher, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var textstretcher_changes = {};
    			if (changed.absentStudents) textstretcher_changes.text = "waiting on " + ctx.absentStudents;
    			textstretcher.$set(textstretcher_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(textstretcher.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(textstretcher.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(textstretcher, detaching);
    		}
    	};
    }

    function create_fragment$1H(ctx) {
    	var main, t0, div, t1, current;

    	var textstretcher0 = new TextStretcher({
    		props: {
    		text: "" + ctx.$session.group.name + " class lesson " + ctx.$session.number,
    		maxSize: "300"
    	},
    		$$inline: true
    	});

    	var textstretcher1 = new TextStretcher({
    		props: {
    		text: "" + (ctx.timeDirection(ctx.$session.startsAt, ctx.$time) > 0 ? 'starts' : 'scheduled to start') + "\n        " + ctx.timeToStart(ctx.$session.startsAt, ctx.$time)
    	},
    		$$inline: true
    	});

    	var if_block = (ctx.absentStudents) && create_if_block$10(ctx);

    	return {
    		c: function create() {
    			main = element("main");
    			textstretcher0.$$.fragment.c();
    			t0 = space();
    			div = element("div");
    			textstretcher1.$$.fragment.c();
    			t1 = space();
    			if (if_block) if_block.c();
    			attr(div, "class", "svelte-1ofj9ck");
    			toggle_class(div, "late", ctx.timeDirection(ctx.$session.startsAt, ctx.$time) < 0);
    			add_location(div, file$1z, 34, 2, 967);
    			attr(main, "class", "svelte-1ofj9ck");
    			add_location(main, file$1z, 32, 0, 864);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, main, anchor);
    			mount_component(textstretcher0, main, null);
    			append(main, t0);
    			append(main, div);
    			mount_component(textstretcher1, div, null);
    			append(main, t1);
    			if (if_block) if_block.m(main, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var textstretcher0_changes = {};
    			if (changed.$session) textstretcher0_changes.text = "" + ctx.$session.group.name + " class lesson " + ctx.$session.number;
    			textstretcher0.$set(textstretcher0_changes);

    			var textstretcher1_changes = {};
    			if (changed.timeDirection || changed.$session || changed.$time || changed.timeToStart) textstretcher1_changes.text = "" + (ctx.timeDirection(ctx.$session.startsAt, ctx.$time) > 0 ? 'starts' : 'scheduled to start') + "\n        " + ctx.timeToStart(ctx.$session.startsAt, ctx.$time);
    			textstretcher1.$set(textstretcher1_changes);

    			if ((changed.timeDirection || changed.$session || changed.$time)) {
    				toggle_class(div, "late", ctx.timeDirection(ctx.$session.startsAt, ctx.$time) < 0);
    			}

    			if (ctx.absentStudents) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$10(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(main, null);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(textstretcher0.$$.fragment, local);

    			transition_in(textstretcher1.$$.fragment, local);

    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(textstretcher0.$$.fragment, local);
    			transition_out(textstretcher1.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(main);
    			}

    			destroy_component(textstretcher0);

    			destroy_component(textstretcher1);

    			if (if_block) if_block.d();
    		}
    	};
    }

    function instance$1G($$self, $$props, $$invalidate) {
    	let $sessionStudents, $session, $time;

    	validate_store(sessionStudents, 'sessionStudents');
    	component_subscribe($$self, sessionStudents, $$value => { $sessionStudents = $$value; $$invalidate('$sessionStudents', $sessionStudents); });
    	validate_store(session, 'session');
    	component_subscribe($$self, session, $$value => { $session = $$value; $$invalidate('$session', $session); });
    	validate_store(time, 'time');
    	component_subscribe($$self, time, $$value => { $time = $$value; $$invalidate('$time', $time); });

    	

      const timeToStart = (startsAt, now) => {
        return formatDistanceStrict(new Date(startsAt), now, { addSuffix: true })
      };
      const timeDirection = (startsAt, now) => {
        return new Date(startsAt) - now
      };

    	let absentStudents;

    	$$self.$$.update = ($$dirty = { $sessionStudents: 1 }) => {
    		if ($$dirty.$sessionStudents) { $$invalidate('absentStudents', absentStudents = $sessionStudents && $sessionStudents.filter(student => {
            return !student.attendance || student.attendance.status !== 'Present'
          }).map(student => (student.englishName || student.chineseName)).join(', ')); }
    	};

    	return {
    		timeToStart,
    		timeDirection,
    		absentStudents,
    		$session,
    		$time
    	};
    }

    class PreclassBoard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1G, create_fragment$1H, safe_not_equal, []);
    	}
    }

    const createPointsStore$1 = () => {
      const { subscribe, update } = writable(null, set => {
        const unsubscribe = session.subscribe(session => {
          if (!session) return
          request(GET_SESSION_POINTS, { classSessionId: session.id })
            .then(response => {
              set(response.points);
            });
        });
        return () => unsubscribe()
      });
      return {
        subscribe,
        update
      }
    };

    const points$1 = createPointsStore$1();

    /* admin/src/components/viewer/Star.svelte generated by Svelte v3.9.2 */

    const file$1A = "admin/src/components/viewer/Star.svelte";

    // (43:2) {#if number}
    function create_if_block$11(ctx) {
    	var text_1, t;

    	return {
    		c: function create() {
    			text_1 = svg_element("text");
    			t = text(ctx.number);
    			attr(text_1, "x", "50%");
    			attr(text_1, "y", "60%");
    			attr(text_1, "dominant-baseline", "middle");
    			attr(text_1, "text-anchor", "middle");
    			attr(text_1, "fill", "black");
    			attr(text_1, "font-size", "0.8rem");
    			add_location(text_1, file$1A, 43, 2, 1549);
    		},

    		m: function mount(target, anchor) {
    			insert(target, text_1, anchor);
    			append(text_1, t);
    		},

    		p: function update(changed, ctx) {
    			if (changed.number) {
    				set_data(t, ctx.number);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(text_1);
    			}
    		}
    	};
    }

    function create_fragment$1I(ctx) {
    	var svg, path;

    	var if_block = (ctx.number) && create_if_block$11(ctx);

    	return {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			if (if_block) if_block.c();
    			attr(path, "d", "M32.143 12.403c-.494-1.545-3.213-1.898-6.092-2.279-1.578-.207-3.371-.441-3.912-.842-.545-.398-1.305-2.035-1.977-3.482C18.94 3.169 17.783.687 16.165.683l-.03-.005c-1.604.027-2.773 2.479-4.016 5.082-.685 1.439-1.464 3.07-2.007 3.465-.549.391-2.342.611-3.925.803-2.876.35-5.599.678-6.107 2.215s1.479 3.426 3.585 5.422c1.156 1.098 2.465 2.342 2.671 2.982s-.143 2.416-.448 3.977c-.558 2.844-1.085 5.537.219 6.5.312.223.704.336 1.167.326 1.331-.021 3.246-1.057 5.097-2.061 1.387-.758 2.96-1.613 3.66-1.621.677 0 2.255.879 3.647 1.654 1.893 1.051 3.852 2.139 5.185 2.117.416-.006.771-.113 1.061-.322 1.312-.945.812-3.637.285-6.492-.29-1.564-.615-3.344-.41-3.984.212-.637 1.536-1.865 2.703-2.955 2.125-1.977 4.131-3.838 3.641-5.383z");
    			add_location(path, file$1A, 40, 2, 790);
    			attr(svg, "class", "star svelte-i1zisd");
    			attr(svg, "xmlns", "http://www.w3.org/2000/svg");
    			set_style(svg, "--hue", ctx.hue(ctx.index));
    			set_style(svg, "--size", ctx.size);
    			attr(svg, "viewBox", "0 0 32.218 32.218");
    			toggle_class(svg, "group", ctx.group);
    			add_location(svg, file$1A, 38, 0, 648);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, svg, anchor);
    			append(svg, path);
    			if (if_block) if_block.m(svg, null);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.number) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$11(ctx);
    					if_block.c();
    					if_block.m(svg, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (changed.index) {
    				set_style(svg, "--hue", ctx.hue(ctx.index));
    			}

    			if (changed.size) {
    				set_style(svg, "--size", ctx.size);
    			}

    			if (changed.group) {
    				toggle_class(svg, "group", ctx.group);
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(svg);
    			}

    			if (if_block) if_block.d();
    		}
    	};
    }

    function instance$1H($$self, $$props, $$invalidate) {
    	let { size = '8rem', group = false, index = 0, number = index + 1 } = $$props;

      const hue = (index) => index * 30;

    	const writable_props = ['size', 'group', 'index', 'number'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Star> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('size' in $$props) $$invalidate('size', size = $$props.size);
    		if ('group' in $$props) $$invalidate('group', group = $$props.group);
    		if ('index' in $$props) $$invalidate('index', index = $$props.index);
    		if ('number' in $$props) $$invalidate('number', number = $$props.number);
    	};

    	return { size, group, index, number, hue };
    }

    class Star extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1H, create_fragment$1I, safe_not_equal, ["size", "group", "index", "number"]);
    	}

    	get size() {
    		throw new Error("<Star>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set size(value) {
    		throw new Error("<Star>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get group() {
    		throw new Error("<Star>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set group(value) {
    		throw new Error("<Star>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get index() {
    		throw new Error("<Star>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set index(value) {
    		throw new Error("<Star>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get number() {
    		throw new Error("<Star>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set number(value) {
    		throw new Error("<Star>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/viewer/ScoreboardRow.svelte generated by Svelte v3.9.2 */

    const file$1B = "admin/src/components/viewer/ScoreboardRow.svelte";

    function get_each_context$w(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.point = list[i];
    	child_ctx.i = i;
    	return child_ctx;
    }

    // (91:4) {#if student.attendance && student.attendance.status !== 'Absent'}
    function create_if_block$12(ctx) {
    	var each_1_anchor, current;

    	var each_value = { length: ctx.pointsTally };

    	var each_blocks = [];

    	for (var i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$w(get_each_context$w(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	return {
    		c: function create() {
    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			for (var i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert(target, each_1_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (changed.pointsTally) {
    				each_value = { length: ctx.pointsTally };

    				for (var i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$w(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(changed, child_ctx);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$w(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();
    				for (i = each_value.length; i < each_blocks.length; i += 1) out(i);
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

    			current = true;
    		},

    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);
    			for (let i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);

    			if (detaching) {
    				detach(each_1_anchor);
    			}
    		}
    	};
    }

    // (92:10) {#each { length: pointsTally } as point, i}
    function create_each_block$w(ctx) {
    	var div, t, div_intro, current;

    	var star = new Star({
    		props: { index: ctx.i, size: "5rem" },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			div = element("div");
    			star.$$.fragment.c();
    			t = space();
    			add_location(div, file$1B, 92, 12, 1838);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			mount_component(star, div, null);
    			append(div, t);
    			current = true;
    		},

    		p: noop,

    		i: function intro(local) {
    			if (current) return;
    			transition_in(star.$$.fragment, local);

    			if (!div_intro) {
    				add_render_callback(() => {
    					div_intro = create_in_transition(div, fly, { x: -400 });
    					div_intro.start();
    				});
    			}

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(star.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			destroy_component(star);
    		}
    	};
    }

    function create_fragment$1J(ctx) {
    	var li, div0, span, t0_value = ctx.student.englishName || ctx.student.chineseName + "", t0, t1, t2, div1, current;

    	var if_block = (ctx.student.attendance && ctx.student.attendance.status !== 'Absent') && create_if_block$12(ctx);

    	return {
    		c: function create() {
    			li = element("li");
    			div0 = element("div");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			if (if_block) if_block.c();
    			t2 = space();
    			div1 = element("div");
    			attr(span, "class", "name svelte-1jjtw95");
    			toggle_class(span, "glow", ctx.glow);
    			toggle_class(span, "absent", !ctx.student.attendance || ctx.student.attendance.status === 'Absent');
    			add_location(span, file$1B, 87, 4, 1529);
    			attr(div0, "class", "content svelte-1jjtw95");
    			add_location(div0, file$1B, 86, 2, 1503);
    			attr(div1, "class", "bg svelte-1jjtw95");
    			toggle_class(div1, "glow", ctx.glow);
    			add_location(div1, file$1B, 98, 2, 1975);
    			attr(li, "class", "svelte-1jjtw95");
    			add_location(li, file$1B, 85, 0, 1496);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, li, anchor);
    			append(li, div0);
    			append(div0, span);
    			append(span, t0);
    			append(div0, t1);
    			if (if_block) if_block.m(div0, null);
    			append(li, t2);
    			append(li, div1);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if ((!current || changed.student) && t0_value !== (t0_value = ctx.student.englishName || ctx.student.chineseName + "")) {
    				set_data(t0, t0_value);
    			}

    			if (changed.glow) {
    				toggle_class(span, "glow", ctx.glow);
    			}

    			if (changed.student) {
    				toggle_class(span, "absent", !ctx.student.attendance || ctx.student.attendance.status === 'Absent');
    			}

    			if (ctx.student.attendance && ctx.student.attendance.status !== 'Absent') {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$12(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div0, null);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}

    			if (changed.glow) {
    				toggle_class(div1, "glow", ctx.glow);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(li);
    			}

    			if (if_block) if_block.d();
    		}
    	};
    }

    function instance$1I($$self, $$props, $$invalidate) {
    	let $points;

    	validate_store(points$1, 'points');
    	component_subscribe($$self, points$1, $$value => { $points = $$value; $$invalidate('$points', $points); });

    	
      let { student, sessionId, glow = false } = $$props;

    	const writable_props = ['student', 'sessionId', 'glow'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<ScoreboardRow> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('student' in $$props) $$invalidate('student', student = $$props.student);
    		if ('sessionId' in $$props) $$invalidate('sessionId', sessionId = $$props.sessionId);
    		if ('glow' in $$props) $$invalidate('glow', glow = $$props.glow);
    	};

    	let pointsTally;

    	$$self.$$.update = ($$dirty = { $points: 1, student: 1 }) => {
    		if ($$dirty.$points || $$dirty.student) { $$invalidate('pointsTally', pointsTally = $points ? $points.reduce((sum, point) => {
            if (point.student.id !== student.id) return sum
            return sum + point.value
          }, 0) : 0); }
    	};

    	return { student, sessionId, glow, pointsTally };
    }

    class ScoreboardRow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1I, create_fragment$1J, safe_not_equal, ["student", "sessionId", "glow"]);

    		const { ctx } = this.$$;
    		const props = options.props || {};
    		if (ctx.student === undefined && !('student' in props)) {
    			console.warn("<ScoreboardRow> was created without expected prop 'student'");
    		}
    		if (ctx.sessionId === undefined && !('sessionId' in props)) {
    			console.warn("<ScoreboardRow> was created without expected prop 'sessionId'");
    		}
    	}

    	get student() {
    		throw new Error("<ScoreboardRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set student(value) {
    		throw new Error("<ScoreboardRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sessionId() {
    		throw new Error("<ScoreboardRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sessionId(value) {
    		throw new Error("<ScoreboardRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get glow() {
    		throw new Error("<ScoreboardRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set glow(value) {
    		throw new Error("<ScoreboardRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/viewer/Scoreboard.svelte generated by Svelte v3.9.2 */

    const file$1C = "admin/src/components/viewer/Scoreboard.svelte";

    function get_each_context$x(ctx, list, i) {
    	const child_ctx = Object.create(ctx);
    	child_ctx.student = list[i];
    	return child_ctx;
    }

    // (74:0) {#if $sessionStudents}
    function create_if_block$13(ctx) {
    	var section, ul, each_blocks = [], each_1_lookup = new Map(), current;

    	var each_value = ctx.$sessionStudents;

    	const get_key = ctx => ctx.student.id;

    	for (var i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$x(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$x(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			section = element("section");
    			ul = element("ul");

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();
    			attr(ul, "class", "svelte-1wgwl9x");
    			add_location(ul, file$1C, 75, 2, 1886);
    			attr(section, "class", "scoreboard svelte-1wgwl9x");
    			add_location(section, file$1C, 74, 0, 1855);
    		},

    		m: function mount(target, anchor) {
    			insert(target, section, anchor);
    			append(section, ul);

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(ul, null);

    			current = true;
    		},

    		p: function update(changed, ctx) {
    			const each_value = ctx.$sessionStudents;

    			group_outros();
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$x, null, get_each_context$x);
    			check_outros();
    		},

    		i: function intro(local) {
    			if (current) return;
    			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

    			current = true;
    		},

    		o: function outro(local) {
    			for (i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(section);
    			}

    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d();
    		}
    	};
    }

    // (77:4) {#each $sessionStudents as student (student.id)}
    function create_each_block$x(key_1, ctx) {
    	var first, current;

    	var scoreboardrow = new ScoreboardRow({
    		props: {
    		student: ctx.student,
    		sessionId: ctx.$sessionId,
    		glow: ctx.newPoint && ctx.newPoint.student.id === ctx.student.id
    	},
    		$$inline: true
    	});

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			first = empty();
    			scoreboardrow.$$.fragment.c();
    			this.first = first;
    		},

    		m: function mount(target, anchor) {
    			insert(target, first, anchor);
    			mount_component(scoreboardrow, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var scoreboardrow_changes = {};
    			if (changed.$sessionStudents) scoreboardrow_changes.student = ctx.student;
    			if (changed.$sessionId) scoreboardrow_changes.sessionId = ctx.$sessionId;
    			if (changed.newPoint || changed.$sessionStudents) scoreboardrow_changes.glow = ctx.newPoint && ctx.newPoint.student.id === ctx.student.id;
    			scoreboardrow.$set(scoreboardrow_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(scoreboardrow.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(scoreboardrow.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(first);
    			}

    			destroy_component(scoreboardrow, detaching);
    		}
    	};
    }

    function create_fragment$1K(ctx) {
    	var h2, t0_value = ctx.$session.group.name + "", t0, t1, t2_value = ctx.$session.number + "", t2, t3, if_block_anchor, current;

    	var if_block = (ctx.$sessionStudents) && create_if_block$13(ctx);

    	return {
    		c: function create() {
    			h2 = element("h2");
    			t0 = text(t0_value);
    			t1 = text(" class lesson ");
    			t2 = text(t2_value);
    			t3 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr(h2, "class", "title");
    			add_location(h2, file$1C, 71, 0, 1755);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, h2, anchor);
    			append(h2, t0);
    			append(h2, t1);
    			append(h2, t2);
    			insert(target, t3, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if ((!current || changed.$session) && t0_value !== (t0_value = ctx.$session.group.name + "")) {
    				set_data(t0, t0_value);
    			}

    			if ((!current || changed.$session) && t2_value !== (t2_value = ctx.$session.number + "")) {
    				set_data(t2, t2_value);
    			}

    			if (ctx.$sessionStudents) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$13(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h2);
    				detach(t3);
    			}

    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function instance$1J($$self, $$props, $$invalidate) {
    	let $sessionStudents, $session, $sessionId;

    	validate_store(sessionStudents, 'sessionStudents');
    	component_subscribe($$self, sessionStudents, $$value => { $sessionStudents = $$value; $$invalidate('$sessionStudents', $sessionStudents); });
    	validate_store(session, 'session');
    	component_subscribe($$self, session, $$value => { $session = $$value; $$invalidate('$session', $session); });
    	validate_store(sessionId, 'sessionId');
    	component_subscribe($$self, sessionId, $$value => { $sessionId = $$value; $$invalidate('$sessionId', $sessionId); });

    	

      let newPoint = null;

      const yay = new Audio('sounds/ui-confirmation-alert-a5min.wav');
      const boo = new Audio('sounds/quick-fart.wav');
      const opening = new Audio('sounds/gamelan_glissando_upward_002_538.mp3');
      onMount(() => {
        opening.play();
        const subscription = ws
          .request({
            query: POINTS_SUB,
            variables: { classSessionId: $session.id }
          })
          .subscribe({
            next(message) {
              if (message.data && message.data.points) {
                const { node, mutation, previousValues } = message.data.points;
                if (mutation === 'CREATED') pointAdded(node);
                if (mutation === 'DELETED') {
                  points$1.update(previous => {
                    return previous.filter(point => point.id !== previousValues.id)
                  });
                }
              }
            }
          });
        return () => subscription && subscription.unsubscribe()
      });
      const setNewPoint = point => {
        $$invalidate('newPoint', newPoint = point);
        setTimeout(() => {
          $$invalidate('newPoint', newPoint = null);
        }, 1000);
      };

      const pointAdded = point => {
        setNewPoint(point);
        if (point.value > 0) {
          yay.play();
        } else {
          boo.play();
        }

        points$1.update(previous => {
          return [point, ...previous]
        });
      };

    	$$self.$$.update = ($$dirty = { $sessionStudents: 1 }) => {
    		if ($$dirty.$sessionStudents) { console.log($sessionStudents); }
    	};

    	return {
    		newPoint,
    		$sessionStudents,
    		$session,
    		$sessionId
    	};
    }

    class Scoreboard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1J, create_fragment$1K, safe_not_equal, []);
    	}
    }

    /* admin/src/components/viewer/ResultsBoard.svelte generated by Svelte v3.9.2 */
    const { Object: Object_1$2 } = globals;

    const file$1D = "admin/src/components/viewer/ResultsBoard.svelte";

    function get_each_context$y(ctx, list, i) {
    	const child_ctx = Object_1$2.create(ctx);
    	child_ctx.group = list[i];
    	child_ctx.i = i;
    	return child_ctx;
    }

    // (118:2) {:else}
    function create_else_block_1$3(ctx) {
    	var current;

    	var loading = new Loading({
    		props: { what: "results" },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			loading.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},

    		p: noop,

    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};
    }

    // (108:2) {#if results}
    function create_if_block$14(ctx) {
    	var each_blocks = [], each_1_lookup = new Map(), each_1_anchor;

    	var each_value = ctx.groupedResults;

    	const get_key = ctx => ctx.group.total;

    	for (var i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$y(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$y(key, child_ctx));
    	}

    	return {
    		c: function create() {
    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();

    			each_1_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(target, anchor);

    			insert(target, each_1_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			const each_value = ctx.groupedResults;
    			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$y, each_1_anchor, get_each_context$y);
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d(detaching);

    			if (detaching) {
    				detach(each_1_anchor);
    			}
    		}
    	};
    }

    // (114:6) {:else}
    function create_else_block$o(ctx) {
    	var p, t0_value = ctx.group.total + "", t0, t1, t2_value = ctx.listNames(ctx.group.students) + "", t2;

    	return {
    		c: function create() {
    			p = element("p");
    			t0 = text(t0_value);
    			t1 = text(" stars: ");
    			t2 = text(t2_value);
    			attr(p, "class", "svelte-3ys7yi");
    			add_location(p, file$1D, 114, 8, 2798);
    		},

    		m: function mount(target, anchor) {
    			insert(target, p, anchor);
    			append(p, t0);
    			append(p, t1);
    			append(p, t2);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.groupedResults) && t0_value !== (t0_value = ctx.group.total + "")) {
    				set_data(t0, t0_value);
    			}

    			if ((changed.groupedResults) && t2_value !== (t2_value = ctx.listNames(ctx.group.students) + "")) {
    				set_data(t2, t2_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(p);
    			}
    		}
    	};
    }

    // (110:6) {#if i === 0}
    function create_if_block_1$x(ctx) {
    	var div, p, i, t0, t1_value = ctx.group.total + "", t1, t2, t3_value = ctx.listNames(ctx.group.students) + "", t3, t4;

    	return {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			i = element("i");
    			t0 = text("×");
    			t1 = text(t1_value);
    			t2 = space();
    			t3 = text(t3_value);
    			t4 = space();
    			attr(i, "class", "fas fa-star bounce svelte-3ys7yi");
    			add_location(i, file$1D, 111, 25, 2674);
    			attr(p, "class", "big svelte-3ys7yi");
    			add_location(p, file$1D, 111, 10, 2659);
    			attr(div, "class", "winner svelte-3ys7yi");
    			add_location(div, file$1D, 110, 8, 2628);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, p);
    			append(p, i);
    			append(p, t0);
    			append(p, t1);
    			append(p, t2);
    			append(p, t3);
    			append(div, t4);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.groupedResults) && t1_value !== (t1_value = ctx.group.total + "")) {
    				set_data(t1, t1_value);
    			}

    			if ((changed.groupedResults) && t3_value !== (t3_value = ctx.listNames(ctx.group.students) + "")) {
    				set_data(t3, t3_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}
    		}
    	};
    }

    // (109:4) {#each groupedResults as group, i (group.total)}
    function create_each_block$y(key_1, ctx) {
    	var first, if_block_anchor;

    	function select_block_type_1(changed, ctx) {
    		if (ctx.i === 0) return create_if_block_1$x;
    		return create_else_block$o;
    	}

    	var current_block_type = select_block_type_1(null, ctx);
    	var if_block = current_block_type(ctx);

    	return {
    		key: key_1,

    		first: null,

    		c: function create() {
    			first = empty();
    			if_block.c();
    			if_block_anchor = empty();
    			this.first = first;
    		},

    		m: function mount(target, anchor) {
    			insert(target, first, anchor);
    			if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    		},

    		p: function update(changed, ctx) {
    			if (current_block_type === (current_block_type = select_block_type_1(changed, ctx)) && if_block) {
    				if_block.p(changed, ctx);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);
    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(first);
    			}

    			if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function create_fragment$1L(ctx) {
    	var audio, source, t0, h2, t1_value = ctx.$session.group.name + "", t1, t2, t3_value = ctx.$session.number + "", t3, t4, t5, t6, section, current_block_type_index, if_block, t7, span, current;

    	var if_block_creators = [
    		create_if_block$14,
    		create_else_block_1$3
    	];

    	var if_blocks = [];

    	function select_block_type(changed, ctx) {
    		if (ctx.results) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(null, ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	return {
    		c: function create() {
    			audio = element("audio");
    			source = element("source");
    			t0 = space();
    			h2 = element("h2");
    			t1 = text(t1_value);
    			t2 = text(" class lesson ");
    			t3 = text(t3_value);
    			t4 = text(" ended ");
    			t5 = text(ctx.endedDistance);
    			t6 = space();
    			section = element("section");
    			if_block.c();
    			t7 = space();
    			span = element("span");
    			attr(source, "type", "audio/mp3");
    			attr(source, "src", "sounds/gamelan_glissando_downward_004_536.mp3");
    			add_location(source, file$1D, 101, 2, 2318);
    			attr(audio, "preload", "");
    			audio.autoplay = true;
    			add_location(audio, file$1D, 100, 0, 2291);
    			attr(h2, "class", "title");
    			add_location(h2, file$1D, 104, 0, 2406);
    			attr(section, "class", "results svelte-3ys7yi");
    			add_location(section, file$1D, 106, 0, 2505);
    			attr(span, "class", "bounce");
    			add_location(span, file$1D, 122, 0, 2939);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, audio, anchor);
    			append(audio, source);
    			insert(target, t0, anchor);
    			insert(target, h2, anchor);
    			append(h2, t1);
    			append(h2, t2);
    			append(h2, t3);
    			append(h2, t4);
    			append(h2, t5);
    			insert(target, t6, anchor);
    			insert(target, section, anchor);
    			if_blocks[current_block_type_index].m(section, null);
    			insert(target, t7, anchor);
    			insert(target, span, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if ((!current || changed.$session) && t1_value !== (t1_value = ctx.$session.group.name + "")) {
    				set_data(t1, t1_value);
    			}

    			if ((!current || changed.$session) && t3_value !== (t3_value = ctx.$session.number + "")) {
    				set_data(t3, t3_value);
    			}

    			if (!current || changed.endedDistance) {
    				set_data(t5, ctx.endedDistance);
    			}

    			var previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(changed, ctx);
    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(changed, ctx);
    			} else {
    				group_outros();
    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});
    				check_outros();

    				if_block = if_blocks[current_block_type_index];
    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}
    				transition_in(if_block, 1);
    				if_block.m(section, null);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(audio);
    				detach(t0);
    				detach(h2);
    				detach(t6);
    				detach(section);
    			}

    			if_blocks[current_block_type_index].d();

    			if (detaching) {
    				detach(t7);
    				detach(span);
    			}
    		}
    	};
    }

    function instance$1K($$self, $$props, $$invalidate) {
    	let $session, $time;

    	validate_store(session, 'session');
    	component_subscribe($$self, session, $$value => { $session = $$value; $$invalidate('$session', $session); });
    	validate_store(time, 'time');
    	component_subscribe($$self, time, $$value => { $time = $$value; $$invalidate('$time', $time); });

    	

      let results = null;

      onMount(async () => {
        $$invalidate('results', results = await getResults($session.id));
      });

      const groupByPoints = results => {
        if (!results || results.length === 0) return []
        const grouped = results.reduce((acc, student) => {
          const group = student.pointsTally;
          acc[group] = acc[group] || [];
          acc[group].push(student);
          return acc
        }, {});
        const sortedPoints = Object.keys(grouped).sort((a, b) => b - a);
        return sortedPoints.map((point, i) => {
          return { total: parseInt(point), students: grouped[point] }
        })
      };
      const listNames = group => {
        const names = group.map(x => x.student.englishName || x.student.chineseName);
        return [names.slice(0, -1).join(', '), names.slice(-1)[0]].join(names.length < 2 ? '' : ' and ')
      };

    	let endedDistance, groupedResults;

    	$$self.$$.update = ($$dirty = { $session: 1, $time: 1, results: 1 }) => {
    		if ($$dirty.$session || $$dirty.$time) { $$invalidate('endedDistance', endedDistance = formatDistance$1(new Date($session.endedAt), new Date($time), { addSuffix: true })); }
    		if ($$dirty.results) { $$invalidate('groupedResults', groupedResults = groupByPoints(results)); }
    	};

    	return {
    		results,
    		listNames,
    		$session,
    		endedDistance,
    		groupedResults
    	};
    }

    class ResultsBoard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1K, create_fragment$1L, safe_not_equal, []);
    	}
    }

    /* admin/src/components/viewer/Viewer.svelte generated by Svelte v3.9.2 */

    const file$1E = "admin/src/components/viewer/Viewer.svelte";

    // (55:41) 
    function create_if_block_4$5(ctx) {
    	var current;

    	var scoreboard = new Scoreboard({ $$inline: true });

    	return {
    		c: function create() {
    			scoreboard.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(scoreboard, target, anchor);
    			current = true;
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(scoreboard.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(scoreboard.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(scoreboard, detaching);
    		}
    	};
    }

    // (53:40) 
    function create_if_block_3$a(ctx) {
    	var current;

    	var preclassboard = new PreclassBoard({ $$inline: true });

    	return {
    		c: function create() {
    			preclassboard.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(preclassboard, target, anchor);
    			current = true;
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(preclassboard.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(preclassboard.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(preclassboard, detaching);
    		}
    	};
    }

    // (51:22) 
    function create_if_block_2$i(ctx) {
    	var current;

    	var loading = new Loading({
    		props: { what: "session" },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			loading.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(loading, target, anchor);
    			current = true;
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(loading.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(loading.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(loading, detaching);
    		}
    	};
    }

    // (49:2) {#if !$sessionId}
    function create_if_block_1$y(ctx) {
    	var h2;

    	return {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "No active session found";
    			attr(h2, "class", "title");
    			add_location(h2, file$1E, 49, 4, 1313);
    		},

    		m: function mount(target, anchor) {
    			insert(target, h2, anchor);
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(h2);
    			}
    		}
    	};
    }

    // (59:2) {#if $session && $session.stage === 'Ended'}
    function create_if_block$15(ctx) {
    	var current;

    	var resultsboard = new ResultsBoard({ $$inline: true });

    	return {
    		c: function create() {
    			resultsboard.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(resultsboard, target, anchor);
    			current = true;
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(resultsboard.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(resultsboard.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(resultsboard, detaching);
    		}
    	};
    }

    function create_fragment$1M(ctx) {
    	var link, style, t1, div, current_block_type_index, if_block0, t2, current;

    	var if_block_creators = [
    		create_if_block_1$y,
    		create_if_block_2$i,
    		create_if_block_3$a,
    		create_if_block_4$5
    	];

    	var if_blocks = [];

    	function select_block_type(changed, ctx) {
    		if (!ctx.$sessionId) return 0;
    		if (!ctx.$session) return 1;
    		if (ctx.$session.stage === 'Active') return 2;
    		if (ctx.$session.stage === 'Started') return 3;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(null, ctx))) {
    		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	var if_block1 = (ctx.$session && ctx.$session.stage === 'Ended') && create_if_block$15();

    	return {
    		c: function create() {
    			link = element("link");
    			style = element("style");
    			style.textContent = "body {\n      background: black;\n    }";
    			t1 = space();
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			document.title = "Viewer";
    			attr(link, "href", "https://fonts.googleapis.com/css?family=Schoolbell");
    			attr(link, "rel", "stylesheet");
    			add_location(link, file$1E, 39, 2, 1122);
    			add_location(style, file$1E, 40, 2, 1206);
    			attr(div, "class", "svelte-11094u3");
    			add_location(div, file$1E, 47, 0, 1283);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			append(document.head, link);
    			append(document.head, style);
    			insert(target, t1, anchor);
    			insert(target, div, anchor);
    			if (~current_block_type_index) if_blocks[current_block_type_index].m(div, null);
    			append(div, t2);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(changed, ctx);
    			if (current_block_type_index !== previous_block_index) {
    				if (if_block0) {
    					group_outros();
    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});
    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block0 = if_blocks[current_block_type_index];
    					if (!if_block0) {
    						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block0.c();
    					}
    					transition_in(if_block0, 1);
    					if_block0.m(div, t2);
    				} else {
    					if_block0 = null;
    				}
    			}

    			if (ctx.$session && ctx.$session.stage === 'Ended') {
    				if (!if_block1) {
    					if_block1 = create_if_block$15();
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				} else transition_in(if_block1, 1);
    			} else if (if_block1) {
    				group_outros();
    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			detach(link);
    			detach(style);

    			if (detaching) {
    				detach(t1);
    				detach(div);
    			}

    			if (~current_block_type_index) if_blocks[current_block_type_index].d();
    			if (if_block1) if_block1.d();
    		}
    	};
    }

    function instance$1L($$self, $$props, $$invalidate) {
    	let $sessionId, $session;

    	validate_store(sessionId, 'sessionId');
    	component_subscribe($$self, sessionId, $$value => { $sessionId = $$value; $$invalidate('$sessionId', $sessionId); });
    	validate_store(session, 'session');
    	component_subscribe($$self, session, $$value => { $session = $$value; $$invalidate('$session', $session); });

    	

      onMount(async () => {
        const response = await request(ACTIVE_SESSION);
        if (response.classSessions[0]) {
          sessionId.set(response.classSessions[0].id);
        }
        // subscribe to above
        const subscription = ws.request({ query: ACTIVE_SESSION_SUB })
          .subscribe({
            next(message) {
              if (!message.data || !message.data.classSessions) return
              sessionId.set(message.data.classSessions.node.id);
            }
          });
        return () => {
          subscription && subscription.unsubscribe();
        }
      });

    	return { $sessionId, $session };
    }

    class Viewer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1L, create_fragment$1M, safe_not_equal, []);
    	}
    }

    var routes = {
      '/': Dashboard,
      '/semesters': Semesters,
      '/students': Students,
      '/groups': Groups,
      '/sessions': Sessions,
      '/session/:id': Session,
      '/lessons': Lessons,
      '/lesson/:id': Lesson,
      '/edit-lesson/:id': EditLesson,
      '/new-lesson': CreateLesson,
      '/materials': Materials,
      '/material/:id': Material,
      '/words': Words,
      '/word/:id': Word,
      '/tags': Tags,
      '/me': Profile,
      '/viewer': Viewer,
      '/viewer/results/:id': ResultsBoard,
      '/not-found/:item/:id?': NotFound,
      '*': NotFound
    };

    /* admin/src/components/Login.svelte generated by Svelte v3.9.2 */
    const { Error: Error_1$z } = globals;

    const file$1F = "admin/src/components/Login.svelte";

    // (83:12) {:else}
    function create_else_block$p(ctx) {
    	var i;

    	return {
    		c: function create() {
    			i = element("i");
    			attr(i, "class", "fas fa-eye-slash");
    			add_location(i, file$1F, 83, 12, 2160);
    		},

    		m: function mount(target, anchor) {
    			insert(target, i, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(i);
    			}
    		}
    	};
    }

    // (81:12) {#if show}
    function create_if_block$16(ctx) {
    	var i;

    	return {
    		c: function create() {
    			i = element("i");
    			attr(i, "class", "fas fa-eye");
    			add_location(i, file$1F, 81, 12, 2101);
    		},

    		m: function mount(target, anchor) {
    			insert(target, i, anchor);
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(i);
    			}
    		}
    	};
    }

    function create_fragment$1N(ctx) {
    	var t0, div6, div5, h1, t2, h3, t4, t5, form_1, updating_value, t6, label, t8, div2, div0, input1, t9, span0, i, t10, div1, span1, t11, div4, div3, button, current, dispose;

    	var error = new Error$1({
    		props: { errors: ctx.errors },
    		$$inline: true
    	});

    	function input0_value_binding(value) {
    		ctx.input0_value_binding.call(null, value);
    		updating_value = true;
    		add_flush_callback(() => updating_value = false);
    	}

    	let input0_props = {
    		name: "usernameField",
    		type: "text",
    		label: "Username",
    		required: true,
    		leftIcon: "user"
    	};
    	if (ctx.username !== void 0) {
    		input0_props.value = ctx.username;
    	}
    	var input0 = new Input({ props: input0_props, $$inline: true });

    	binding_callbacks.push(() => bind(input0, 'value', input0_value_binding));

    	function select_block_type(changed, ctx) {
    		if (ctx.show) return create_if_block$16;
    		return create_else_block$p;
    	}

    	var current_block_type = select_block_type(null, ctx);
    	var if_block = current_block_type(ctx);

    	return {
    		c: function create() {
    			t0 = space();
    			div6 = element("div");
    			div5 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Login";
    			t2 = space();
    			h3 = element("h3");
    			h3.textContent = "gotta log in to continue.";
    			t4 = space();
    			error.$$.fragment.c();
    			t5 = space();
    			form_1 = element("form");
    			input0.$$.fragment.c();
    			t6 = space();
    			label = element("label");
    			label.textContent = "Password";
    			t8 = space();
    			div2 = element("div");
    			div0 = element("div");
    			input1 = element("input");
    			t9 = space();
    			span0 = element("span");
    			i = element("i");
    			t10 = space();
    			div1 = element("div");
    			span1 = element("span");
    			if_block.c();
    			t11 = space();
    			div4 = element("div");
    			div3 = element("div");
    			button = element("button");
    			button.textContent = "Let me in!";
    			document.title = "Login";
    			attr(h1, "class", "title");
    			add_location(h1, file$1F, 62, 4, 1298);
    			attr(h3, "class", "subtitle");
    			add_location(h3, file$1F, 63, 4, 1331);
    			attr(label, "class", "label");
    			attr(label, "for", "passwordField");
    			add_location(label, file$1F, 69, 6, 1599);
    			attr(input1, "class", "input");
    			attr(input1, "type", "password");
    			input1.required = true;
    			add_location(input1, file$1F, 73, 10, 1750);
    			attr(i, "class", "fas fa-key");
    			add_location(i, file$1F, 75, 12, 1902);
    			attr(span0, "class", "icon is-small is-left");
    			add_location(span0, file$1F, 74, 10, 1853);
    			attr(div0, "class", "control has-icons-left");
    			add_location(div0, file$1F, 72, 8, 1703);
    			attr(span1, "class", "button is-white showhide svelte-1o7mwy6");
    			add_location(span1, file$1F, 79, 10, 2002);
    			attr(div1, "class", "control");
    			add_location(div1, file$1F, 78, 8, 1970);
    			attr(div2, "class", "field has-addons");
    			add_location(div2, file$1F, 71, 6, 1664);
    			attr(button, "type", "submit");
    			attr(button, "class", "button is-primary is-loading");
    			toggle_class(button, "is-loading", ctx.loading);
    			add_location(button, file$1F, 90, 10, 2323);
    			attr(div3, "class", "control");
    			add_location(div3, file$1F, 89, 8, 2291);
    			attr(div4, "class", "field");
    			add_location(div4, file$1F, 88, 6, 2263);
    			form_1.noValidate = true;
    			add_location(form_1, file$1F, 66, 4, 1411);
    			attr(div5, "class", "login");
    			add_location(div5, file$1F, 61, 2, 1274);
    			attr(div6, "class", "container-centered svelte-1o7mwy6");
    			add_location(div6, file$1F, 60, 0, 1239);

    			dispose = [
    				listen(input1, "input", ctx.input1_input_handler),
    				listen(span1, "click", ctx.showPassword),
    				listen(form_1, "submit", prevent_default(ctx.login))
    			];
    		},

    		l: function claim(nodes) {
    			throw new Error_1$z("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, t0, anchor);
    			insert(target, div6, anchor);
    			append(div6, div5);
    			append(div5, h1);
    			append(div5, t2);
    			append(div5, h3);
    			append(div5, t4);
    			mount_component(error, div5, null);
    			append(div5, t5);
    			append(div5, form_1);
    			mount_component(input0, form_1, null);
    			append(form_1, t6);
    			append(form_1, label);
    			append(form_1, t8);
    			append(form_1, div2);
    			append(div2, div0);
    			append(div0, input1);

    			set_input_value(input1, ctx.password);

    			ctx.input1_binding(input1);
    			append(div0, t9);
    			append(div0, span0);
    			append(span0, i);
    			append(div2, t10);
    			append(div2, div1);
    			append(div1, span1);
    			if_block.m(span1, null);
    			append(form_1, t11);
    			append(form_1, div4);
    			append(div4, div3);
    			append(div3, button);
    			ctx.button_binding(button);
    			ctx.form_1_binding(form_1);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var error_changes = {};
    			if (changed.errors) error_changes.errors = ctx.errors;
    			error.$set(error_changes);

    			var input0_changes = {};
    			if (!updating_value && changed.username) {
    				input0_changes.value = ctx.username;
    			}
    			input0.$set(input0_changes);

    			if (changed.password && (input1.value !== ctx.password)) set_input_value(input1, ctx.password);

    			if (current_block_type !== (current_block_type = select_block_type(changed, ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);
    				if (if_block) {
    					if_block.c();
    					if_block.m(span1, null);
    				}
    			}

    			if (changed.loading) {
    				toggle_class(button, "is-loading", ctx.loading);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(error.$$.fragment, local);

    			transition_in(input0.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(error.$$.fragment, local);
    			transition_out(input0.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(t0);
    				detach(div6);
    			}

    			destroy_component(error);

    			destroy_component(input0);

    			ctx.input1_binding(null);
    			if_block.d();
    			ctx.button_binding(null);
    			ctx.form_1_binding(null);
    			run_all(dispose);
    		}
    	};
    }

    function instance$1M($$self, $$props, $$invalidate) {
    	

      let username = '';
      let password = '';
      let errors = '';
      let loading = false;
      let show = false;
      let submit;
      let passInput;
      let form;

      const login = async () => {
        const isValid = form.checkValidity();
        if (!isValid) {
          notifications.add({
            text: 'Please fix form errors first.',
            type: 'danger'
          });
          return
        }
        $$invalidate('loading', loading = true);
        submit.disabled = true; $$invalidate('submit', submit);
        try {
          await auth.login(username, password);
          notifications.add({ text: `Logged in as '${username}'`, type: 'success' });
        } catch (error) {
          $$invalidate('errors', errors = error);
          notifications.add({ text: 'Login failed.', type: 'danger' });
          submit.disabled = false; $$invalidate('submit', submit);
        } finally {
          $$invalidate('loading', loading = false);
        }
      };
      const showPassword = () => {
        passInput.type = !show ? 'text' : 'password'; $$invalidate('passInput', passInput);
        $$invalidate('show', show = !show);
      };

    	function input0_value_binding(value) {
    		username = value;
    		$$invalidate('username', username);
    	}

    	function input1_input_handler() {
    		password = this.value;
    		$$invalidate('password', password);
    	}

    	function input1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('passInput', passInput = $$value);
    		});
    	}

    	function button_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('submit', submit = $$value);
    		});
    	}

    	function form_1_binding($$value) {
    		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
    			$$invalidate('form', form = $$value);
    		});
    	}

    	return {
    		username,
    		password,
    		errors,
    		loading,
    		show,
    		submit,
    		passInput,
    		form,
    		login,
    		showPassword,
    		input0_value_binding,
    		input1_input_handler,
    		input1_binding,
    		button_binding,
    		form_1_binding
    	};
    }

    class Login extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1M, create_fragment$1N, safe_not_equal, []);
    	}
    }

    /* admin/src/components/NavbarLink.svelte generated by Svelte v3.9.2 */

    const file$1G = "admin/src/components/NavbarLink.svelte";

    // (25:2) {#if icon}
    function create_if_block$17(ctx) {
    	var i, i_class_value;

    	return {
    		c: function create() {
    			i = element("i");
    			attr(i, "class", i_class_value = "fas fa-" + ctx.icon + " svelte-fam8bh");
    			add_location(i, file$1G, 25, 4, 504);
    		},

    		m: function mount(target, anchor) {
    			insert(target, i, anchor);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.icon) && i_class_value !== (i_class_value = "fas fa-" + ctx.icon + " svelte-fam8bh")) {
    				attr(i, "class", i_class_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(i);
    			}
    		}
    	};
    }

    function create_fragment$1O(ctx) {
    	var a, t0, t1, a_href_value;

    	var if_block = (ctx.icon) && create_if_block$17(ctx);

    	return {
    		c: function create() {
    			a = element("a");
    			if (if_block) if_block.c();
    			t0 = space();
    			t1 = text(ctx.text);
    			attr(a, "class", "navbar-item svelte-fam8bh");
    			attr(a, "href", a_href_value = "#" + ctx.url);
    			toggle_class(a, "is-active", ctx.$location === ctx.url);
    			add_location(a, file$1G, 23, 0, 413);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, a, anchor);
    			if (if_block) if_block.m(a, null);
    			append(a, t0);
    			append(a, t1);
    		},

    		p: function update(changed, ctx) {
    			if (ctx.icon) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    				} else {
    					if_block = create_if_block$17(ctx);
    					if_block.c();
    					if_block.m(a, t0);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (changed.text) {
    				set_data(t1, ctx.text);
    			}

    			if ((changed.url) && a_href_value !== (a_href_value = "#" + ctx.url)) {
    				attr(a, "href", a_href_value);
    			}

    			if ((changed.$location || changed.url)) {
    				toggle_class(a, "is-active", ctx.$location === ctx.url);
    			}
    		},

    		i: noop,
    		o: noop,

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(a);
    			}

    			if (if_block) if_block.d();
    		}
    	};
    }

    function instance$1N($$self, $$props, $$invalidate) {
    	let $location;

    	validate_store(location, 'location');
    	component_subscribe($$self, location, $$value => { $location = $$value; $$invalidate('$location', $location); });

    	let { url = '', text = '', icon = null } = $$props;

    	const writable_props = ['url', 'text', 'icon'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<NavbarLink> was created with unknown prop '${key}'`);
    	});

    	$$self.$set = $$props => {
    		if ('url' in $$props) $$invalidate('url', url = $$props.url);
    		if ('text' in $$props) $$invalidate('text', text = $$props.text);
    		if ('icon' in $$props) $$invalidate('icon', icon = $$props.icon);
    	};

    	return { url, text, icon, $location };
    }

    class NavbarLink extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1N, create_fragment$1O, safe_not_equal, ["url", "text", "icon"]);
    	}

    	get url() {
    		throw new Error("<NavbarLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set url(value) {
    		throw new Error("<NavbarLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get text() {
    		throw new Error("<NavbarLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set text(value) {
    		throw new Error("<NavbarLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get icon() {
    		throw new Error("<NavbarLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set icon(value) {
    		throw new Error("<NavbarLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/Navbar.svelte generated by Svelte v3.9.2 */

    const file$1H = "admin/src/components/Navbar.svelte";

    // (63:4) {#if $auth.username}
    function create_if_block_2$j(ctx) {
    	var div, span0, t0, span1, t1, span2, dispose;

    	return {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			t0 = space();
    			span1 = element("span");
    			t1 = space();
    			span2 = element("span");
    			attr(span0, "aria-hidden", "true");
    			add_location(span0, file$1H, 72, 8, 1505);
    			attr(span1, "aria-hidden", "true");
    			add_location(span1, file$1H, 73, 8, 1546);
    			attr(span2, "aria-hidden", "true");
    			add_location(span2, file$1H, 74, 8, 1587);
    			attr(div, "role", "button");
    			attr(div, "class", "navbar-burger burger svelte-3cc10n");
    			attr(div, "aria-label", "menu");
    			attr(div, "aria-expanded", "false");
    			attr(div, "data-target", "navmenu");
    			toggle_class(div, "is-active", ctx.showMenu);
    			add_location(div, file$1H, 63, 6, 1254);
    			dispose = listen(div, "click", ctx.click_handler);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, span0);
    			append(div, t0);
    			append(div, span1);
    			append(div, t1);
    			append(div, span2);
    		},

    		p: function update(changed, ctx) {
    			if (changed.showMenu) {
    				toggle_class(div, "is-active", ctx.showMenu);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			dispose();
    		}
    	};
    }

    // (88:8) {#if $auth.username}
    function create_if_block_1$z(ctx) {
    	var t0, t1, t2, t3, t4, div1, span, i, t5, t6, div0, t7, t8, t9, hr, t10, current;

    	var navbarlink0 = new NavbarLink({
    		props: {
    		url: "/",
    		text: "Dashboard",
    		icon: "chalkboard-teacher"
    	},
    		$$inline: true
    	});

    	var navbarlink1 = new NavbarLink({
    		props: {
    		url: "/sessions",
    		text: "Schedule",
    		icon: "calendar-alt"
    	},
    		$$inline: true
    	});

    	var navbarlink2 = new NavbarLink({
    		props: {
    		url: "/groups",
    		text: "Groups",
    		icon: "users"
    	},
    		$$inline: true
    	});

    	var navbarlink3 = new NavbarLink({
    		props: {
    		url: "/students",
    		text: "Students",
    		icon: "address-card"
    	},
    		$$inline: true
    	});

    	var navbarlink4 = new NavbarLink({
    		props: {
    		url: "/semesters",
    		text: "Semesters",
    		icon: "school"
    	},
    		$$inline: true
    	});

    	var navbarlink5 = new NavbarLink({
    		props: { url: "/lessons", text: "Lessons" },
    		$$inline: true
    	});

    	var navbarlink6 = new NavbarLink({
    		props: { url: "/materials", text: "Materials" },
    		$$inline: true
    	});

    	var navbarlink7 = new NavbarLink({
    		props: { url: "/words", text: "Words" },
    		$$inline: true
    	});

    	var navbarlink8 = new NavbarLink({
    		props: { url: "/tags", text: "Tags" },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			navbarlink0.$$.fragment.c();
    			t0 = space();
    			navbarlink1.$$.fragment.c();
    			t1 = space();
    			navbarlink2.$$.fragment.c();
    			t2 = space();
    			navbarlink3.$$.fragment.c();
    			t3 = space();
    			navbarlink4.$$.fragment.c();
    			t4 = space();
    			div1 = element("div");
    			span = element("span");
    			i = element("i");
    			t5 = text("Contents");
    			t6 = space();
    			div0 = element("div");
    			navbarlink5.$$.fragment.c();
    			t7 = space();
    			navbarlink6.$$.fragment.c();
    			t8 = space();
    			navbarlink7.$$.fragment.c();
    			t9 = space();
    			hr = element("hr");
    			t10 = space();
    			navbarlink8.$$.fragment.c();
    			attr(i, "class", "fas fa-book svelte-3cc10n");
    			add_location(i, file$1H, 95, 12, 2332);
    			attr(span, "class", "navbar-link svelte-3cc10n");
    			add_location(span, file$1H, 94, 10, 2293);
    			attr(hr, "class", "navbar-divider svelte-3cc10n");
    			add_location(hr, file$1H, 102, 12, 2622);
    			attr(div0, "class", "navbar-dropdown svelte-3cc10n");
    			add_location(div0, file$1H, 97, 10, 2396);
    			attr(div1, "class", "navbar-item has-dropdown is-hoverable svelte-3cc10n");
    			add_location(div1, file$1H, 93, 8, 2231);
    		},

    		m: function mount(target, anchor) {
    			mount_component(navbarlink0, target, anchor);
    			insert(target, t0, anchor);
    			mount_component(navbarlink1, target, anchor);
    			insert(target, t1, anchor);
    			mount_component(navbarlink2, target, anchor);
    			insert(target, t2, anchor);
    			mount_component(navbarlink3, target, anchor);
    			insert(target, t3, anchor);
    			mount_component(navbarlink4, target, anchor);
    			insert(target, t4, anchor);
    			insert(target, div1, anchor);
    			append(div1, span);
    			append(span, i);
    			append(span, t5);
    			append(div1, t6);
    			append(div1, div0);
    			mount_component(navbarlink5, div0, null);
    			append(div0, t7);
    			mount_component(navbarlink6, div0, null);
    			append(div0, t8);
    			mount_component(navbarlink7, div0, null);
    			append(div0, t9);
    			append(div0, hr);
    			append(div0, t10);
    			mount_component(navbarlink8, div0, null);
    			current = true;
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarlink0.$$.fragment, local);

    			transition_in(navbarlink1.$$.fragment, local);

    			transition_in(navbarlink2.$$.fragment, local);

    			transition_in(navbarlink3.$$.fragment, local);

    			transition_in(navbarlink4.$$.fragment, local);

    			transition_in(navbarlink5.$$.fragment, local);

    			transition_in(navbarlink6.$$.fragment, local);

    			transition_in(navbarlink7.$$.fragment, local);

    			transition_in(navbarlink8.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(navbarlink0.$$.fragment, local);
    			transition_out(navbarlink1.$$.fragment, local);
    			transition_out(navbarlink2.$$.fragment, local);
    			transition_out(navbarlink3.$$.fragment, local);
    			transition_out(navbarlink4.$$.fragment, local);
    			transition_out(navbarlink5.$$.fragment, local);
    			transition_out(navbarlink6.$$.fragment, local);
    			transition_out(navbarlink7.$$.fragment, local);
    			transition_out(navbarlink8.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(navbarlink0, detaching);

    			if (detaching) {
    				detach(t0);
    			}

    			destroy_component(navbarlink1, detaching);

    			if (detaching) {
    				detach(t1);
    			}

    			destroy_component(navbarlink2, detaching);

    			if (detaching) {
    				detach(t2);
    			}

    			destroy_component(navbarlink3, detaching);

    			if (detaching) {
    				detach(t3);
    			}

    			destroy_component(navbarlink4, detaching);

    			if (detaching) {
    				detach(t4);
    				detach(div1);
    			}

    			destroy_component(navbarlink5);

    			destroy_component(navbarlink6);

    			destroy_component(navbarlink7);

    			destroy_component(navbarlink8);
    		}
    	};
    }

    // (112:8) {#if $auth.username}
    function create_if_block$18(ctx) {
    	var t, div, button, strong, current, dispose;

    	var navbarlink = new NavbarLink({
    		props: {
    		url: "/me",
    		icon: "user-circle",
    		text: ctx.$auth.username
    	},
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			navbarlink.$$.fragment.c();
    			t = space();
    			div = element("div");
    			button = element("button");
    			strong = element("strong");
    			strong.textContent = "Log out";
    			add_location(strong, file$1H, 117, 18, 3030);
    			attr(button, "class", "button is-text");
    			add_location(button, file$1H, 116, 12, 2962);
    			attr(div, "class", "buttons");
    			add_location(div, file$1H, 115, 10, 2928);
    			dispose = listen(button, "click", ctx.logout);
    		},

    		m: function mount(target, anchor) {
    			mount_component(navbarlink, target, anchor);
    			insert(target, t, anchor);
    			insert(target, div, anchor);
    			append(div, button);
    			append(button, strong);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var navbarlink_changes = {};
    			if (changed.$auth) navbarlink_changes.text = ctx.$auth.username;
    			navbarlink.$set(navbarlink_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarlink.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(navbarlink.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(navbarlink, detaching);

    			if (detaching) {
    				detach(t);
    				detach(div);
    			}

    			dispose();
    		}
    	};
    }

    function create_fragment$1P(ctx) {
    	var nav, div0, a, img, t0, span, t2, t3, div3, div1, t4, div2, current, dispose;

    	var if_block0 = (ctx.$auth.username) && create_if_block_2$j(ctx);

    	var if_block1 = (ctx.$auth.username) && create_if_block_1$z();

    	var if_block2 = (ctx.$auth.username) && create_if_block$18(ctx);

    	return {
    		c: function create() {
    			nav = element("nav");
    			div0 = element("div");
    			a = element("a");
    			img = element("img");
    			t0 = space();
    			span = element("span");
    			span.textContent = "Kumu";
    			t2 = space();
    			if (if_block0) if_block0.c();
    			t3 = space();
    			div3 = element("div");
    			div1 = element("div");
    			if (if_block1) if_block1.c();
    			t4 = space();
    			div2 = element("div");
    			if (if_block2) if_block2.c();
    			attr(img, "class", "logo svelte-3cc10n");
    			attr(img, "src", "kumu-logo.png");
    			attr(img, "height", "28");
    			attr(img, "alt", "levitation logo");
    			add_location(img, file$1H, 58, 6, 1087);
    			attr(span, "class", "title is-4 appname svelte-3cc10n");
    			add_location(span, file$1H, 59, 6, 1168);
    			attr(a, "class", "navbar-item svelte-3cc10n");
    			attr(a, "href", "#/");
    			add_location(a, file$1H, 57, 4, 1047);
    			attr(div0, "class", "navbar-brand svelte-3cc10n");
    			add_location(div0, file$1H, 56, 2, 1016);
    			attr(div1, "class", "navbar-start svelte-3cc10n");
    			add_location(div1, file$1H, 86, 6, 1807);
    			attr(div2, "class", "navbar-end svelte-3cc10n");
    			add_location(div2, file$1H, 110, 6, 2770);
    			attr(div3, "id", "navmenu");
    			attr(div3, "class", "navbar-menu svelte-3cc10n");
    			toggle_class(div3, "is-active", ctx.showMenu);
    			add_location(div3, file$1H, 80, 4, 1664);
    			attr(nav, "class", "navbar is-black svelte-3cc10n");
    			attr(nav, "role", "navigation");
    			attr(nav, "aria-label", "main navigation");
    			add_location(nav, file$1H, 55, 0, 937);
    			dispose = listen(div3, "click", ctx.click_handler_1);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, nav, anchor);
    			append(nav, div0);
    			append(div0, a);
    			append(a, img);
    			append(a, t0);
    			append(a, span);
    			append(div0, t2);
    			if (if_block0) if_block0.m(div0, null);
    			append(nav, t3);
    			append(nav, div3);
    			append(div3, div1);
    			if (if_block1) if_block1.m(div1, null);
    			append(div3, t4);
    			append(div3, div2);
    			if (if_block2) if_block2.m(div2, null);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.$auth.username) {
    				if (if_block0) {
    					if_block0.p(changed, ctx);
    				} else {
    					if_block0 = create_if_block_2$j(ctx);
    					if_block0.c();
    					if_block0.m(div0, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (ctx.$auth.username) {
    				if (!if_block1) {
    					if_block1 = create_if_block_1$z();
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div1, null);
    				} else transition_in(if_block1, 1);
    			} else if (if_block1) {
    				group_outros();
    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});
    				check_outros();
    			}

    			if (ctx.$auth.username) {
    				if (if_block2) {
    					if_block2.p(changed, ctx);
    					transition_in(if_block2, 1);
    				} else {
    					if_block2 = create_if_block$18(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div2, null);
    				}
    			} else if (if_block2) {
    				group_outros();
    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});
    				check_outros();
    			}

    			if (changed.showMenu) {
    				toggle_class(div3, "is-active", ctx.showMenu);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(nav);
    			}

    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			dispose();
    		}
    	};
    }

    function instance$1O($$self, $$props, $$invalidate) {
    	let $auth;

    	validate_store(auth, 'auth');
    	component_subscribe($$self, auth, $$value => { $auth = $$value; $$invalidate('$auth', $auth); });

    	

      let showMenu = false;

      const logout = async () => {
        const username = await auth.logout();
        notifications.add({ text: `Logged out user '${username}'`, type: 'success' });
      };

    	function click_handler() { showMenu = !showMenu; $$invalidate('showMenu', showMenu); }

    	function click_handler_1() { showMenu = !showMenu; $$invalidate('showMenu', showMenu); }

    	return {
    		showMenu,
    		logout,
    		$auth,
    		click_handler,
    		click_handler_1
    	};
    }

    class Navbar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1O, create_fragment$1P, safe_not_equal, []);
    	}
    }

    /* admin/src/components/Warning.svelte generated by Svelte v3.9.2 */

    const file$1I = "admin/src/components/Warning.svelte";

    function create_fragment$1Q(ctx) {
    	var div, p, i, t0, t1, t2, section, current;

    	const default_slot_template = ctx.$$slots.default;
    	const default_slot = create_slot(default_slot_template, ctx, null);

    	return {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			i = element("i");
    			t0 = space();
    			t1 = text(ctx.title);
    			t2 = space();
    			section = element("section");

    			if (default_slot) default_slot.c();
    			attr(i, "class", "fas fa-exclamation-triangle svelte-1ipf0fy");
    			add_location(i, file$1I, 36, 4, 587);
    			attr(p, "class", "warning-message-header svelte-1ipf0fy");
    			add_location(p, file$1I, 35, 2, 548);

    			attr(section, "class", "warning-message-body svelte-1ipf0fy");
    			add_location(section, file$1I, 39, 2, 652);
    			attr(div, "class", "warning svelte-1ipf0fy");
    			add_location(div, file$1I, 34, 0, 524);
    		},

    		l: function claim(nodes) {
    			if (default_slot) default_slot.l(section_nodes);
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			append(div, p);
    			append(p, i);
    			append(p, t0);
    			append(p, t1);
    			append(div, t2);
    			append(div, section);

    			if (default_slot) {
    				default_slot.m(section, null);
    			}

    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (!current || changed.title) {
    				set_data(t1, ctx.title);
    			}

    			if (default_slot && default_slot.p && changed.$$scope) {
    				default_slot.p(
    					get_slot_changes(default_slot_template, ctx, changed, null),
    					get_slot_context(default_slot_template, ctx, null)
    				);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			if (default_slot) default_slot.d(detaching);
    		}
    	};
    }

    function instance$1P($$self, $$props, $$invalidate) {
    	let { title = 'Warning' } = $$props;

    	const writable_props = ['title'];
    	Object.keys($$props).forEach(key => {
    		if (!writable_props.includes(key) && !key.startsWith('$$')) console.warn(`<Warning> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;

    	$$self.$set = $$props => {
    		if ('title' in $$props) $$invalidate('title', title = $$props.title);
    		if ('$$scope' in $$props) $$invalidate('$$scope', $$scope = $$props.$$scope);
    	};

    	return { title, $$slots, $$scope };
    }

    class Warning extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1P, create_fragment$1Q, safe_not_equal, ["title"]);
    	}

    	get title() {
    		throw new Error("<Warning>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<Warning>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* admin/src/components/sessions/CurrentSession.svelte generated by Svelte v3.9.2 */

    const file$1J = "admin/src/components/sessions/CurrentSession.svelte";

    // (25:0) {#if $todaysSessions && $todaysSessions.now && $todaysSessions.now.stage !== 'Ended'}
    function create_if_block$19(ctx) {
    	var if_block_anchor, current;

    	var if_block = (ctx.$location !== `/session/${ctx.$todaysSessions.now.id}`) && create_if_block_1$A(ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.$location !== `/session/${ctx.$todaysSessions.now.id}`) {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block_1$A(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    // (26:0) {#if $location !== `/session/${$todaysSessions.now.id}`}
    function create_if_block_1$A(ctx) {
    	var current;

    	var warning = new Warning({
    		props: {
    		title: "" + ctx.$todaysSessions.now.group.name + " class is on right now!",
    		$$slots: { default: [create_default_slot$n] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			warning.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(warning, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var warning_changes = {};
    			if (changed.$todaysSessions) warning_changes.title = "" + ctx.$todaysSessions.now.group.name + " class is on right now!";
    			if (changed.$$scope || changed.$todaysSessions) warning_changes.$$scope = { changed, ctx };
    			warning.$set(warning_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(warning.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(warning.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(warning, detaching);
    		}
    	};
    }

    // (29:6) <DL>
    function create_default_slot_1$3(ctx) {
    	var dt0, t1, dd0, t2_value = ctx.dateString(ctx.$todaysSessions.now.startsAt) + "", t2, t3, dt1, t5, dd1, t6_value = ctx.dateString(ctx.$todaysSessions.now.endsAt) + "", t6, t7, dt2, t9, dd2, t10_value = ctx.$todaysSessions.now.stage + "", t10;

    	return {
    		c: function create() {
    			dt0 = element("dt");
    			dt0.textContent = "Started:";
    			t1 = space();
    			dd0 = element("dd");
    			t2 = text(t2_value);
    			t3 = space();
    			dt1 = element("dt");
    			dt1.textContent = "Ends:";
    			t5 = space();
    			dd1 = element("dd");
    			t6 = text(t6_value);
    			t7 = space();
    			dt2 = element("dt");
    			dt2.textContent = "Status:";
    			t9 = space();
    			dd2 = element("dd");
    			t10 = text(t10_value);
    			add_location(dt0, file$1J, 29, 8, 776);
    			add_location(dd0, file$1J, 30, 8, 802);
    			add_location(dt1, file$1J, 31, 8, 862);
    			add_location(dd1, file$1J, 32, 8, 885);
    			add_location(dt2, file$1J, 33, 8, 943);
    			add_location(dd2, file$1J, 34, 8, 968);
    		},

    		m: function mount(target, anchor) {
    			insert(target, dt0, anchor);
    			insert(target, t1, anchor);
    			insert(target, dd0, anchor);
    			append(dd0, t2);
    			insert(target, t3, anchor);
    			insert(target, dt1, anchor);
    			insert(target, t5, anchor);
    			insert(target, dd1, anchor);
    			append(dd1, t6);
    			insert(target, t7, anchor);
    			insert(target, dt2, anchor);
    			insert(target, t9, anchor);
    			insert(target, dd2, anchor);
    			append(dd2, t10);
    		},

    		p: function update(changed, ctx) {
    			if ((changed.$todaysSessions) && t2_value !== (t2_value = ctx.dateString(ctx.$todaysSessions.now.startsAt) + "")) {
    				set_data(t2, t2_value);
    			}

    			if ((changed.$todaysSessions) && t6_value !== (t6_value = ctx.dateString(ctx.$todaysSessions.now.endsAt) + "")) {
    				set_data(t6, t6_value);
    			}

    			if ((changed.$todaysSessions) && t10_value !== (t10_value = ctx.$todaysSessions.now.stage + "")) {
    				set_data(t10, t10_value);
    			}
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(dt0);
    				detach(t1);
    				detach(dd0);
    				detach(t3);
    				detach(dt1);
    				detach(t5);
    				detach(dd1);
    				detach(t7);
    				detach(dt2);
    				detach(t9);
    				detach(dd2);
    			}
    		}
    	};
    }

    // (27:2) <Warning title="{$todaysSessions.now.group.name} class is on right now!">
    function create_default_slot$n(ctx) {
    	var div, t0, a, i, t1, a_href_value, current;

    	var dl = new DL({
    		props: {
    		$$slots: { default: [create_default_slot_1$3] },
    		$$scope: { ctx }
    	},
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			div = element("div");
    			dl.$$.fragment.c();
    			t0 = space();
    			a = element("a");
    			i = element("i");
    			t1 = text("  Go now");
    			attr(i, "class", "fas fa-running");
    			add_location(i, file$1J, 36, 74, 1091);
    			attr(a, "href", a_href_value = "#/session/" + ctx.$todaysSessions.now.id);
    			attr(a, "class", "button is-link svelte-1byku66");
    			add_location(a, file$1J, 36, 6, 1023);
    			attr(div, "class", "warning svelte-1byku66");
    			add_location(div, file$1J, 27, 4, 735);
    		},

    		m: function mount(target, anchor) {
    			insert(target, div, anchor);
    			mount_component(dl, div, null);
    			append(div, t0);
    			append(div, a);
    			append(a, i);
    			append(a, t1);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			var dl_changes = {};
    			if (changed.$$scope || changed.$todaysSessions) dl_changes.$$scope = { changed, ctx };
    			dl.$set(dl_changes);

    			if ((!current || changed.$todaysSessions) && a_href_value !== (a_href_value = "#/session/" + ctx.$todaysSessions.now.id)) {
    				attr(a, "href", a_href_value);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(dl.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(dl.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (detaching) {
    				detach(div);
    			}

    			destroy_component(dl);
    		}
    	};
    }

    function create_fragment$1R(ctx) {
    	var if_block_anchor, current;

    	var if_block = (ctx.$todaysSessions && ctx.$todaysSessions.now && ctx.$todaysSessions.now.stage !== 'Ended') && create_if_block$19(ctx);

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, if_block_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.$todaysSessions && ctx.$todaysSessions.now && ctx.$todaysSessions.now.stage !== 'Ended') {
    				if (if_block) {
    					if_block.p(changed, ctx);
    					transition_in(if_block, 1);
    				} else {
    					if_block = create_if_block$19(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(if_block_anchor);
    			}
    		}
    	};
    }

    function instance$1Q($$self, $$props, $$invalidate) {
    	let $todaysSessions, $location;

    	validate_store(todaysSessions, 'todaysSessions');
    	component_subscribe($$self, todaysSessions, $$value => { $todaysSessions = $$value; $$invalidate('$todaysSessions', $todaysSessions); });
    	validate_store(location, 'location');
    	component_subscribe($$self, location, $$value => { $location = $$value; $$invalidate('$location', $location); });

    	

      const dateString = (date) => {
        const dateTime = new Date(date);
        return formatDistance$1(dateTime, new Date(), { addSuffix: true })
      };

    	return { dateString, $todaysSessions, $location };
    }

    class CurrentSession extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1Q, create_fragment$1R, safe_not_equal, []);
    	}
    }

    /* admin/src/App.svelte generated by Svelte v3.9.2 */

    const file$1K = "admin/src/App.svelte";

    // (19:0) {#if $location !== '/viewer'}
    function create_if_block_3$b(ctx) {
    	var current;

    	var navbar = new Navbar({ $$inline: true });

    	return {
    		c: function create() {
    			navbar.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			current = true;
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    		}
    	};
    }

    // (30:2) {:else}
    function create_else_block$q(ctx) {
    	var current;

    	var login = new Login({ $$inline: true });

    	return {
    		c: function create() {
    			login.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(login, target, anchor);
    			current = true;
    		},

    		p: noop,

    		i: function intro(local) {
    			if (current) return;
    			transition_in(login.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(login.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(login, detaching);
    		}
    	};
    }

    // (25:2) {#if $auth.username}
    function create_if_block_1$B(ctx) {
    	var t, current;

    	var if_block = (ctx.$location !== '/viewer') && create_if_block_2$k();

    	var router = new Router({
    		props: { routes: routes },
    		$$inline: true
    	});

    	return {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			router.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert(target, t, anchor);
    			mount_component(router, target, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.$location !== '/viewer') {
    				if (!if_block) {
    					if_block = create_if_block_2$k();
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t.parentNode, t);
    				} else transition_in(if_block, 1);
    			} else if (if_block) {
    				group_outros();
    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});
    				check_outros();
    			}

    			var router_changes = {};
    			if (changed.routes) router_changes.routes = routes;
    			router.$set(router_changes);
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);

    			transition_in(router.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);

    			if (detaching) {
    				detach(t);
    			}

    			destroy_component(router, detaching);
    		}
    	};
    }

    // (26:4) {#if $location !== '/viewer'}
    function create_if_block_2$k(ctx) {
    	var current;

    	var currentsession = new CurrentSession({ $$inline: true });

    	return {
    		c: function create() {
    			currentsession.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(currentsession, target, anchor);
    			current = true;
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(currentsession.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(currentsession.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(currentsession, detaching);
    		}
    	};
    }

    // (36:0) {#if location !== '/viewer'}
    function create_if_block$1a(ctx) {
    	var current;

    	var notificationlist = new NotificationList({ $$inline: true });

    	return {
    		c: function create() {
    			notificationlist.$$.fragment.c();
    		},

    		m: function mount(target, anchor) {
    			mount_component(notificationlist, target, anchor);
    			current = true;
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(notificationlist.$$.fragment, local);

    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(notificationlist.$$.fragment, local);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			destroy_component(notificationlist, detaching);
    		}
    	};
    }

    function create_fragment$1S(ctx) {
    	var t0, main, current_block_type_index, if_block1, t1, if_block2_anchor, current;

    	var if_block0 = (ctx.$location !== '/viewer') && create_if_block_3$b();

    	var if_block_creators = [
    		create_if_block_1$B,
    		create_else_block$q
    	];

    	var if_blocks = [];

    	function select_block_type(changed, ctx) {
    		if (ctx.$auth.username) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(null, ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	var if_block2 = (location !== '/viewer') && create_if_block$1a();

    	return {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			main = element("main");
    			if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    			attr(main, "class", "svelte-e2l5fl");
    			add_location(main, file$1K, 22, 0, 527);
    		},

    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},

    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert(target, t0, anchor);
    			insert(target, main, anchor);
    			if_blocks[current_block_type_index].m(main, null);
    			insert(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert(target, if_block2_anchor, anchor);
    			current = true;
    		},

    		p: function update(changed, ctx) {
    			if (ctx.$location !== '/viewer') {
    				if (!if_block0) {
    					if_block0 = create_if_block_3$b();
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				} else transition_in(if_block0, 1);
    			} else if (if_block0) {
    				group_outros();
    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});
    				check_outros();
    			}

    			var previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(changed, ctx);
    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(changed, ctx);
    			} else {
    				group_outros();
    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});
    				check_outros();

    				if_block1 = if_blocks[current_block_type_index];
    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				}
    				transition_in(if_block1, 1);
    				if_block1.m(main, null);
    			}
    		},

    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},

    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},

    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);

    			if (detaching) {
    				detach(t0);
    				detach(main);
    			}

    			if_blocks[current_block_type_index].d();

    			if (detaching) {
    				detach(t1);
    			}

    			if (if_block2) if_block2.d(detaching);

    			if (detaching) {
    				detach(if_block2_anchor);
    			}
    		}
    	};
    }

    function instance$1R($$self, $$props, $$invalidate) {
    	let $location, $auth;

    	validate_store(location, 'location');
    	component_subscribe($$self, location, $$value => { $location = $$value; $$invalidate('$location', $location); });
    	validate_store(auth, 'auth');
    	component_subscribe($$self, auth, $$value => { $auth = $$value; $$invalidate('$auth', $auth); });

    	return { $location, $auth };
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1R, create_fragment$1S, safe_not_equal, []);
    	}
    }

    const app = new App({
      target: document.body
    });

    return app;

}());
//# sourceMappingURL=bundle.js.map
